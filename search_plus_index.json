{"./":{"url":"./","title":"Introduction","keywords":"","body":"此文件夹用于放置学习笔记 注意gitbook书写规则，当出现时，需要使用语法，详见issue "},"ES6/":{"url":"ES6/","title":"ES6","keywords":"","body":"ES6 ES6-阮一峰 ES6-继承 ES6-新数据结构 ES6-新数据类型 "},"ES6/ES6-阮一峰.html":{"url":"ES6/ES6-阮一峰.html","title":"ES6-阮一峰","keywords":"","body":"ES6学习 简介 ES6是继ES5.1之后，JavaScript语言的下一代标准 ECMA2015/2016/2017等，是ES6在每年发布的不同版本 即ES6是一个泛指，ES2015、ES2016等是其在每年六月发布的不同版本 babel转码器 将ES6代码转为ES5代码，从而在现有环境执行，不用考虑兼容问题 .babelrc文件，设置转码规则与插件 babel-cli在node下进行安装，进行命令行转码，可以将ES6标准的js文件转码为ES5标准 babel-node可以直接运行ES6代码，无需单独安装，随babel-cli一起安装 babel-register模块改写require命令，调用后，每当使用require加载.js、.jsx、.es、.es6后缀名文件。会先使用babel进行转码 使用时必须首先加载babel-register require('babel-register'); require('./index.js'); 注意 babel-register只会对require命令加载的文件进行转码，不会对当前文件进行转码 babel-register是实时转码，只适合在开发环境使用 babel-core模块：调用babel的API进行转码 var babel = require('babel-core'); // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function(err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } babel-polyfill模块 Babel默认只转换新的JavaScript句法（syntax），而不转换新的API。 如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片 let和const命令 let命令 引入块级作用域，let声明的变量仅在let命令所在代码块内有效 var a[]; for(let i=0;i for循环中，变量i由let声明，当前的i仅在本轮循环中有效，所以每一次循环的i都是一个新的变量 for循环中，整个循环是一个父作用域，其中的循环体是一个子作用域 变量提升 let命令可以变量提升，但是ES6禁止在变量在声明前使用，变量只能在声明后使用，否则抛出错误 暂时性死区 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 var tmp = 123; if(true){ tmp = 'abc';//报错 typeof tmp;//报错ReferenceError let tmp; } //块级作用域内，`let`声明变量前，该变量不可用，哪怕外部由同名变量 变量未声明前使用typeof操作符也会报错 var x = x;//不会报错 let x = x;//报错 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 不允许重复声明 let不允许在同一个作用域内重复声明同一个变量 不能再函数内部重新声明参数 块级作用域 ES5只有全局作用域和函数作用域没有块级作用域 * 内层变量可能会覆盖外层变量 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = 'hello world'; } } f();//undefined 函数内部变量提升，导致tmp声明被提升到函数刚开始的地方，所以返回undefined * 用于计数的循环变量泄露为全局变量，导致闭包的出现 var s = 'hello'; for (var i = 0; i ES6块级作用域 let为JavaScript新增了块级作用域，块级作用域的出现使得立即执行函数不再必要 * 一个代码块就是一个块级作用域 * 块级作用域可以任意嵌套 * 外层作用域无法读取内层作用域的变量 * 内层作用域可以定义外层作用域的同名变量但不影响外层 块级作用域中的函数声明 ES6规定块级作用域中可以声明函数，此函数在块级作用域外无法访问 但是，为了与老版本兼容，实际处理时，会将其转化为var形式的函数表达式处理，进行变量的提升等工作，所以应该尽量避免在块级作用域中声明函数 do表达式 暂时为提案，不了解 const命令 声明只读常量，一旦声明，常量值不可改变 const一旦声明变量，就必须立刻初始化，不能留到以后赋值，否则会报错 const声明的变量与let相似，同一作用域内不能重复声明，存在暂时性死区，声明后才能使用 const实际上保证的是变量指向的的栈内存地址的值不得改动。 对于简单类型的数据，值就保存在变量指向的栈内存地址中，因此等同于常量。 对于引用类型的数据，变量指向的栈内存地址中存储的仅是堆内存的一个地址引用。const只能保证这个指针的值不变，即不能对这个指针重新赋值。但是对原有引用类型数据的更改，不受其影响。 真正冻结对象，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 全局变量与顶层对象 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象 ES5中，全局变量即为顶层对象的属性。但是这样会导致一些问题： 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的） 程序员很容易不知不觉地就创建了全局变量（比如打字出错） 顶层对象的属性是到处可以读写的，这非常不利于模块化编程 ES6中，对全局变量与顶层对象做了新的规定： 使用var和function声明的全局变量依旧是顶层对象的属性 使用let、const、class等命令声明的全局变量，不属于顶层对象的属性。 从ES6开始，全局变量将逐步与顶层对象的属性脱钩 变量的解构赋值 数组的解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 let [a,b,c] = [1,2,3]; 这种写法本质属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 let [foo, [[bar], baz]] = [1, [[2], 3]]; foo // 1 bar // 2 baz // 3 let [ , , third] = [\"foo\", \"bar\", \"baz\"]; third // \"baz\" let [x, , y] = [1, 2, 3]; x // 1 y // 3 let [head, ...tail] = [1, 2, 3, 4]; head // 1 tail // [2, 3, 4] //...为剩余值的意思 如果解构不成功，变量的值就等于undefined let [foo] = []; let [bar, foo] = [1]; 不完全解构，等号左边的模式，只匹配一部分等号右边的数组 let [x, y] = [1, 2, 3]; x // 1 y // 2 如果等号右边不是可遍历的结构，会报错 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值 若对应位置是个表达式，则该表达式惰性求值，即用到的时候再求值 默认值 如果变量对应位置的数值严格等于undefined，则使用默认值（null不严格等于undefined，故不会生效） 对象的解构赋值 与数组解构赋值不同，按照变量与属性的名称取值。若等号右边不能解构，则报错 变量必须与属性同名，才能取到正确的值，否则为undefined let { bar, foo } = { foo: \"aaa\", bar: \"bbb\" }; foo // \"aaa\" bar // \"bbb\" let { baz } = { foo: \"aaa\", bar: \"bbb\" }; baz // undefined 若变量与属性名不一致，则需要写成如下格式 var { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // \"aaa\" 对象的解构赋值实质为 * let {foo：baz} ={foo:\"aaa\",bar:\"bbb\"}; baz // \"aaa\" foo //error notdefined foo是匹配的模式，baz才是真正的变量，真正被赋值的是baz let { bar, foo } = { foo: \"aaa\", bar: \"bbb\" }; let { bar:bar, foo:foo } = { foo: \"aaa\", bar: \"bbb\" }; 以上两句等价，第一句是第二句的简写 此处变量依然遵循不能重复声明的原则，注意赋值格式 let foo; ({foo} = {foo: 1}); // 成功 let baz; ({bar: baz} = {bar: 1}); // 成功 此处需要用()包裹{},否则解析器会将大括号理解为一个代码块 嵌套赋值、默认值方面与数组解构赋值相同 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 // 报错 let {foo: {bar}} = {baz: 'baz'}; foo属性在等号右侧为undefined，再取子属性，就会报错 解构赋值允许等号左边的模式中，不防止任何变量名，虽无意义，但是合乎语法 ({} = [true, false]); ({} = 'abc'); ({} = []); 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 let { log, sin, cos } = Math; 将Math对象的三个方法提取出来复制给相应变量，方便使用 数组本身即为特殊的对象，其内部元素和其他属性均可进行解构赋值 let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first // 1 last // 3 字符串的解构赋值 非对象或数组的解构赋值，先将其转换为对象 此时字符串被转换成一个类数组的对象 字符串内部可以通过str[index]访问，可使用数组解构赋值。另外其本身有length属性，可使用对象解构赋值 数值和布尔值的解构赋值 数值和布尔值的toString方法，可使用对象的解构赋值 undefined和null无法转换为对象，无法对其进行解构赋值，所以会报错 函数参数的解构赋值 函数传参也可理解为解构赋值 function add([x, y]){ return x + y; } add([1, 2]); // 3 带默认值的函数传参 function move({x = 0, y = 0} = {}) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, 0] move({}); // [0, 0] move(); // [0, 0] 此例中为双重默认值。 如果函数被调用时有参数，则首先执行{x = 0, y = 0} = 参数进行赋值，再执行内部的赋值操作 如果函数被调用时没有参数，则首先执行{x = 0, y = 0} = {}进行外层默认赋值，然后再执行内层的默认赋值 圆括号的使用 变量声明语句中，不能带有圆括号 函数参数中，模式不能带有圆括号 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中 整个模式放入圆括号中 ({ p: a }) = { p: 42 }; ([a]) = [5]; 嵌套模式的一层，放在圆括号中 [({ p: a }), { x: c }] = [{}, {}]; 赋值语句的非模式部分，可以使用圆括号 用途 交换变量的值 let x = 1; let y = 2; [x, y] = [y, x]; 从函数返回多个值 return [1,2,3] 函数参数的定义 使用对象的解构赋值传参，参数无次序要求 使用数组解构赋值传参，参数有次序要求 提取JSON数据 let { id, status, data: number } = jsonData 函数参数的默认值 遍历Map结构 map、set数据结构 获取模块的指定方法 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); 字符串的扩展 字符负的Unicode表示 JavaScript可以采用\\uxxxx的方式表示字符，但是仅限0000到ffff之间，超出此范围的Unicode码必须用两个双字节来表示。 ES6中，将字符的Unicode码放入大括号中，如\\u{20BB7}便可以正确解读字符 codePointAt() 字符编码大于0xFFFF时，JavaScript会使用双字节进行表示，并认为这是两个字符 var s = \"𠮷\"; s.length // 2 s.charAt(0) // '' s.charAt(1) // '' s.charCodeAt(0) // 55362 s.charCodeAt(1) // 57271 使用codePointAt()函数，可以正确返回字符的编码 s.codePointAt(0).toString(16) // \"20bb7\" String.fromCodePoint() 此方法参数为Unicode编码，返回对应的字符，可以接受大于\\uFFFF的编码值 字符串的遍历 字符串可以使用for...of进行循环遍历，并且此遍历方法能够识别Unicode编码大于0xFFFF的字符，传统的for循环不能识别 模板字符串 模板字符窜使用反引号(`)标识，作用有 定义普通字符串 `In JavaScript '\\n' is a line-feed.` 定义多行字符串 `In JavaScript this is not legal.` 使用引号定义的字符串中不能存在换行，但是反引号内可以换行。 多行字符串内所有的空格、缩进、换行都会保存在字符串中 字符串中嵌入变量 var name = \"Bob\", time = \"today\"; `Hello ${name}, how are you ${time}?` 在模板字符串内可以使用${}引用外部变量嵌入。大括号内部可以放入任意的JavaScript表达式，可以进行运算或引用对象属性 模板字符串内可以调用函数 `foo ${fn()} bar` 模板字符串按照默认规则将大括号内的值转为字符串 模板字符串可以进行嵌套 模板编译 标签模板 标签模板：模板字符串紧跟在一个函数名后，该函数将会被调用来处理这个模板字符串，模板字符串即为函数参数 模板字符串本身即为一种函数调用方式 多参情况： 函数的第一个参数是一个数组，成员为模板字符串中没有被变量替换的部分 其他参数为模板字符串各变量被替换后的值 例如： var a = 5; var b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容，对用户输入内容中的特殊字符进行转移 模板处理函数的第一个参数（即模板字符串数组）同时具有raw属性，属性值为一个数组。其中保存着对模板字符串数组每个值转义后的字符串 tag`First line\\nSecond line` function tag(strings) { console.log(strings.raw[0]); // \"First line\\\\nSecond line\" } 字符串中的\\被转义 String.raw() String.raw方法用于充当模板字符串的处理函数，返回一个斜杠都被转义的字符串。 如果原字符串的斜杠已经被转义，则不做任何处理 String.raw函数也可Uozu哦为正常函数使用，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组 模板字符串的限制 模板字符串默认对字符串转义，导致了无法嵌入其他语言 正则的扩展 正则构造方法 new RegExp('xyz', 'i')，同ES5 /xyz/i，同ES5 new RegExp(/abc/ig,'i')，ES6新增，第二个参数的修饰符会覆盖原有正则对象的修饰符，此表达式结果相当于/abc/i 字符串的正则 字符串对象共有四种方法可以使用正则： match replace search split ES6中这四种方法全部调用RegExp的实例方法，如String.prototype.match调用RegExp.prototype[Symbol.match]等 u修饰符 正则表达式中增加u修饰符，表示“Unicode模式”，用于处理大于\\uFFFF的Unicode字符，以正确处理四个字节的UTF-16编码 u修饰符影响原有正则表达式行为 点字符. 点字符代表除了换行符之外的任意单个字符，但是对马甸大于0xFFFF的Unicode字符，点字符不能识别，需要加上u修饰符 var s = '𠮷'; /^.$/.test(s) // false /^.$/u.test(s) // true Unicode的大括号表示 当使用大括号表示Unicode字符时，必须使用u修饰符才能识别 大括号内的量词 使用u修饰符时，所有量词都可以正确识别码点大于0xFFFF的Unicode字符 /𠮷{2}/.test('𠮷𠮷') // false /𠮷{2}/u.test('𠮷𠮷') // true 使用u修饰符时，Unicode表达式中的大括号才能正确解读，不被解读为量词 /^\\u{3}$/.test('uuu') // true 在u模式下，使用正则表达式 的match方法可以正确获取字符串的长度 u模式下，可以识别非规范的字符 /[a-z]/i.test('\\u212A') // false /[a-z]/iu.test('\\u212A') // true 这两个编码都是大写的K，编码不同，但是字型很相近 y修饰符 y修饰符与g修饰符类似，从上一次匹配成功的下一个位置开始 但是y修饰符要求匹配必须从第一个字符开始，否则匹配失败 进一步说，y修饰符隐含了头部匹配的标志^,y修饰符使得头部匹配在全局匹配中都有效 正则对象的sticky属性表示是否设置y修饰符 正则对象的flags属性返回正则表达式的修饰符 字符串的转义 function escapeRegExp(str) { return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&'); } 其中$&表示整个被匹配到的子串 次函数可用于对字符串进行转义，转义后可以将字符串用于正则表达式的定义 s修饰符 一般情况下，点（·。·）能够匹配除了换行符之外的任意单个字符 s修饰符模式下，点（.）可以匹配任意单个字符，包括换行符。 注意，为反选符，匹配不包含在方括号内的任意字符 先行断言与后行断言 先行断言指只有当x在y前面时才匹配x，写法为/x(?=y)/ 先行否定断言是指只有当x不在y的前面才匹配x，写法为/x(?!y)/ ES6增加后行断言与后行否定断言 后行断言即为只有当x在y后面时才匹配x，写法为/(? 后行否定断言是指只有当x不在y的后面才匹配x，写法为/(? 后行断言需要先匹配x，再回到左边匹配y，是从右向左的执行顺序，在贪婪匹配中，是右边尽可能多的匹配字符 Unicode属性类 暂时不用 数值的扩展 二进制与八进制 二进制：0b或者0B 八进制：严格模式下使用0o 将0b与0o前缀字符串转化为十进制需要使用Number()方法 Number.isFinite(),Number.isNaN() Number.isFinite()检测参数是否为有限的。仅对Number类型的有限值返回true，其余均返回false Number.isNaN()用于检测参数是否为NaN 传统的isFinite()与isNaN()方法会先调用Number()完成数据类型转换再进行判断，新的方法对非数据类型值，全部返回false Number.parseInt()与Number.parseFloat() 在ES6中，全局方法parseInt()与parseFloat()被移植到Number对象上，行为不变 目的为逐步减少全局性方法，增强模块化 Number.isInteger() 函数用于判断一个值是否为整数。 注意： 此处依然是直接判断，不做类型转换 JavaScript中，整数与浮点数存储方法相同，故3.0和3被视为同一个值 Number.EPSILON Number.EPSILON是一个极小的常量，用于在浮点数计算时设置一个误差范围。其实质即为一个可以接受的误差范围 Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // '0.00000000000000022204' 如果误差小于Number.EPSILON，即可认为得到了正确结果 5.551115123125783e-17 安全整数与Number.isSafeInteger() JavaScript能够准确表示的的整数范围是-2^53到2^53之间，不包含两个端点。因此设置两个常量，表示范围的上下限 安全整数 Number.MAX_SAFE_INTEGER范围的上限 Number.MIN_SAFE_INTEGER范围的下限 函数umber.isSafeInteger()用于判断整数是否在准确表示的范围内。返回true有四项要求 类型为数值 数值是整数 大于范围的下限 小于范围的上限 函数的实现： Number.isSafeInteger = function (n) { return (typeof n === 'number' && Math.round(n) === n && Number.MIN_SAFE_INTEGER 当验证运算结果是否安全时，需要对参与运算的数组也进行验证，否则很容易出错 Number.isSafeInteger(9007199254740993 - 990) // true 9007199254740993 - 990 // 返回结果 9007199254740002 // 正确答案应该是 9007199254740003 实例中第一个数组已经不是安全数字，在计算机内部存储时已经出错，所以运算结果是错误的 Math对象的扩展 Math.trunc()用于返回一个数字的整数部分，内部会调取Number()方法。对空值和无法截取整数的值，返回NaN Math.sign()用于判断一个数是正数、负数或者零 参数为正数返回1 参数为负数返回-1 参数为0返回0 参数为-0返回-0 其他值返回NaN Math.cbrt()计算一个数的立方根，内部会调用Number方法 Math.clz32()返回一个数的32位无符号整数形式有多少个前导0，此函数与左移运算符相关 Math.signbit()判断一个数的符号位是否设置了 指数运算符 指数运算符** let a = 2; a **= 2;//a=a*a a **= 3;//a=a*a*a 对于过大数字的计算，可能会有差异 函数的扩展 默认参数 函数的参数默认声明，不能再用let或者const重复声明 函数默认值与解构赋值相结合 注意参数取默认值的顺序 {x=0,y=0} = {} {x,y} = {x:0,y:0} 参数默认值的位置 一般的，定义了默认值的参数应该放在函数参数的尾部，简化传参，否则无法省略该参数，因为还要对该参数后面的参数传参 可以使用undefined触发函数的默认值，null不能触发默认值 函数的length属性 函数的length属性将返回第一个有默认值参数之前的参数个数 指定默认值后，length属性将会失真、length参数意义在于函数预期传入的参数个数，指定默认值后，预期参数就不包括这个参数 当设置了默认值的参数不是尾参数时，length属性不再计入后面的参数 默认参数的作用域链 设置参数的默认值后，参数会形成一个不同于函数作用域的单独作用域链，在初始化结束后，此作用域就会消失。如果不设置参数默认值，不会出现这种作用域 参数作用域中包含本函数的所有参数，父作用域是函数的外层作用域，与函数本身作用域无关 function foo (y = x) { let x = 2; }//报错，父作用域下未定义x let x = 2; functon f00 (x,y = x) { }//在参数作用域中，y的默认值现在本作用域中查找，指向第一个参数x functon f00 (y = x) { }//在参数作用域中无x，所以y的默认值指向父作用域中的x function foo (x = x) { }//报错，参数作用域中形成暂时性死区 指定不可省略参数 为不可省略的参数指定默认值为一个错误抛出函数，在定义的时候在函数名后加括号。当函数执行时，如果未对该参数赋值，则执行错误抛出函数抛出错误 另外，可以将参数默认值设置为undefined，表明该参数是可以省略的 rest参数 使用rest参数获取函数多余的参数，避免使用arguments对象。 rest参数形式为...values,values为一个数组，该变量将多余的变量放入数组中 利用rest参数可以向函数传入任意多个参数，函数的length属性不包括rest参数 rest参数后不能再有其他参数，否则会报错 严格模式 ES5中函数可以设置严格模式，ES6对其做了修改 规定函数参数使用默认值、解构赋值、扩展运算符，函数内部就不能现实的定义为严格模式，否则会报错 name属性 函数的name属性返回函数的函数名 将匿名函数赋值给变量，ES6中name属性返回实际的函数名，ES5中返回空字符串 将具名函数赋值给变量，ES5和ES6中都会返回函数原来的名字 Function构造函数返回的函数实例，name属性的值为anonymous bind返回的函数，name属性值会加上bound前缀 箭头函数 var f = v => v; //等价于 var f = function (v) { return v; } 当函数不需要参数或者需要多个参数时，可以使用圆括号代表参数部分 var f = () => 5; 当箭头函数的代码块多于一条语句时，使用大括号将其包裹起来 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 var getTempItem = id => ({ id: id, name: \"Temp\" }); 箭头函数重点 箭头函数自身没有this对象，其内部使用的this，是定义时所在的对象，不是使用时所在的对象 箭头函数不可以作为构造函数 箭头函数了内部没有arguments对象，可以使用rest对象代替 箭头函数不能用作Generator函数 箭头函数中不存在：this、arguments、super、new.target 箭头函数不能使用call、apply、bind改变this指向 嵌套的箭头函数 箭头函数之间的互相嵌套 绑定this ES7中提出函数绑定运算符，双冒号(::) 双冒号左边是一个对象，右边是一个函数，运算符会将左侧的对象作为上下文环境，绑定到右侧的函数上 foo::bar; // 等同于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); 如果双冒号左侧为空右侧为一个对象的方法，则等于将该方法绑定在该对象上面、 var method = obj::obj.foo; // 等同于 var method = ::obj.foo; 尾调用 指一个函数的最后一步是调用另一个函数 function foo (x){ return g(x); } 以下情况不属于尾函数调用 function foo (x){ g(x); } 上面函数中最后一步还有return undefined 尾调用优化 函数调用时会在内存中形成调用记录，又称调用帧，用于保存调用位置与内部变量等信息，所有的调用帧形成调用栈。A调用B，则A调用帧的上方就会形成一个B的调用帧，B执行完成后返回结果到A，B的调用帧才会消失。 但是由于尾调用是函数的最后一步操作，不需要保存外层函数的调用帧，当不需要用到外层函数中的内部变量时，直接使用内层函数的调用帧取代外层函数的调用帧即可 尾函数调用优化即为只保留内层函数的调用帧，函数的每次执行只有一项调用帧，节省内存 只有内层函数不需要用到外层函数的变量时才会用到尾函数优化 严格模式 尾调用优化仅在严格模式下开启 函数中存在的arguments和caller两个变量可以跟踪函数的调用栈，尾调用优化时，函数调用栈改写，两个变量失真。而严格模式下禁用这两个变量，故尾调用仅在严格模式下使用。 尾递归优化 递归函数尾调用自身即为尾递归 递归调用时生成递归帧较多，容易发生栈溢出。当使用尾调用优化时，确保最后一步只调用自身，只存在一个调用帧，永远不会发生栈溢出。 递归函数改写 尾递归的实现需要确保函数最后一步调用自身，将所有用到的内部变量改写为函数的参数 由于函数参数增加后不易读，故需要改写递归函数。递归函数的改写分为两种 将尾递归函数包裹在正常形式函数中 函数柯里化，使用单参数+默认传参的形式 function currying(fn, n) { return function (m) { return fn.call(this, m, n); }; } function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } const factorial = currying(tailFactorial, 1); factorial(5) // 120 尾递归优化的实现 此处主要指非严格模式下实现尾递归优化，其主要原理为用循环代替递归，将递归调用条件变为循环控制条件 蹦床函数可以将递归执行转化为循环执行 function trampoline(f) { while (f && f instanceof Function) { f = f(); } return f; } 真正尾递归优化实现 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y > 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 本例中，只有第一次调用sum函数时会进入if判断中，后续的sum函数调用均不会执行if中内容，其作用仅为向accumulated数组添加参数，每次执行返回值均为undefined 函数参数后的尾逗号 ES2017允许在函数在定义和调用时参数列表的最后添加一个逗号 function clownsEverywhere( param1, param2, ) { /* ... */ } clownsEverywhere( 'foo', 'bar', ); 其作用为当参数分行写时，避免因为新添加参数导致最后一行在版本管理系统中出现改动 数组扩展 Array.from() 此方法用于将类数组对象与可遍历对象转换为数组，即任何具有length属性的对象，都可以被转换为数组 类数组对象：DOM中的NodeList集合，函数的arguments参数对象 可遍历对象：具有iterator接口 在ES5中，此类转化可以使用原型链的方法解决 let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c'] // ES6的写法 let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 扩展运算符也可以将具备iterator接口的数据结构转换为数组 var array = [...arguments]; var array = [...document.querySelectorAll('div')] Array.from()可以把任何具有length属性的对象转换为数组，如 var array = Array.from({length:3}); //[undefined,undefined,undefined] Array.from()第二个参数为一个函数，作用类似于数组的map遍历 Array.from([1,2,3],(x)=>x*x); function typesOf () { return Array.from(arguments, value => typeof value) } typesOf(null, [], NaN) // ['object', 'object', 'number'] Array.from()可以将字符串转化为数组然后求长度，避免js将大于\\uffff的Unicode字符算作两个字符 Array.of() 此方法将一组值转换为数组，用于弥补传统数组构造函数Array()因为参数数目不同导致的行为差异. 与数组构造函数相比，Array.of()可以代替Array()或new Array()，不存在由于参数不同导致的重载，行为统一 Array.of()方法可以使用ES5中数组的slice原型方法代替实现 function ArrayOf () { return [].slice.call(arguments) } copyWithin()方法 在数组内部将指定位置的值复制到其他位置，会覆盖原有成员，然后返回当前数组。（此方法会改变当前数组） Array.prototype.copyWithin(target, start = 0, end = this.length) * target（必需）：从该位置开始替换数据。被替换的数目与复制的数目相同 * start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 * end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 [1,2,3,4,5].copyWithin(0,3,4) // [4,2,3,4,5] [1,2,3,4,5].copyWithin(0,2) // [3,4,5,4,5] find()和findIndex() 这两个方法的参数为回调函数，回调函数类似于map方法的回调函数。数组成员依次执行该回调函数直到找到第一个返回true的成员 find()方法可以依据条件查找数组中第一个符合条件的项，返回该项。如果没有查找到返回undefined findIndex()方法可以依据条件查找数组中第一个符合条件的项，返回该项的位置，如果没有查找到返回-1 这两个方法可以弥补indexOf不能识别某些数组成员的问题 fill() 使用给定值填充数组 ['a','a','a'].fill(7) // [7,7,7] new Array(3).fill(7) // [7,7,7] 第二和第三个参数用于指定填充的起始和结束位置，填充不包括结束位置 ['a','a','a','a','a'].fill(7,1,3) // ['a',7,7,7,'a'] entries() keys() values() 三种对数组的遍历方法，返回一个遍历器对象 entries(): 对键值对的遍历 keys(): 对键名的遍历 values(): 对键值的遍历 includes() 返回一个布尔值，表明数组中是否包含给定的值，与字符串includes方法相似。对NaN也适用 第二个参数指定搜索开始位置，负值为倒数，大于数组长度值会重置为0 indexOf方法不够直观，对NaN不支持 注意Map与Set中has方法的区别 Map中has方法用于查找键名 Set中has方法用于查找键值 数组的空位 数组中的空位没有任何值，也不是undefined。 0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 一个位置的值如果是undefined，也是有值的分 ES6中明确将空位转为undefined，数组的新增的各种遍历或替换方法不会忽略空位。但是旧的遍历方法如map会跳过空位 由于空位处理规则不一致，避免在数组中出现空位 对象的扩展 属性与方法的简洁表示 直接写入变量和函数，最为对象的属性和方法 function f(x, y) { return {x, y}; } 属性名为变量值，属性值为变量值 const o = { method() { return \"Hello!\"; } }; 方法定义简写 属性赋值器与取值器的简写 const cart = { _wheels: 4, get wheels () { return this._wheels; }, set wheels (value) { if (value 简写的属性名为字符串，不会与关键字冲突 generator函数的定义在函数名前加*即可 const obj = { * m() { yield 'hello world'; } }; 属性名表达式 使用标识符作为属性名 使用表达式作为属性名 let lastWord = 'last word'; const a = { 'first word': 'hello', [lastWord]: 'world' }; a['first word'] // \"hello\" a[lastWord] // \"world\" a['last word'] // \"world\" 方法名也可以使用表达式定义 属性名表达式与简洁表示法不能同时使用 note：属性名表达式如果是一个对象，则会自动将对象转化为[object Object] 方法的name名 方法的name属性返回函数名 如果对象的方法使用了getter和setter，则name属性位于该方法的属性描述对象的get与set上面，返回值为方法名前加get与set const obj = { get foo() {}, set foo(x) {} }; obj.foo.name // TypeError: Cannot read property 'name' of undefined const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo'); descriptor.get.name // \"get foo\" descriptor.set.name // \"set foo\" bind方法创造的函数，name属性返回bound + 原函数名 Function构造函数创造的函数，name属性返回anonymous 如果对象的方法名是一个symbol值，name属性返回symbol的描述 object.is() 同值相等，与严格比较运算符行为基本一致，区别在于 +0 不等于 -0 NaN 等于 NaN ES5部署object.is Object.defineProperty(Object, 'is', { value: function(x, y) { if (x === y) { // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; } // 针对NaN的情况 return x !== x && y !== y; }, configurable: true, enumerable: false, writable: true }); objec.assign() 基本用法 用于对象合并，将源对象所有可枚举属性复制到目标对象，包括对象内部的方法忽略继承属性与不可枚举属性 复制时仅会拷贝属性的值，忽略其背后的get与set方法 Object.assign(target, source1, source2); 同名属性后面的属性覆盖前面的属性 若只有一个参数 参数类型为对象，直接返回该参数 若该参数不是对象，转化为对象后返回 非对象参数（number、string、bool）出现在source位置 字符串会以数组形式拷入目标对象 其他值忽略 参数中有无法转化为对象的值，如undefined与null 若该值位于首位，则报错 若该值不位于首位，则忽略 note 浅拷贝 Object.assign只进行浅拷贝 同名属性替换 同名属性后者覆盖前者 数组处理 数组按照对象进行处理，key与value 取值函数处理 针对取值函数，对其求值后复制进目标对象中 const source = { get foo() { return 1 } }; const target = {}; Object.assign(target, source) // { foo: 1 } 常见用途 为对象添加属性 为对象添加方法 克隆对象，只能克隆自身属性 克隆继承属性： function clone(origin) { let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin); } 合并多个对象 为属性指定默认值 由于是浅拷贝，尽量只操作简单类型值 属性的可枚举性和遍历 可枚举性 Object.getOwnPropertyDescriptor属性获取对象特定属性的描述对象 let obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, 'foo') // { // value: 123, // writable: true, // enumerable: true,可枚举性 // configurable: true // } enumerable属性代表可枚举性，该属性为false时，代表该属性不可枚举，以下操作会忽略不可遍历属性 for...in 循环：只遍历对象自身的和继承的可枚举属性 Object.keys()：返回对象自身所有可枚举属性的键名 JSON.stringify()：串行化对象自身的可枚举属性 Object.assign()：只拷贝对象自身的可枚举属性 所有class的原型方法都是不可枚举的 属性的遍历 for...in：遍历对象自身和继承的可枚举属性 Object.keys(obj):返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj):返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 遍历规则： 首先遍历所有的数值键，按照数值升序排列 其次遍历所有的字符串键，按照加入时间升序排列 最后遍历所有的symbol键，按照加入时间升序排列 Object.getOwnPropertyDescriptors：与Object.getOwnPropertyDescriptor类似，返回对象所有自身属性的描述对象 const obj = { foo: 123, get bar() { return 'abc' } }; Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } 方法实现：使用Reflect.ownKeys()与Object.getOwnPropertyDescriptor可以实现该函数 用法： 避免Object.assign()函数拷贝对象时无法正确拷贝get与set属性。通过获取到所有属性的descriptor在使用assign进行合并 配合Object.create方法，将对象属性克隆到一个新的对象，完成浅拷贝 note Object.create(proto, [propertiesObject])函数会新创建一个对象，proto作为新创建对象的原型对象，第二个可选参数添加到新创建对象自身的可枚举属性中，作为其属性描述符以及相应的属性名称 如果不显示声明，第二个参数中的属性默认不可遍历 完成对象继承 完成对象继承的几种办法： create const obj = Object.create(prot); obj.foo = 123; create + assign const obj = Object.assign( Object.create(prot), { foo: 123, } ); create + getOwnPropertyDescriptors const obj = Object.create( prot, Object.getOwnPropertyDescriptors({ foo: 123, }) ); __proto__属性,Object.setPrototypeOf(),Object.getPrototypeOf() __proto__属性 用于获取当前对象的原型对象，不建议使用，尽量使用一下函数代替 Object.setPropertyOf()：写操作 Object.getPropertyOf()：读操作 Object.create()：生成操作 Object.setPropertyOf() 用于设置对象的原型对象 Object.setPrototypeOf(object, prototype) 如果第一个参数不是对象，会将其转化为对象，最终返回的还是第一个参数 如果第一个参数不能转化为对象，即null和undefined，报错 Object.getPropertyOf() 获取参数的原型对象 如果参数不是对象，会自动转为对象 如果参数不能转换为对象，报错 super this关键字指向函数所在的当前对象，super指向当前对象的原型对象 super表示原型对象时，只能用在对象的方法中，而且只能用在对象方法的简写方式中 super.foo 等同于 Object.getPrototypeOf(this).foo（针对属性）或 Object.getPrototypeOf(this).foo.call(this)（针对方法） Object.keys()，Object.values()，Object.entries() Object.keys() ES5引入 Object.values() 返回一个数组，其中成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值，并过滤key为symbol的属性 遍历顺序与之前介绍的顺序相同 若参数不为对象，会将其转换为对象 由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组 Object.entries 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组，并过滤key为symbol的属性 用途： 构建Map对象 遍历对象属性 对象扩展运算符 解构赋值 let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } 解构赋值只能是等号左边最后一个参数 解构赋值等号右边必须是一个对象或者可以转化为对象，否则报错 解构赋值仅赋值自身属性 解构赋值浅拷贝 用于扩展对象输入 扩展运算符 对象的扩展运算符用于出去参数对象的所有可遍历属性，拷贝到当前对象中 let z = { a: 3, b: 4 }; let n = { ...z }; n // { a: 3, b: 4 } 注意： 扩展运算符后面可以使用表达式 const obj = { ...(x > 1 ? {a: 1} : {}), b: 2, }; 扩展运算符参数为null或undefined会被忽略 扩展运算符的参数列表中，如果有取值函数get，函数会被执行 用途： 对象的克隆 完整克隆一个对象包括对象原型+对象实例本身 // 写法一 const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj ); // 写法二 const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ) 对象的合并 let ab = { ...a, ...b }; // 等同于 let ab = Object.assign({}, a, b); 同名属性后面的属性值会覆盖前面的属性值，自定义属性放在前面为默认属性值，自定义属性放在后面为强制修改 let aWithOverrides = { ...a, x: 1, y: 2 }; 修改现有对象部分属性 let newVersion = { ...previousVersion, name: 'New Name' // Override the name property }; "},"ES6/ES6-继承.html":{"url":"ES6/ES6-继承.html","title":"ES6-继承","keywords":"","body":"继承 mixin、extend、proxy多重继承 mixin是一种实现多重继承的方式，允许向一个类里面注入一些代码，使得一个类的功能能够“混入”另一个类 "},"ES6/ES6-新数据结构.html":{"url":"ES6/ES6-新数据结构.html","title":"ES6-新数据结构","keywords":"","body":"数据结构 set 基础 新数据结构，类似于数组，成员值唯一，没有重复 Set是一个构造函数，用于生成Set数据结构，使用add向其中添加成员 const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x)); Set构造函数接收一个数组或者其他具有iterable接口的数据结构（如类数组对象）作为参数 const set = new Set([1, 2, 3, 4, 4]); const set = new Set(document.querySelectorAll('div')); Set可以用于去除数组重复成员，但是set不会对成员进行数据类型的转化 Set内部判断两个值是否相等算法类似于精确相等运算符（===），区别对于Set在于NaN等于NaN 属性与方法 实例属性 Set.prototype.constructor：指向构造函数Set Set.prototype.size:返回实例的成员总数 实例方法 实例方法分为操作方法与遍历方法 操作方法 add(value)：添加，返回Set结构本身 delete(value)：删除，返回bool值，表示删除是否成功 has(value)：查找，返回bool值，代表该值是否存在于实例中 clear()：清除所有成员，无返回值 Array.from()可以将Set结构转换为数组 const items = new Set([1, 2, 3, 4, 5]); const array = Array.from(items); 去除数组中重复成员方法： function dedupe(arr) { return Array.from(new Set(arr)) } 遍历操作 keys()；返回键名遍历器 values()：返回键值遍历器 由于Set结构没有键名只有键值，或者键名与键值相同，所以keys和values方法行为相同 entries()：返回键值对遍历器 如下例： let set = new Set(['red', 'green', 'blue']); for (let item of set.keys()) { console.log(item); } // red // green // blue for (let item of set.entries()) { console.log(item); } // [\"red\", \"red\"] // [\"green\", \"green\"] // [\"blue\", \"blue\"] 默认遍历器 对象的[Symbol.iterator]属性指向其for...of循环时的默认遍历器方法。 Set的默认遍历器方法即为values()方法 Set.prototype[Symbol.iterator] === Set.prototype.values 故可以直接使用for...of循环遍历Set forEach()：使用回调函数遍历每个成员 set = new Set([1, 4, 9]); set.forEach((value, key, set) => console.log(key + ' : ' + value), this) 回调函数三个参数分别为value，key和set本身，其中value和key相等 forEach的第二个参数用于指定处理函数内部的this 扩展运算符 扩展运算符内部使用for...of循环，故可以用于Set let arr = [3, 5, 2, 2, 5, 5]; let unique = [...new Set(arr)]; 目前无法再遍历时同步改变Set，可以使用其他方法辅助完成 使用Array.from() let set = new Set([1, 2, 3]); set = new Set(Array.from(set, val => val * 2)); 将原有的set结构映射为数组，再将数组转为set let set = new Set([1, 2, 3]); set = new Set([...set].map(val => val * 2)); WeakSet 与Set结构区别： 内部成员只能是对象 弱引用，不计入引用计数，成员随时可能被垃圾回收，不可遍历 WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失 WeakSet是构造函数，接收任何具有iterable接口的对象，如数组、类数组对象等 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); 定义完之后，数组的所有成员均自动成为WeakSet实例对象的成员，而WeakSet要求内部成员只能为对象，所以要求数组的每一项也必须为对象 内部方法 WeakSet.prototype.add(value)，添加 WeakSet.prototype.delete(value)，删除 WeakSet.prototype.has(value)，查找，返回布尔值 无法遍历WeakSet，所以没有size属性与froEach方法 用途 存储dom节点，不用担心内存泄漏 存储对象实例使用，且在删除实例时，不需要考虑WeakSet中的内容 map object中key只能是字符串，如果使用非字符串的key，会默认将其转化为字符串 map结构避免此类限制，各种数据类型的值都可以作为key，包括object object提供“字符串——值”的对应关系 Map提供“值——值”的对应关系，更为完善 构造实例 使用构造函数传参 const m = new Map(); const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); Map构造函数接收任何具有iterator接口、且每个成员都是一个双元素数组的数据结构作为参数，故Set和Map都可以用于生成新的Map 使用实例的set方法 const m = new Map(); const m = new Map(); const o = {p: 'Hello World'}; m.set(o, 'content') m.get(o) // \"content\" 使用实例的set方法，其参数分别为key和value 对同一个键多次赋值，后面的值将会覆盖前面 当使用对象作为key时，需要注意对象为引用类型。只有对同一个对象的引用，才会被视为同一个键 使用简单类型值作为key时，只要两个值严格相等，就会被视为同一个键 属性与方法 size：返回Map结构的成员总数 set(key, value)：返回整个Map结构 get(key)：返回对应的键值，若不存在返回undefined has(key)：返回布尔值 delete(key)：返回布尔值值，false表示删除失败 clear()：无返回值 遍历方法 keys() values() entries() forEach() Map的遍历顺序就是插入顺序，与对象的便遍历顺序相同 各方法的使用与set相同 Map与其他数据结构的转换 Map ——> 数组：扩展运算符 数组 ——> Map：Map构造函数 Map ——> 对象 function strMapToObj(strMap) { let obj = Object.create(null); for (let [k,v] of strMap) { obj[k] = v; } return obj; } 对象 ——> Map function objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } Map ——> JSON 键名均为字符串，转为对象json：JSON.stringify(strMapToObj(strMap)) 键名有非字符串，转为数组json：JSON.stringify(...strMap) JSON ——> Map 键名均为字符串：objToStrMap(JSON.parse(jsonStr)) JSON为数组，每个数组成员是本身有两个成员的数组 function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr)); } jsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]') WeakMap 区别： 只接受对象作为键名 键名弱引用，键名所指的对象不计入垃圾回收机制 用于为某个对象存储对应数据，对象被清除后，其对应的WeakMap记录自动清除，避免内存泄漏 仅键名是弱引用，键值时正常引用 方法 没有遍历操作 没有clear方法 set() get() has() delete() note 可以通过查看内存使用情况判断WeakMap的执行 典型应用 使用DOM节点作为key，为其存储数据 部署私有属性 在全局WeakMap中存储实例的私有属性，实例清除后属性消失 > node --expose-gc：表示在手动执行垃圾回收机制的情况下运行node process.memoryUsage()：查看内存使用情况 global.gc()：执行垃圾回收 "},"ES6/ES6-新数据类型.html":{"url":"ES6/ES6-新数据类型.html","title":"ES6-新数据类型","keywords":"","body":"Symbol symbol值通过symbol函数生成，独一无二，数据类型为symbol 接收字符串作为参数，进行对symbol实例的描述，在转为字符串时进行区分 let s1 = Symbol('foo'); let s2 = Symbol('bar'); s1 // Symbol(foo) s2 // Symbol(bar) s1.toString() // \"Symbol(foo)\" s2.toString() // \"Symbol(bar)\" 字符串参数的使用： 如果参数是一个对象，则调用对象的toString方法转为字符串，然后再生成symbol值 字符串参数仅表示对symbol值的描述，相同参数生成的symbol值不同 symbol值的使用： symbol值不能与其他类型的值进行运算* symbol值可以显示转化为字符串与布尔值 let sym = Symbol('My symbol'); String(sym) // 'Symbol(My symbol)' sym.toString() // 'Symbol(My symbol)' Boolean(sym) // true !sym // false symbol值不能转化为数值 symbol值作为属性名或方法名 symbol值作为属性名可以防止同名属性出现 let mySymbol = Symbol(); let s = Symbol(); // 第一种写法 let a = {}; a[mySymbol] = 'Hello!'; // 第二种写法 let a = { [mySymbol]: 'Hello!', [s]: function (arg) { ... } // [s](arg) { ... } }; // 第三种写法 let a = {}; Object.defineProperty(a, mySymbol, { value: 'Hello!' }); // 以上写法都得到同样结果 a[mySymbol] // \"Hello!\" 显示定义时，symbol值必须放入方括号中，访问时需要使用方括号语法 使用symbol定义的属性是非私有的，但是会被常规方法遍历不到 使用symbol消除魔术字符串 魔术字符串：在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值 魔术字符串应尽量减少使用，将其替换为变量的形式 对不关心具体值的变量，可以使用symbol类型进行替代，保证唯一性，不产生冲突 属性名的遍历 一般遍历会忽略symbol属性名 Object.getOwnPropertySymbols()方法会返回一个数组，包含所有的symbol属性名 const objectSymbols = Object.getOwnPropertySymbols(obj); objectSymbols // [Symbol(a), Symbol(b)] Reflect.ownKeys返回所有类型键名，包括常规与symbol 可以利用symbol属性不易被遍历到特性定义非私有、同时只希望用于内部的方法 Symbol.for()，Symbol.keyFor() Symbol.for() 接收一个字符串作为参数，定义可以重复使用的symbol值 let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true 搜索有没有以该参数作为名称的 Symbol 值 如果有，就返回这个 Symbol 值 否则就新建并返回一个以该字符串为名称的 Symbol 值 let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true symbol.for()会被登记在全局环境中以供搜索 symbol不会被登记，每次都返回新值 Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值 Symbol.keyFor 返回一个已被登记的 Symbol 类型值的key，搭配symbol.for()使用 let s1 = Symbol.for(\"foo\"); Symbol.keyFor(s1) // \"foo\" let s2 = Symbol(\"foo\"); Symbol.keyFor(s2) // undefined Symbol.for会被登记在全局环境中，可以在不同的iframe或service work中访问到同一个值 实例 使用symbol实现模块的Singleton模式，即多次调用同一个模块返回的是同一个实例 解决办法为将新建的实例存储在全局对象中，其key值为一个symbol.for建立的symbol值 优点： 由于symbol值独一无二，可以避免全局对象下属性值不经意的修改 需要修改时，可以使用symbol.for进行修改，保证自由度 不能直接使用symbol()建立的symbol值作为key。因为每一次模块的执行都会新建一个symbol值，导致每次得到的key值是不一样的。即使node会将脚本的执行结果缓存，但是并不是你绝对可靠。 内置的symbol值 ES6提供了11个内置的symbol值，以供语言内部使用 Symbol.hasInstance 对象的Symbol.hasInstance属性，指向一个内部方法 foo instanceof Foo 实际调用的是 Foo[Symbol.hasInstance](foo) 构造函数内部有Symbol.hasInstance方法，可以自行定义进行测试。如下所示 class Even { static [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; } } // 等同于 const Even = { [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; } }; 1 instanceof Even // false 2 instanceof Even // true 12345 instanceof Even // false Symbol.isConcatSpreadable 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示对象使用Array.prototype.concat()方法时，能否展开。 针对数组： 属性值默认为undefined，可以展开 属性值置为true时，也有展开效果 属性值置为false时，不展开 类数组对象： 默认不展开 属性值设为true，才可以展开 Symbol.isConcatSpreadable属性的定义，可以在类的定义中完成 在实例中定义属性 class A1 extends Array { constructor(args) { super(args); this[Symbol.isConcatSpreadable] = true; } } 在类本身中定义 class A2 extends Array { constructor(args) { super(args); } get [Symbol.isConcatSpreadable] () { return true; } } 在两个位置定义效果相同 Symbol.species Symbol.species定义的属性用于指定衍生对象的构造函数。 衍生对象： class MyArray extends Array { } const a = new MyArray(1, 2, 3); const b = a.map(x => x); const c = a.filter(x => x > 1); 其中b和c即为a的衍生对象，默认情况下b和c的构造函数与a的相同 Symbol.species属性使用get取值器定义，衍生对象使用该属性返回的函数作为构造函数。 class MyArray extends Array { static get [Symbol.species]() { return Array; } } const a = new MyArray(); const b = a.map(x => x); b instanceof MyArray // false b instanceof Array // true promise的then方法也属于创建衍生对象的过程 Symbol.match 用于字符串的match操作。 当执行str.match(myObject)时，会调用myObject内部Symbol.match方法，str作为参数注入该方法，最后返回该方法的返回值 Symbol.replace 当对象被String.prototype.replace方法调用时，会返回该方法的返回值 Symbol.replace方法接收两个参数，即调用replace的对象与替换后的值 Symbol.search 同上 Symbol.split Symbol.iterator 指向该对象的默认遍历器方法 对象进行for...of循环时，会调用Symbol.iterator方法，返回对象的默认遍历器 一般使用generator函数的yield指定每次返回值 Symbol.toPromitive 对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值 该方法被调用时接收一个字符串参数，表明当前运算的模式 Number，需要转化为数值 String，需要转化为字符串 Default，可以转化为数值也可以转化为字符串 Symbol.toStringTag 指向一个方法，当调用Object.prototype.toString时，此方法返回值将出现在toString方法返回的字符串中，表示对象的类型。 如[object Object]或者[object Array]中的第二项 Symbol.unscopables 指向一个对象，指定当对该对象使用with关键字时，在with环境中会被忽略的属性 // 有 unscopables 时 class MyClass { foo() { return 1; } get [Symbol.unscopables]() { return { foo: true }; } } var foo = function () { return 2; }; with (MyClass.prototype) { foo(); // 2 } 如上例所示，Symbol.unscopables中指定foo的值为true，表示其会被with环境忽略，故其会执行外层作用域下的foo函数 "},"HTML5/":{"url":"HTML5/","title":"HTML5","keywords":"","body":"HTML5 简介 基础概念 HTML API 元数据 HTML元素 service worker "},"HTML5/introduction.html":{"url":"HTML5/introduction.html","title":"简介","keywords":"","body":"HTML5 简介 WHATWG与W3C的纠葛 W3C原来希望发展XML，Apple、Mozilla与Opera决定成立新的WHATWG发展HTML5 W3C参与HTML5开发，二者共同更新HTML5 W3C希望发布HTML5的完成版，WHATWG希望继续不断维护 之后W3C将WHATWG做的修复复制到自身的HTML5标准中 跨站点通信 postMEssage iframe 使用具有服务器已知的唯一标识符的跨站点映像请求来启动服务器端数据交换 使用用户区分技术可以用于站点唯一的识别访问者，从而在服务器端交换信息 DOM树包含的节点： DocumentType节点 Element节点 Text节点 Comment节点 ProcessingInstructtion节点 NOTE 源码中多余的空间会被转化为TextDom文本节点 head开始标签前的所有空白会被默认丢弃 body结束标签之后的所有空白会被放置在结尾body 安全问题 用户输入验证 XSS攻击：cross-site-scripting，跨站脚本攻击 SQL注入 用户输入验证与转义 CSRF：cross-site-request-forgery，跨站请求伪造 使用隐藏令牌机制或者检查所有请求上的origin头防止攻击 点击劫持 诱拐用户，当用户即将点击鼠标时，将恶意站点的iframe放置在用户鼠标下 解决办法：不期望在框架中使用的网站只在检测到它们不在框架中时才启用它们的接口 HTML元素常见问题 事件绑定与触发时机 避免事件触发后才进行绑定事件处理程序 使用事件处理程序内容属性 在创建元素的同一脚本中添加事件处理程序，避免阻塞 "},"HTML5/common_infrastucture.html":{"url":"HTML5/common_infrastucture.html","title":"基础概念","keywords":"","body":"2 基础概念 2.1 术语 属性是指JavaScript对象属性和CSS属性 文档用于引用document对象及其后代DOM树 2.1.1 resources 2.1.3 DOM trees 只有当属性的新值与旧值不同时，才称属性值发生变化。为属性赋值是如果没有发生变化，则没有改变属性值 empty用于描述内容长度为0的属性值、文本节点或者字符串 A node A is inserted into a node B 与 a node A is removed from a node B A node is inserted into a document 与 a node is removed from a document 节点的connected与disconnected 2.6 公共DOM接口 2.6.1 在IDL属性中反映内容属性 一些IDL属性用于描述特殊的内容属性，在getting阶段可以获取内容属性，在setting阶段可以通过通过IDL属性对内容属性进行设置 IDL：Interface description language，接口描述语言 2.6.2 集合 HTMLFormControlsCollection和HTMLOptionsCollection接口都是派生自HTMLCollection接口的集合，HTMLAllCollection也是一个集合，但不是派生自HTMLCollection接口 2.6.2.1 HTMLAllCollection接口 HTMLAllCollection接口用于document.all属性的使用，其使用类似于HTMLCollection，最大区别在于其拥有更多样化的调用方法，既可以通过函数调用，也可以通过属性获取 所有的HTMLAllCollection接口都根植于Document对象，并且会筛选过滤出文档中所有的元素，所以HTMLAllCollection接口中包含Document根节点所有的后代元素 collection使用： collection.length 返回集合中元素数量 element = collection.item(index) || element = collection(index) || element = collection[index] 返回集合中第index个元素，其具体顺序由DOM树决定 element = collection . item(name) element = collection . item(name) collection = collection . item(name) element = collection . namedItem(name) collection = collection . namedItem(name) element = collection(name) collection = collection(name) element = collection[name] collection = collection[name] 根据元素ID或者name返回collection中的元素 当匹配到多个元素时，会返回一个HTMLCollection对象包含所有元素 仅button、form、iframe、input、map、meta、object、select和textarea元素可以拥有name属性 2.6.2.1 HTMLFormControlsCollection接口u "},"HTML5/structure_and_API.html":{"url":"HTML5/structure_and_API.html","title":"HTML API","keywords":"","body":"SEMANTICS, STRUCTURE, AND APIS OF HTML DOCUMENTS Document XML和HTML文档在UA中使用Document对象进行表示 Document对象的URL在其创建时被初始化，但是在Document对象的生命周期内可以被更改 当使用JavaScript代码创建一个document对象时，该对象会同时准备进行post-load和页面加载 document对象创建时，会生成document.referrer，类型是字符串，如果没有被设置，其将会是一个空字符串 每个document对象都有一个重载标志位，当调用document.open(type, replace)或者document.write()方法时，会对该标志位进行设置 重载标志位被设置后，document对象会拥有一个重载缓冲区，用于reload时document的源地址 当UA进行重载时，将会给定一个source browser context，其执行操作如下 设置source的值为浏览器上下文中当前活动的document对象的重载缓冲区 设置address为浏览器上下文中活动document对象的URL 设置HTTPS状态为活动document对象的HTTPS状态 设置Referrer-Policy头为当前活动document对象的相应头部 设置Content-Security-Policy为当前活动对象的相应头部 将浏览器上下文导航到新的body响应中，其header即为已上设置的header内容，设置相应的标志位，源浏览器上下文开始重载流程。 新建一个document对象，设置其重载标志位，将其重载缓冲区中的内容设置为浏览器上下文的源地址。当遇到任何异常情况时，抛出错误 当在重载过程中更改document的address时，将会对原地址进行覆盖 document对象 HTTPS state，HTTPS状态值，默认为none，用于标志传输document数据信道的安全属性 referrer policy，Referrer-Policy默认为空字符串，标志用户来源，Referrer-Policy与CSF介绍 CSP列表，内容安全策略，默认为空，用于检测并削弱某些特定类型的攻击 feature policy module map 资源管理 document.referrer 返回将用户导航至当前页面document的链接。如果它被隐藏或者没有相应的文档，将会返回空字符串 noreferrer类型链接可以用于阻断页面之间的引用 document.cookie 返回当前页面的http cookie。如果当前页面没有cookie或者cookie不能被当前的源获取，将会返回空字符串 cookie可以被设置 ，可以为页面增加新的cookie 如果对目标内容进行了sandboxed设置，例如对iframe设置sandbox属性，则其在获取或设置cookie时将会抛出安全性错误 document.lastModified 返回document的lastModified时间戳，如果此属性未知，则返回当前时间 document.readyState 返回文档的加载状态，取值为以下三种 loading：加载，document正在加载 interactive：互动，文档已经加载完成并且被解析，但是如图像、样式表、iframe之类的子资源仍在加载中 complete：完成，文档和所有的子资源已经完成加载。load事件即将被触发 其他事件的触发： 当次状态值发生改变时，onreadystatechange事件将会被触发 DOMContentLoaded事件将会在readyState变为interactive之后但是出于complete之前触发，事件触发时，除了异步加载的脚本之外，所有的子资源全部加载完毕 访问DOM树 document对象html元素即为document elment，其他情况将会返回null document.head 返回head元素，head元素即为html元素的子元素中第一个head元素，如果存在的话将返回此元素，否则返回null document.title 可读可写，返回当前文档的title，title值由HTML的title元素和SVG的SVG title元素给出 设置此值时，将会更新文档的title内容。如果当时没有合适的元素进行更新，将会忽略新的值 与head元素类似，title元素是DOM树中的第一个title元素，如果没有的话将会返回null document.body 可读可写，返回当前文档的body元素。 可以进行设置，替换掉原来的body元素。当新设置的值不是一个body元素或者frameset元素（此元素已被废弃可以忽略）是，将会抛错 body元素是文档中的第一个body元素或者frameset元素，如果没有的话将会返回null document.images 返回一个HTMLCollection，其中包含document中的图片元素 document.embeds,document.pluguns 返回一个HTMLCollection，其中包含document中的embed元素 document.links 返回一个HTMLCollection，其中包含document中包含链接属性的元素，如a标签和area document.forms form元素集合 document.scripts script元素集合 collection = document.getElementsByName(name) document.currentScript 返回当前正在被执行的script元素或者SVG script元素。如果当前有reentrant script正在被执行，则会返回最开始执行且尚未执行完的脚本 如果当前执行的代码是位于一个回调函数或者异步执行的，则该属性会返回null elements 定义 HTML标准中为元素、属性和属性值定义了其对应的语义，而不是专门的表现形式。其表现形式可能会根据设备或者设置的不同而变化 Elements in the DOM 元素表示DOM中的HTML元素节点实现并具有对应的相应属性。 元素可以被显式或者隐式的被引用。页面内部的跳转可以通过链接对id进行引用的形式进行 target point 所有HTML元素的基本接口都继承自HTMLElement对象 元素定义 元素定义包含以下内容 元素类别 元素使用场景 内容模型：必须包含哪些内容作为元素的子元素和后代的规范性描述 元素使用语法 内容属性：可以在元素上指定的属性 DOM接口：元素必须实现的DOM接口 属性值 除特殊声明外，元素属性值是一个字符串，可以为任意字符串值，包括空字符串，并且对此类属性值中可指定的文本没有限制 内容模型 元素的内容模型是对元素内容的预期描述。元素内容是指其DOM树中的子节点 元素之间允许存在空格，UA将这些字符作为DOM树中的Text节点，空的Text节点和仅由这些空格组成的Text节点被视为元素间的空白（inter-element whitespace） 在确定元素的内容是否与元素的内容模型匹配时，必须忽略元素间空白，注释节点和处理指令节点，并且在遵循定义文档和元素语义的算法时必须忽略它们 因此，如果A和B具有相同的父节点并且在它们之间不存在其他元素节点或文本节点（除了元素间空白），则称元素A在第二元素B之前或之后。 类似地，当一个元素除元素间空白，注释节点和处理指令节点之外只包含一个节点，则该节点是元素的唯一子节点 HTML元素可以是一个孤立节点，比如在JavaScript中可以单独的创建一个HTML元素而不进行挂载 The \"nothing\" content model 如果一个元素的内容模型是空，则其中不能包含除元素间空白外的任何文本节点和元素节点 为了方便起见，大多数元素的内容模型都是\"nothing\" are also，例如无效元素（HTML语法中没有结束标签的元素），但是这与nothing是两个概念 内容种类 每个HTML元素都属于零个或多个类别，类别划分依据为元素的不同特征，本规范中将元素划分为以下类别，详情参见 metadata content metadata content是指用于设置内容其他部分的呈现方式或行为的内容，或者用于建立文档与其他文档的关系，传递其他信息 其中包含base、link、meta、noscript、script、style、template、title等标签 flow content 其中的大部分元素用于body中的文档流内容，包含元素见文档 sectioning content 用于定义标题和页脚区域内容，包含article、aside、nav、section等元素 heading content 用于定义页面的标题部分 phrasing content 包含文档内的文本以及用于标记段落内文本的元素 部分phrasing content元素内部只能包含同一类别的元素，不能包含所有的flow content元素 embedded content embedded content用于向文档中导入其他来源的内容或者向文档中插入其他内容，如canvas、img、iframe等 一些embedded元素可能会具有备用内容，当请求的资源失败时，会展示该内容，例如img的alt属性 interactive content 交互式内容特指会与用户产生交互的内容。针对一些元素，可能存在某种条件才能与用户进行交互 Palpable content 当该内容至少具有一个节点并且不是hidden时，那么这个内容即为可触及内容 Script-supporting elements 此类元素一般不会被渲染，但是可以用于插入外部脚本，提供相应功能，如script与template 透明内容模型 部分元素在内容模型中被视作透明的，如del、ins等元素。 透明元素的内容模型由其父元素的内容模型派生而得，内容模型中“透明”部分所需的元素与父元素内容模型中所需的元素相同 段落 段落不仅限于有p元素指定的内容，其只是段落的一种表现形式。段落一般是指一个文本块或主题分组 全局属性 全局属性可以在所有元素上指定，详见文档 class、id、slot可以为所有的HTML元素指定 class属性值为一组以空格分隔的标记，表示该元素所属的各种类 使用id标记元素时，其值在整个DOM树中必须唯一，且必须至少包含一个字符，不能包含空格。id是元素的唯一标识符 slot属性用于内容的分发，具有slot属性的元素将被分配给对应name属性值的位置 可以在元素上指定其对应的事件处理函数。 一些事件句柄在window上具有同名的事件句柄，所以当其绑定在body上时与绑定在一般元素上意义不同 所有的事件都可以绑定在全部元素上，但并不是均适用于全部元素 可以在所有元素上指定自定义数据属性，用于存放对应的自定义数据、状态等内容 title属性 title属性用于表示元素的其他信息或相关描述。 如果元素未指定该属性，则其title属性取值将会依赖其最近的具有title属性的祖先元素相应取值 对元素设置该属性后，将会明确表示任何祖先元素的title信息都与该元素无关 设置title属性值为空，表明元素没有其他描述信息 如果title属性值中包含换行符，则内容将被分为多行。 lang与xml:lang属性 lang属性指定元素内容中的文字与所有包含文本的元素属性使用的语言，其取值必须为有效的BCP47语言标记或空字符串。将该属性设置为空字符串时意味着文档中使用的语言是未知的 如果元素定义中省略了该属性，则元素的语言与其父元素的相同 translate属性 translate属性是一个枚举属性，用于规定其对应元素的属性值及子文本节点的内容，是否跟随系统语言做出对应的翻译变化 属性取值： 空字符串或yes，对应yes状态，元素的转换模式处于translate-enabled状态 no对应no状态，元素的转换模式处于no-translate状态 缺省值或者无效值对应继承状态 任何情况下，文档元素的转换模式与其父元素处于相同状态 当元素处于translate-enabled状态时，元素的可翻译属性及其Text节点子元素的值将在页面本地化时进行转换 当元素处于no-translate状态时，元素的属性值及其Text节点子元素的值将在页面本地化时保持原样 dir属性 dir属性指定元素的文本方向，是一个可枚举属性，具有以下关键字和状态 ltr，映射到LTR状态，指定元素的文本内容方向是从左到右 rtl，映射到RTL状态，指定元素的文本内容方向是从右向左 auto，映射到自动状态，根据编程方式确定方向，一般为根据元素内容的第一个字符种类进行判断 该属性没有默认值和缺省值。 所有元素的方向都处于ltr或者rtl状态，其方向性的确定根据以下步骤进行匹配 如果元素dir属性处于ltr状态 如果元素是一个文档元素并且first属性未处于已定义状态（包括不存在或者是无效值） 如果元素是一个处于telephone状态的输入元素，并且dir未处于已定义状态 以上情况下元素的方向将处于ltr状态 如果元素的dir属性处于rtl状态，则其方向属性将为rtl 如果元素是处于text、search、telephone、url、email状态下的输入元素，并且其dir属性为auto 如果元素是一个textarea元素，并且dir属性是auto 如果元素的内容包含双向字符类型AL或R的字符，且在它之前不存在双向字符L型的字符，则该元素的方向性是rtl 否则，如果元素的内容不是空字符串或者元素是文档元素，则元素的方向性为ltr 否则，元素的方向性与其父元素相同 等等等等。。。。 document.dir[=value] 该属性值可读可写，返回html元素的dir属性。 可以设置为ltr、rtl或者auto代替原来html元素的dir属性值 如果没有html元素，将会返回空字符串并且忽略新设置的值 style属性 所有的HTML元素都可以设置style属性 使用style属性隐藏或显示内容，以及传递文档中未包含的其他信息，是不符合要求的 elemnt.style返回一个元素style属性的CSSStyleDeclaration对象 data-*自定义数据属性 HTML文档中元素的属性名会自动小写 每个HTML元素都可以指定任意数量的自定义数据属性 element.dataset将元素的自定义数据属性放在一个DOMStringMap中返回 获取单个自定义数据时，将之前的命名改为驼峰式作为dataset的属性值获取 innerText属性 element.innerText返回元素当前渲染的文本内容 设置该属性时，将会替代元素原来的后代，并且将设置内容中的回车换为br元素 与双向算法有关的需求 "},"HTML5/microdata.html":{"url":"HTML5/microdata.html","title":"元数据","keywords":"","body":"5 microdata 5.1 introducton microdata期望使用机器可读的标签注释内容，使用该注释提供一些页面的定制化服务或使用统一的脚本处理来自多个来源的内容 microdata使用name-value组的形式嵌套进文档，其与文档内容本身保持平行 5.1.2 基础语法 元数据由一组name-value对组成。 在元素上使用itemscope属性创建一个项目，在该元素的后代上使用itemprop属性指定name，子元素本身的value属性或其他属性指定value，所形成的所有name-value对均为父元素的元数据 属于父级元素itemscope中的元素，也可以有自身的itemscope，不属于其他scope的元素，称为顶级元数据项。 "},"HTML5/the_element_of_HTML.html":{"url":"HTML5/the_element_of_HTML.html","title":"HTML元素","keywords":"","body":"4 HTML元素 4.1 document元素 4.1.1 html元素 使用上下文： 文档的document元素中 Wherever a subdocument fragment is allowed in a compound document 内容模型： 一个head元素后跟着一个body元素 标记省略规则： 如果html元素中第一项内容不是注释的话则可以省略开始标记 如果html元素后不是紧跟着注释的话，则可以省略结束标记 DOM接口：HTMLHtmlElement html元素是整个HTML文档的根节点，使用HTMLHtmlElement对象接口 一般鼓励开发人员在html元素上指定lang属性，有助于文档解析时确定所要使用的语言规则 manifest属性给出文档的应用程序缓存清单，如果属性存在，属性值必须为可能由空格包围的有效非空URL。但是manifest所属的离线引用缓存缓存正在从标准中移除，推荐使用service workers替代 manifest仅在文档加载的初期阶段起作用，所以动态更改manifest属性不会起作用，因此manifest属性没有DOM API。但是window.applicationcache提功力访问离线应用缓存的接口 4.2 文档数据元素 4.2.1 head元素 使用上下文：html元素的第一个子元素 内容模型： 如果文档是iframe文档或者其title信息可以从更高等级的协议中获取，则head元素中可以有0个或者更多的metadata内容，但是其中最多只能有一个title元素和一个base元素（base元素用于指定一个文档中包含的所有相对URL的基本URL） 其他情况下，只能有一个或者更多的metadata内容，其中只能有一个title元素和不多于一个的base元素 标记省略规则： 如果head元素内容为空，或者head元素中第一项内容是一个元素，则可以省略开始标记 如果head元素之后不是紧跟ASCII空格或注释，则可以省略结束标记 内容属性：全局属性 DOM接口：HTMLHeadElement head元素代表Document中的元数据集合 title元素在大部分情况下都是需要的，但是当有更高等级的协议提供此信息时，title元素可以被省略，例如当HTML用于email时 4.2.2 title元素 类别：元数据内容 使用上下文：当前head元素中不包含其他的title元素 内容模型：不包含inter-element whitespace的文本 标签省略：不可省略 title元素用于表示一篇文档的标题，作者应该使用更具标示性的标题作为内容的概括 每篇文档中不能有多于一个的title元素 title.text [= value] 4.2.3 base元素 分类：元数据内容 使用上下文：当前head元素中不包含其他的title元素 内容模型：无 标签缺省：没有结束标签 href属性：指定文档中所有相对URL指定基本URL，取值为可能被空格包含的有效URL。如果指定了该属性，base元素必须写在其他任何属性值是 URL 的元素之前 target属性：超链接导航和表单提交的默认浏览上下文，指定显示结果的默认位置，即新窗口的加载位置。如果指定了该属性，base元素必须写在其他代表超链接的元素前面。取值有_self、_blank、_parent、_top base元素仅用于为文档指定基本URL和跟随超链接的默认浏览上下文，除此之外不包含其他信息 每个文档中不能包含一个以上的base元素 base元素必须包含一个href属性，一个target属性，或者两者均包含 4.2.4 link元素 分类：元数据内容，当元素用于body中时，其同时是flow content和phrasing content 使用上下文：可以使用元数据的地方。 内容模型：无 标签缺省：没有结束标签 相应属性：as、crossorigin、href等，title属性在此元素上具有特殊意义可以作为链接的标题和css样式表的名称 link元素允许在文档中链接其他来源的数据，链接的目标由href属性给定，crossorigin属性用于指定在加载相关图片时是否必须使用 CORS以防止图片被污染，属性中的rel指定link目标的类型 link元素必须有一个rel属性或者一个itemprop属性，但是不能同时两者都有，且其属性值必须为允许值 当使用rel属性，link元素有时只能在body中使用 当使用itemprop属性，link元素在body和head中均可以使用，受microdata模型限制 link元素可以创建外部资源链接和超链接两种类型链接，可以通过链接的类型指定。一个link元素可以创建多个链接，具体的链接种类和数量由rel属性给定。用户代理对每个链接单独处理，而不是针对每个元素 一个link元素创建两个超链接： link元素创建的超链接和其rel属性适用于整个文档，与其相反，a元素和area元素的rel属性表示链接的类型，其链接的上下文由文档中链接的位置给出 属性使用说明 media属性说明资源适用于哪种媒体，属性取值必须为媒体查询列表中的有效值 integrity属性表示link元素负责的请求数据是完整的元数据，取值为文本。属性只能在rel为stylesheet的link元素上使用 hreflang属性知名被连接资源的语言，与在其他元素上使用效果相同 type属性指定链接资源的MIME type，仅用于说明，取值必须为合法的MIME type值 针对外部资源链接，type属性可以帮助浏览器避免请求那些不支持的资源 referrerpolicy：设置当获取外部资源时的referrer属性 title size as color 4.2.4.1 用户跟踪使用由link元素创建的超链接 UA有时候需要提供跟踪超链接的接口，其可以由以下的属性提供： rel属性提供本文档与该资源之间的关系 title属性提供资源的title href属性提供资源的地址 hreflang属性提供资源的语言 media属性给定资源最适用的媒体类型 UA也可以提供其他信息，如通过type给定资源的类型 The activation behavior of link elements that create hyperlinks is to follow the hyperlink created by the link element.（link元素创建超链接的行为遵循由link元素创建的超链接） 4.2.5 meta标签 分类：元数据内容，指定itemprop元素可以成为flow content与phrasing comtent 使用上下文： 如果元素的charset属性指定，或者http-equiv属性处于编码状态，则要在head元素中使用 如果元素的http-equiv属性指定但不处于编码状态，则要在head元素中使用 如果元素的http-equiv属性指定但不处于编码状态，则要在head元素的noscript标签中使用 标签缺省：没有结束标签 标签属性：全局属性、name、http-equiv、content、charset meta标签用于表示不同通过title、base、link、style和script等元素展示的信息 如果标签中指定了name、http-equiv或itemprop属性，则其content属性必须被指定，否则将会忽略该属性 charset属性指定document所使用的字符编码，是一个字符编码声明。如果该属性被指定，其取值必须为与utf-8匹配的不区分大小写的ASCII码。为了便于统一，XML中允许指定charset属性，但是其无效。 每个文档中，不能在多个meta标签中同时指定charset属性 meta标签中的name属性用于定义数据属性名，同一个标签中的content用于定义属性值，如果没有的content属性，则对应的属性值为空字符串 4.2.5.1 标准数据名 文档规定了部分meta元素的name属性，name取值不区分大小写，并且必须符合ASCII码 application-name 取值必须为简短的自由格式字符串，其中包含页面所代表的web应用程序名称。如果页面不是一个web应用，则不能使用该name属性。 文档中，可以使用lang属性为不同语言指定其对应application-name，每种语言不能有多个application-name author 自由格式字符串，给定页面作者名称 description 自由格式字符串，用于描述页面，应该是对页面具有总结性的词，一个文档中最多只能出现一次 generator 只在页面由工具自动生成时使用，用于标识生成页面的软件 keywords referrer 设置文档默认的referrer policy，取值必须为一个合法的referrer policy theme-color 取值为一个合法的颜色值，定义了建议UA需要向用户展示的页面颜色，一个文档中最多出现一次 4.2.5.2 其他数据名 用户可以根据自身需求定义相关的元数据名扩展，对于这些名称没有具体的规范要求，但是一个新的元数据名称在下列情况下不应该被创建： name属性或其相关的value取值为url，此时将会被当做一个链接进行处理 name属性为UA中的标准数据名 在使用自定义数据名前，可以在WHATWG Wiki MetaExtensions page中查阅相关信息，避免选择已被使用的元数据名，避免再次定义一个已被实现的元数据，避免新标准中的名称与自定义名称冲突 WHATWG wiki大家都可以编辑，在其中加入新的元数据名称，但是要遵循一定的规则 4.2.5.3 编译指示指令 meta元素使用http-equiv属性时，该元素即为一个编译指示指令 http-equiv取值： content-type：定义文档的MIME type，由其字符编码决定 其对应的content取值为字符串'text/html; charset=utf-8' 一个文档最多只能包含一个http-equiv属性处于字符编码状态的meta元素和一个使用charset属性的meta元素 meta元素的http-equiv属性不能被用于XML文档 default-style：这个属性指定了在页面上使用的首选样式表 content属性必须包含 元素的标题, href属性链接到CSS样式表或包含CSS样式表的元素的标题 refresh：设置定时刷新 取值为： 有效的非负整数：重新载入页面的时间间隔（单位为秒） 有效非负整数，后跟一个字符串为'URL=xxx链接'：重定向到指定链接的时间间隔(单位为秒) X-UA-Compatible 当meta元素的http-equiv属性处于此状态时，对应的content属性值为\"IE=edge\"，此举是为了让IE更关注标准，UA将会忽略这条指令 content-security-policy 此指令加强文档的内容安全策略。当meta元素的http-equiv属性处于此状态时，对应content属性值必须是一个合法的内容安全策略值，但是不能包含report-uri, frame-ancestors, or sandbox directives 上例中指定文档中script标签的src只能为同源，同时禁止了插件的使用 4.2.5.4 指定文档的字符编码 编码标准与编码标签均需使用utf-8进行编码。无论是否存在字符编码声明，用于编码文档的实际字符编码必须是UTF-8。 如果一个HTML文档不是以BOM开始，同时其编码没有被content-type明确给定，并且文档也不是以iframe的形式存在于源文档中，那么必须使用meta元素的charset属性或者http-equiv属性明确指定其编码状态 如果文档以iframe的形式存在于源文档中，则该文档中不能包含字符编码声明。在此情况下，源文档中已经进行了字符解码，其中包含了iframe 使用非utf-8编码会在表单提交和URL编码过程中产生不可预期的结果 4.2.6 style元素 分类：元数据内容 使用上下文：作为head元素的子元素 内容模型：给定内容的样式表 标签省略：标签不可省略 内容属性：title属性指定css样式表的名称 DOM接口：HTMLStyleElement HTMLStyleElement/media中media属性指定style适用的媒体种类，取值必须为合法的媒体值，当省略时，相当于对所有媒体均生效 style元素不会继承父级元素的title属性 如果style元素不在DOM树上，则其title属性将会被忽略 4.3 章节元素 4.3.1 body元素 分类：章节元素根节点 内容模型：文档流 标签缺省： bod元素起始标签省略： 当body元素中的第一个元素不是meta、link、script、style或template元素是，以下情况body的起始标签可以被省略 body元素为空 body元素中第一个字符不是空格或注释 body元素结束标签省略： 当body元素后不是紧跟注释时可以省略结束标签 DOM接口：HTMLBodyElement body元素代表文档的内容，每个文档中只能有一个body元素，document.body提供了文档中body元素的使用接口 body元素将window对象上的大量事件处理函数以事件处理函数内容属性的方式暴露出来，并且镜像了事件处理函数的IDL属性，即将部分window对象上的事件，可以在body元素上进行绑定，如onerror，onLoad等 4.3.2 article元素 分类：section content 标签缺省：标签不可省略 DOM接口：HTMLElement article元素用于标识文档或页面中一个完整的或者自包含的作品，原则上讲，他是独立或者可重用的。 当article元素出现互相嵌套时，原则上内层article元素所代表内容与外层article元素是有关联的。作者信息不适合与article元素相关联。 当页面除了页眉、页脚、导航栏和侧边栏之外的内容整体是一个自包含内容，这部分内容可以被标记在一个article元素中，不过这种情况在技术上是多余的，因为整个页面显然是一个单个的文档 4.3.3 section元素 分类：section content 标签缺省：标签不可缺省 DOM接口：HTMLElement section元素表示文档中的一个段落，一个section应该有一个中心主题，并且有一个代表性的标题heading，鼓励使用article元素代替section元素，其能起到内容聚合的作用 section元素不能作为一个普适性的包含元素，当仅出于样式或者脚本需要使用元素时，建议使用div。一个通用的规则是，section元素的内容需要在文档中被明确列出。 section与article区别 section用于表示一篇文章中的一个章节，article用于表示一片独立的文章。 特别的，书评不是文章的一部分，故其也需要使用article元素 4.3.4 nav元素 分类：section content 标签不可缺省 nav元素代表页面的导航链接部分，该元素由页面的导航块组成 footer元素中也包含了部分链接，但是单独的footer元素足以满足这种情况，在此情况下不必使用nav元素 UA（如屏幕阅读器）针对省略初始渲染中的导航信息受益或者立刻使用导航信息受益两种用户，可以使用nav元素作为确定这两种方式的方法，以确保在页面初始化过程中跳过或提供某些请求 nav元素中不仅可以包含一个列表，也可以包含一些其他种类的内容，如包含链接的文本 4.3.5 aside元素 分类：section content 标签不可缺省 aside元素由与页面其他内容无关的部分组成，此部分内容可以与页面其他内容分开。在印刷排版中，此部分经常被当做侧边栏 aside元素可用于包含长的引用块、侧边栏、广告、nav元素组，或者其他可以从页面主内容中拆分出来的内容 4.3.6 h标题系列元素 分类：heading content 这些元素代表了章节标题 h1 -> h6等级逐渐降低，相同数字具有相同等级 4.3.7 hgroup元素 分类：heading content hgroup元素代表了章节的标题，其子元素为h1-h6元素。当章节具有多级标题时，如副标题或替代标题，需要用hgroup元素对标题进行分组 hgroup元素的等级与其后代元素h1-h6中等级最高的相同，其他的h系列元素作为副标题存在。 使用hgroup可以防止部分标题元素作为单独章节的标题出现，而将其作为一个标题组的次要标题 hgroup元素中同样等级的元素，先写的比后写的优先级高 4.3.8 header元素 header元素表示一组用于介绍或导航的工具 header元素不是章节型内容，它不会生成一个新章节 4.3.9 footer元素 footer元素表示其最近的祖先章节内容或章节元素的页脚，典型footer元素包含的信息包括作者、相关文档、版权声明等数据。一个完整的footer元素还应该包含附录、索引、长版本、详细许可协议和其他此类内容 当最近的祖先章节内容或章节元素是body元素时，footer元素用于整篇文档 footer元素不是章节型内容，它不会生成一个新章节 4.3.10 address元素 address元素表示距离其最近的祖先元素中article或者body元素的联系信息，当其指代body时，联系信息同时适用于整个文档 address元素不能被用于表示任何形式的地址信息（如邮政地址），除非这些地址与联系信息有关 此种情况下使用p元素表示邮政地址更为合适 address元素不能包含任何非联系信息的内容 一般address元素与其他信息一起放在footer元素中 Headings and sections section content元素集合中的第一个heading content元素将会是这个段落的标题，之后同等级或更高等级的标题元素将会开启新的段落（或隐含的段落），而低等级的标题所属段落将属于之前高等级段落的一部分 sectioning roots元素，如blockquote与body等，其自身具有概述，所以其内部的标题元素不会影响到他们自身的概述内容 鼓励显式使用section content中的元素，避免因为heading content元素的使用生成隐含的section content 鼓励仅使用h1元素或者使用与当前层级相符的heading元素。 但是仅使用h1时需要使用明确的样式规则确定相应样式，否则浏览器默认按照最高等级标题绘制 creating an outline section content元素或sectioning roots元素的概述outline由一个列表组成，其中包括一个或多个段落，可以进行嵌套 页面outline中包含了各级section的heading，包括显式与隐式的section，各级之间可以进行嵌套 相邻的标题元素如果位于同一个section元素中，则后面的标题元素将创造一个隐含的section，将该标题与本级别的内容包含进去。该section与之前同级别的section在outline中互为兄弟 Sample outlines 标题的定义不能提升，如果未对页面指定标题就开始使用section content元素，则这个页面在outline中没有标题。（此处与title元素无关） Exposing outlines to users 可以将页面outline展现给用户，当做页面导航使用 4.4 grouping content 4.4.1 p元素 p元素代表一个段落 段落通常以文本块的形式在视觉媒体中呈现，相邻的段落通过空行相分隔，不过使用css或UA以不同方式呈现段落时同样是合理的。 p元素中不能包含列表，但可以用div包含列表，使整体结构更紧凑 4.4.2 hr元素 没有结束标签 hr元素代表一个段落级别的主题转变，例如，一个故事中的场景的改变，或一个章节的主题的改变 hr元素表现为一条水平线，但是在语义上也有重要作用 hr元素不影响文档的概述outline 4.4.3 pre元素 标签不可省略 pre元素代表一块预格式化的文本，其结构由印刷约定，与元素本身无关 NOTE：HTML语法中，将会删除pre开始标签后紧跟的换行符 pre元素可以被用于以下场景： 展示email等场景，其中段落之间使用空行间隔，列表开头使用特殊符号， 展示代码片段，将会按照该语言的结构进行展示，可以搭配code标签 展示电脑输出，可以搭配samp标签 展示ASCII码 4.4.4 blockquote元素 标签不可省略 cite属性：链接到引用来源或标出有关编辑的更多信息，格式需要为由空格包围的链接 blockquote元素代表引用自其他来源的一段内容。块引用的内容可以缩写，或者可以以常规方式为文本语言添加上下文 如果要标出引用的归属，则该部分需要在blockquote元素外部 4.4.5 ol元素 其内容模型是0个或多个li元素 标签不可省略 内部属性： reverse：boolean，表示列表是正序还是倒序，true为倒序 start：int值，列表的起始值 type：列表标号的类型，可以使用css更改其样式 ol元素代表一个有序列表，改变其中元素的顺序将会改变文档的含义 4.4.6 ul元素 其内容模型是0个或多个li元素 标签不可省略 ul元素代表一个无序列表，改变顺序不会改变文档含义 4.4.7 menu元素 其内容模型是0个或多个li元素 menu元素代表一个工具栏，其内容是使用li元素表示的无序项目列表 4.4.8 li元素 可以被用于ol、ul、menu元素中 当前li元素后紧接着开始新一个li或者当前li元素的父元素上没有更多内容时，其结束标签可以省略 内部属性： value：合法int值，作为ol元素子元素时，可以使用value属性指定其序列数 li元素代表一个列表项，当其父元素是ol、ul或menu时，元素代表父元素列表中一项。否则，该元素与其他li元素没有任何列表关系 在li元素中使用标题元素不会引发语法问题，但是可能语义存在问题。标题元素会将li元素分割为多个段落 4.4.9 dl、dt、dd系列元素 标签省略： dl元素元素标签不可省略 dt元素当其后立刻跟着dt或dd元素时可以省略结束标签 dd元素当其后立刻跟着dd元素或父元素没有更多内容时可以省略结束标签 此系列元素用于术语定义以及描述 dl元素包含属于定义及描述部分，其内部可以包含多组术语 dt元素与dd 元素为一组，dt元素代表术语定义，dd 元素代表术语描述 可以在dt元素与dd元素组外部包装一层div元素，不影响dl元素语义 dt与dd 元素形成一个Name-value组，可以为一个name指定多个value，也可以为一个value指定多个name dl元素中各项的顺序需要注意，有时候这个顺序是有意义的 4.4.12 figure、figcaption元素 figure元素代表一段独立的内容，是自包含的，通常作为文档中的独立单元 自包含不是指文本必须要独立，一个完整的句子也可以自包含的，只要是完整的即可 figure元素经常用在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体。 figcaption元素作为figure元素的标题使用 4.4.14 main元素 main元素表示文档的主要内容，文档不得包含多个未指定hidden属性的main元素。 层次结构正确的main元素是其祖先元素仅限于html，body，div，没有可访问名称的form以及自主自定义元素的元素。 每个main元素必须是分层正确的main元素。 hidden属性为全局属性，表明将某一个模块从DOM树中移除 注意display:none与visibility:hidden区别,display:none将元素在DOM树中不显示，visibility:hidden仅将元素隐藏，但是元素原本所占空间保留 4.4.15 div元素 div元素无特殊含义，建议先选用其他合适的元素，最后再选择div，便于语义化与可维护性 4.5 文本级别的语义化元素 4.5.1 a元素 标签不可以省略 元素属性： href：包含超链接指向的 URL 或 URL 片段 target：指定在何处显示链接的资源，取值有tab、window、iframe等浏览器上下文名称或_self、_blank、_top等关键字 download：指定浏览器是否下载URL资源而不是导航到它，取值为下载资源的文件名 ping：包含一个以空格分隔的url列表，当跟随超链接时，将由浏览器(在后台)发送带有正文 PING 的 POST 请求。通常用于跟踪 rel：该属性指定了目标对象到链接对象的关系 hreflang：指定链接文档的语言 type：指定目标对象的MIME type类型 referrerpolicy：指定获取超链接资源时的referrer头取值 如果a元素具有href属性，则其代表由其内容标记的超链接。如果在元素上指定了itemprop属性，则必须指定href属性。 如果a元素没有href属性，则其代表了一个占位符，用于放置相关链接，a标签仅代表了元素的文本内容。当href属性未指定时，a标签上的其他自身属性全部会被忽略 a元素中可以包含除了交互式内容之外的其他任何内容，交互式内容如按钮或其他链接，即a元素中不能嵌套a元素和按钮button 4.5.2 em元素 没有标签可以省略 em元素表示对其重点内容的强调，强调的等级由其祖先中em元素的数量决定 em元素会改变句子本身的语义，其具体的使用依赖于语言。 em元素一般不用于表示斜体。当文本更倾向于以区别于段落其他部分的形式展示时，可以使用i标签斜体展示 em元素也不用于传递文本的重要性，出于此目的时，使用strong标签更为合理。strong是文档级别的强调，em是句子中的强调，强调个别单词 4.5.3 strong元素 标签不可省略 strong元素代表其内容强烈的重要性、严重性或紧急性 重要性：strong元素在标题或段落中使用时，在真正重要的元素与其他的细节或样板部分之间产生区分 严重性：strong元素可以被用于标记警告通知 紧急性：strong元素可以被用于相对页面其它部分需要被用户更先看到的内容 内容的重要性由其祖先元素中strong元素的数目决定，每个strong元素都会增加其内容的重要性 使用strong元素改变文本的重要性不会改变其语义 4.5.4 small元素 暂停元素部分 4.12.3 template element 内容模型：nothing template元素用于声明可以被脚本插入或克隆到文档其他位置的HTML片段。在渲染过程中，template元素代表空 template元素的内容并不是template的后代元素，其内容存储在与不同Document相关联的DocumentFragment中，而不是浏览器上下文，从而避免template中的内容影响主文档。其内部元素是通过template元素的content属性返回的DocumentFragment对象的子节点 template.content //返回template元素内容，即一个DocumentFragment template元素中可以包含文本节点和元素节点，但是由于其内容模型为nothing，故元素中包含任何内容都会违反template的内容模型 每个template元素都有一个与之相关联的DocumentFragment对象，其中存储着template的内容，对于内容没有一致性要求。当template元素创建时，UA必须执行如下操作 将doc设置为template元素模板中节点文档的所有者 创建一个DocumentFragment对象，其节点文档是doc，其所有者为template元素 设置template元素的模板内容是最新创建的DocumentFragment对象 clone template元素中节点的步骤： 如果没有指定深度clone标志位，则直接返回 让复制的内容是克隆节点模板内容的所有子节点的结果，文档设置为复制模板内容的节点文档，并且克隆子元素标志集 将复制的内容附加到副本的模板内容中 4.12.4 slot element slot元素定义一个slot插槽，通常用于shadow DOM树。slot元素代表其分配的节点，如果未被分配到节点，则代表其内容 name属性代表slot的name，其中可以包含任何字符串。 name属性用于将slot插槽分配给其他元素，具有name属性的slot元素创建一个命名槽，如果其他元素的slot属性值与该slot元素name属性的值相匹配，则对应元素将分配给slot插槽 slot.name：可以被用于设置或获取name属性 slot.assignNodes()：返回slot被分配到的节点 slot.assignNode({flatten: true})：返回插槽的已分配节点（如果有），否则返回插槽的子节点，并对其中遇到的任何插槽元素执行相同的操作，直到没有剩余插槽元素为止。 slot.assignElements()：返回slot被分配到的节点，仅限于元素节点 slot.assignElements({flatten: true})：与assignNodes操作相同，仅限于元素节点 4.13 custom element "},"HTML5/service-worker.html":{"url":"HTML5/service-worker.html","title":"service worker","keywords":"","body":"service worker service workers 特点 install之后会一直运行，且会自动更新 只能在HTTPS中运行，可以进行资源缓存 可以通过postMessage传递消息 不能操作DOM 单独线程运行，不会被阻塞，也不阻塞其他js，适用于复杂计算 过程 注册 此过程一般在主函数中进行，需要进行属性检测。注册时需要指定service worker文件位置，可以同时指定此worker的管理范围 安装 注册后，浏览器会尝试安装并激活，故install事件会在安装完成后触发，此事件可以被监听 install事件一般是被用来填充你的浏览器的离线缓存能力，此处需要使用cachestorage的API caches，根据指定的key存储网络请求资源。此缓存会一直持久存在，直至手动删除 整个缓存过程需要在安装完成之前完成，所以用到waitUtil方法。可以在第一个fetch事件之前完成所有缓存 localStorage是同步存储，不允许在service worker中使用 可以使用IndexDB做数据存储 激活 安装完成后service worker会被激活，activate事件可以被监听 激活一般用户删除旧缓存。当需要缓存更新时，通过key的白名单，删除旧缓存。 此过程也使用waitUtil，可以在第一个fetch事件前完成清理操作 fetch事件 通过捕捉控制scope范围内的fetch事件，service worker可以实现对所有请求的控制 捕获fetch事件后，使用event.respondWith可以劫持HTTP响应，完成各种操作，详见service workers 更新 如果你的 service worker 已经被安装，但是刷新页面时有一个新版本的可用，此时 新版会在后台安装，但是还没激活。 当不再有任何已加载的页面在使用旧版的时候，新版本才会激活。 注意此过程中 service worker的文件名不能发生变化，否则无法发现版本更新 注册的service worker名称不能发生变化，有人会在名称后面跟时间戳以实时监测sw文件更新得到最新缓存，但会导致每次都注册新的service worker，系统负担很大，得不偿失。 正确监测sw文件更新两种方法： 服务端配置sw.js为no-cache不缓存，每次更新单独请求，此方法需要单独服务端配置 将注册过程单独写入js文件，在主文件中每次带上时间戳请求最新的该文件。 在注册文件中，注册时带上上线版本号，保证每上线一次，会且只会重新注册一个新的sw，立即完成新文件缓存 详见：service worker更新 新旧版之间可以通过key区分cache，注意旧cache的删除 Q&A 不同路径下注册 Q：/a路径下能否注册根路径下的service worker A：可以，注册之后访问根路径时该service worker也会使用，此时资源来源为from disk cache。不过要注意对不同路径所需资源的支持，此处需要缓存文件列表与fetch请求监听的共同支持，尤其是在单页面应用上，vuerouter的history模式下不同路径会访问同一份资源 断网unregister后不同路径下的不同表现 Q：断网情况下，unregister掉/a路径注册在根路径下的service worker，此时再刷新页面a的确无法访问。但是转而访问根路径页面可以访问，观察到一个新的worker被重新注册并获取资源，何处注册，何处拿到资源？ A：在devtools的network中可以发现，断网unregister后页面来源为from disk cache，故页面资源从硬盘缓存中获取，并在其中注册 单页面应用history模式下拦截其他路径下请求 Q：vuerouter的history模式下，使用path区分不同页面的路径，本质仍为单页面，需要服务器做相应配置，在不同路径下返回同一份html文件，此时HTTP缓存位于不同路径下。当无网络时访问一个全新路径，由于没有该path缓存，页面会访问失败，可以使用service worker返回相关资源 A：在service中具体做法类似于服务端的配置，对特定路径下的html资源访问均从缓存中匹配主文件或发起根路径资源请求，如下示 if (event.request.url.indexOf('/b') > 0) { // return fetch('/'); return caches.match('/'); } 此种方法即可解决SPA应用不同路径下缓存不同问题 "},"react/":{"url":"react/","title":"react","keywords":"","body":"React 基础 进阶 "},"react/react基础.html":{"url":"react/react基础.html","title":"基础","keywords":"","body":"react基础学习 搭建React框架指南，类似于vue-cli 依赖库 react.js，React核心库 react-dom.js，提供DOM相关操作 brower.js，将JSX语法转化为JavaScript语法，使用JSX的的地方script标签下type为\"text/babel\" render函数 ReactDOM.render函数将模板转化为HTML，插入到指定DOM节点中 ReactDOM.render( Hello, world!, document.getElementById('example') ); 多次使用render方法时以最后一次为准 JSX语法 特点为HTML和JavaScript混写 遇到HTML标签以HTML规则解析 遇到代码块（即大括号）以JavaScript规则解析 var names = ['Alice', 'Emily', 'Kate']; ReactDOM.render( { names.map(function (name) { return Hello, {name}! }) } , document.getElementById('example') ); 直接在模板中插入JavaScript变量，如果是数组，则展开数组 此处为展开数组，并不是调用数组的toString方法 var arr = [ Hello world!, React is awesome, ]; ReactDOM.render( {arr}, document.getElementById('example') ); React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保你的应用不会被注入攻击，防止XSS攻击。 CSRF(cross site request forgery)与XSS(cross site script) 组件 React.createClass方法用于生成组件类 var HelloMessage = React.createClass({ render: function() { return Hello {this.props.name}; } }); ReactDOM.render( , document.getElementById('example') ); 组件类的render方法用于输出组件 组件类第一个字母必须大写 组件类只能包含一个顶层标签 可以在调用组件时向其中加入属性 以上指定的name属性，可以在组件内部通过this.props.name获取该属性 this.props this.props中组件的属性与dom的属性一一对应，具有只读性 this.props.children表示组件的所有子节点 this.props的取值要点： 如果当前组件没有子节点，则值为undefined 如果当前组件有一个子节点，则取值类型为object 如果当前组件有多个子节点，则取值类型为array 可以使用官方提供的React.Children.map遍历子节点，从而避免数据类型的问题 propTypes 验证组件实例的属性是否符合要求 取值为对象，其中key为相应参数，value为取值类型、是否必须等 propTypes: { title: React.PropTypes.string.isRequired } getDefaultProps 设置参数默认值 取值为函数，该函数返回一个对象，其中key为参数名，value为相应参数默认取值 getDefaultProps () { return { title: \"456\" } } ref获取DOM元素 react中通过虚拟DOM操作DOM树，但是使用ref获取真正DOM元素 //使用ref获取DOM元素 this.refs.myTextInput.focus(); 此处获取的DOM节点为真实DOM节点，需要在虚拟DOM插入文档后再进行操作，否则会报错 this.state react将组件看作一个状态机，this.state规定组件内部数据属性，组件内部调用this.setState({})改变状态 getInitialState 函数规定函数内部初始状态，函数返回一个对象，其中即为组件的初始状态，会在组件挂载时自动执行。这个对象可以在外部通过this.state读取 state与props的区别 props存储的数据已经定义不再改变 state中存储组件内部随用户操作而变化的特性 state与props为异步更新，不可依赖，需要改变状态时解决办法为使用setState的函数参数prevState this.setState((prevState, props) => ({ counter: prevState.counter + props.increment })); react生命周期 大流程顺序如下所示： constructor:创建组件时调用一次 componentWillMount:组件挂载前调用 componentDidMount:组件挂载后调用 componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，还有其他钩子函数： componentWillReceiveProps(nextProps) props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换） shouldComponentUpdate(nextProps, nextState) 组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率 请求的使用 通常数据请求在componentDidMount中使用，而后根据请求获得的数据使用setState更改状态 事件处理 react中事件绑定属性采用驼峰写法 需要传入函数作为事件处理函数，而不是函数名字符串 Activate Lasers //原生javascript Activate Lasers 必须使用preventDefault阻止默认事件 事件处理函数触发时最后一个参数默认为事件对象 绑定事件处理函数中this对象方法： 构造函数中绑定 constructor(props) { // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); } 即在构造函数中使用bind直接给函数绑定 this值 属性初始化器语法 handleClick = () => { console.log('this is:', this); } 在函数定义时使用箭头函数确定函数中this指向 回调函数中的箭头函数 this.handleClick(e)}> 在函数调用时使用箭头函数 此方法下，当回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染 事件函数传参 向事件处理函数传参有两种方法： 使用箭头函数 this.deleteRow(id, e)}>Delete Row 此方法下所有参数都必须显式传递，包括事件对象，这与箭头函数机制有关 使用bind函数 Delete Row 此方法下事件对象可以隐式传递，事件对象默认为所有参数的最后一个，如下示 preventPop(name, e){ //事件对象e要放在最后 e.preventDefault(); alert(name); } 条件渲染 react中使用javascript中if或者条件运算符进行条件渲染 条件判断可以依据props和state中变量进行相应判断 javascript中条件运算可以使用 if && judge && expression 此种原理即为利用&&与||的计算特点，当条件为true时执行后面语句，为false时不执行第二项 三目运算符 组件不希望进行条件渲染时可以直接返回null，返回null不影响该组件生命周期钩子函数的执行 列表渲染 列表渲染使用js的循环或遍历实现 列表渲染需要为每一项设置相应的key，key的作用在于当DOM发生变化时帮助react判断哪些DOM发生了变化 key的应用 key的作用为与兄弟组件进行比较，因此无需为每一项均指定相应的key key在兄弟元素之间唯一，无需全局唯一 key作为标识不会传递给子组件，必要时需要使用其他属性传递 子组件的props中没有key属性 react的双向数据绑定 数据双向绑定实现 react组件内部状态只能使用setState函数进行，故在view中状态改变时，需要进行手动的viewmodel操作，此处即为受控组件的意义 //输入框输入时触发事件更改组件状态 //手动完成状态更改，函数中使用event.target.value获取输入值 handleChange(event) { this.setState({value: event.target.value}); } 在组件初始化时用状态设置初始值，使用onChange事件处理用户输入，使用event.target.value获取用户输入 此方法适用于input、textarea与select等输入 在状态修改的同时，也可以对用户输入值可以进行一定的修改和限制 多输入解决办法 存在多个input输入框时，通过为input指定name属性进行区分 handleInputChange(event) { const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } 此处最后的状态更改语句用到了ES6的计算属性名，选择相应的变量进行赋值 此即为受控组件的内部原理，受控组件较为复杂，但是其内部的数据流动更为清晰，便于开发 状态提升 多个组件均会用到的数据，使用状态提升的方法将共享状态提升至最近的父组件中进行管理 父组件传递数据到子组件使用props，props为只读 子组件传递数据到父组件，需要在调用子组件时使用props，将父组件内部的函数方法传递到子组件，子组件内部数据更改时调用该方法，将更改后的数据传递至父组件 经验教训 单一数据源 对于任何可变数据只有一个单一数据源，位于需要渲染数据的组件中。 当其他组件中需要这些数据时，将数据提升至最近的父组件中，而且需要保证数据均为自顶向下流动，避免出现不同组件中状态的同步 状态提升更易于调试 当出现bug时，只需要查找哪些组件中保有状态数据，因为只有这些组件才可以操作数据，减小bug查找范围 props可以提供的数据可以不必出现在state中 减少state中不必要状态的存储，如果状态可以通过props计算得出，则可以不使用state react开发者工具辅助开发 组合与继承 建议使用组合复用组件之间的代码，避免使用继承 包含关系 组件内部通过props.children访问外部注入的子元素 需要进行区分时，使用props参数进行不同子元素的区分 function App() { return ( } right={ } /> ); } 上例中，在props属性中使用left和right区分不同项 props参数可以传递任意值，包括数据、DOM结构与函数等 特殊实例 在 React 中，通过属性配置的方法，组件可以作为其他组件的特殊实例 如配置children属性或其他属性 属性+组合提供了以清晰和安全的方式自定义组件的样式和行为所需的所有灵活性，此外，组件可以接受任意元素，包括基本数据类型、React 元素或函数 当需要复用与展示无关的功能时，可以将其提取到单独的javascript模块中，在需要的地方进行导入即可，避免对组件进行不必要的扩展 React理念 根据UI划分组件层级 划分可以根据单一功能原则进行划分。理想情况下一个组件仅做一件事，若组件功能过于复杂，则可以进一步划分。 此处涉及到javascript设计模式 创建静态应用 传入数据模型 + UI渲染，不包括交互 区分props与state，state主要用于数据交互阶段 开发模式可以分为自顶向下和自底向上两种，自顶向下有利于框架设计，自底向上有利于具体实现与单元测试 这一步使用props的单向数据流实现一个静态的数据模型，不涉及交互操作，便于观察UI更新流程 确定应用中state state的确定应该具有不可重复性，避免数据冗余。其确立原则有： 是否通过props从父级获得，若是，则可能不是state 是否一直不会改变，若是，则可能不是state 是否可以通过组件中state或props计算得出，若是，则可能不是state 确定state位置 确定state位置方法： 寻找所有需要这个state的组件 寻找所有需要state组件的公共父组件，state存储于这个组件中 若没有公共父组件，则创建一个专门用于保存状态的组件 添加反向数据流 添加反向数据流，完成数据的双向绑定 React特点：组件化，模块化 "},"react/react进阶.html":{"url":"react/react进阶.html","title":"进阶","keywords":"","body":"React进阶 JSX JSX本质为React.createElement()的语法糖 React的声明 JSX编译后会调用React.createElement方法，故需要提前声明引入react变量 点表示法 组件自身也可作为一个对象的属性存在 首字母大写 React组件名首字母必须为大写。 React中默认首字母小写的为HTML标签，大写的为React组件，将调用React.component进行编译 运行时选择组件类型 如需运行时根据变量确定所使用的元素类型，需要将其先赋值给一个大写字母开头的变量，再用这个变量进行组件的渲染 import React from 'react'; import { PhotoStory, VideoStory } from './stories'; const components = { photo: PhotoStory, video: VideoStory }; function Story(props) { // 正确！JSX 标签名可以为大写开头的变量。 const SpecificStory = components[props.storyType]; return ; } 属性的使用 JSX中有几种不同的方式指定属性 javascript表达式 使用javascript表达式对属性进行赋值 注意：if和for不算表达式 字符串常量 可以将字符串常量作为属性值传递 两种方法等价 字符串常量在进行传递时，不会对其进行HTML转义，故与$lt;3相同 属性值默认为true 如果没有给属性传值，则默认为true 不建议使用 扩展属性 可以使用ES6的对象扩展符将对象中所有属性传递过去 function App1() { return ; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return ; } 不建议使用，容易导致不相关属性的传递 子节点的传递 组件内部可以使用props.chirldren获取外部传入的子节点，子节点的传入有以下方法 字符串常量 在开始与结束标签之间放入一个字符串，则props.children就是那个字符串 JSX会移除空行和开始与结尾处的空格，字符串内部的换行会被压缩成一个空格。 JSX 一个React组件可以通过数组的形式返回多个元素 javascript表达式 将用大括号{}包裹的javascript表达式作为子元素传递 function Item(props) { return {props.message}; } function TodoList() { const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( {todos.map((message) => )} ); } 可以与其他类型的子代混合使用 函数 props.children可以传递任何数据，包括函数。只要将该组件在React渲染前转换成React能够理解的结构即可。 // Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i {items}; } function ListOfTenThings() { return ( {(index) => This is item {index} in the list} ); } 布尔值、Null和undefined被忽略 false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染 以下表达式等价： {false} {null} {undefined} {true} React中，出现了falsy值,即强制类型转换后会变为false的值，包括有0，“”，null，undefined 和 NaN，在进行组件渲染的&&判断时不会起到作用 {props.messages.length && } 当length为0时，后面的组件依然会得到渲染。 解决办法为使得&&前面的表达式始终为布尔值 如果需要将false、true、null或者undefined出现在输出中，则必须先将其转换为字符串再加入到元素中。 "},"flutter/":{"url":"flutter/","title":"flutter","keywords":"","body":"flutter 基础 进阶 "},"wechat/":{"url":"wechat/","title":"微信小程序","keywords":"","body":"小程序 微信小程序基础 微信小程序进阶 小程序组件 快应用基础 "},"wechat/微信小程序基础.html":{"url":"wechat/微信小程序基础.html","title":"微信小程序基础","keywords":"","body":"微信小程序 基础 代码构成 JSON配置 app.json：当前小程序全局配置 pages：当前小程序所有页面路径 window：默认页面的窗口表现 tabBar：设置tab的表现 networkTimeout：网络超时事件 debug： 是否开启debug模式 project.config.json：开发者工具配置，如界面颜色，代码上传压缩等 page.json：为单个页面指定不同于app.json的特殊属性 WXML模板 自定义组件，包装原原生标签，如text，view等 自定义指令，表现与数据分离，如wx:if等 WXSS样式 新增尺寸单位，使用rpx避免换算 app.wxss设置全局样式，page.wxss设置当前页面样式 js交互 小程序能力 小程序启动 app.json的pages数组第一项为小程序首页 加载首页代码进行渲染 触发app.js中的onLaunch回调函数 程序与页面 根据page.json配置生成页面，其中定义顶部颜色与文字 加载WXML与WXSS 加载page.js，渲染页面 触发onload回调 组件 组件传值、事件绑定 API 发布前准备 开发者权限管理、小程序预览、代码上传、版本号设置等 小程序上线 提交审核、发布、运营数据查看 "},"wechat/微信小程序进阶.html":{"url":"wechat/微信小程序进阶.html","title":"微信小程序进阶","keywords":"","body":"框架 MVVM框架，视图层与逻辑层分离 页面管理 基础组件 API 文件结构 根目录： app.js，app.json，app.wxss app.wxss：小程序公共样式表，全局样式设置 单一页面：page.wxml，page.js，page.wxss，page.json 描述同一页面的所有文件必须具有相同的路径与文件名 配置 app.json pages：array，每一项为string，路径+文件名，指定小程序的页面组成 数组中第一项问初始页，小程序页面增删均需在此修改 window：object，设置小程序状态栏、导航条、标题与窗口背景色 tabBar：array，每一项为单个tab设置参数，设置tab表现 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面 networkTimeout：设置各种网络请求超时时间 request：wx.request超时时间，单位ms，默认60000 connectSocket：同上 uploadFile：同上 downloadFile：同上 debug page.json：其中只会设置app.json中的window项与disableScroll，会对window进行覆盖 逻辑层 增加App与Page方法，进行小程序与页面的注册。 getApp与getCurrentPages获取App实例与当前页面栈 模块化开发，每个页面独立作用域 浏览器中一些对象无法使用，如document与window 所有代码打包成一份JavaScript App App()：用于注册小程序。接收object参数，其中指定小程序生命周期函数 生命周期 | 意义 | 触发时机 onLaunch | 监听小程序初始化 | 小程序初始化完成，触发一次 onShow | 监听小程序显示 | 小程序启动或从后台进入前台显示，进行触发 onHide | 监听小程序隐藏 | 小程序进入后台，进行触发 onError | 错误监听函数 | 脚本错误与API调用失败，进行触发并带上错误参数 其他 | any | 此处定义的函数或数据，可以使用this全局访问 onLaunch与onShow参数 getApp() 返回App对象 注意事项： App()必须在app.js中注册，只能注册一个 在App()内可以使用this直接获取App对象 不能在onLaunch中获取page对象，此时尚未生成 不能私自调用生命周期函数 场景值 Page Page()：用于注册页面。接收一个object参数，其中页面初始化数据、生命周期函数、事件处理函数等 object参数： data： 页面初始数据，负责页面第一次渲染，其中数据必须是字符串、数字、布尔、对象与数组格式 生命周期函数 onLoad：页面加载时触发，每个只调用一次 参数为其他页面打开当前页面所调用的query参数 onShow：每次页面显示时都会调用 onReady：页面初次渲染完成，每个页面只调用一次，代表当前页面以准备妥当，可以与视图层进行交互 onHide：页面隐藏，在navigateTo或者底部tab切换时调用 onUnload：页面卸载，在redirectTo或navigateBack时调用 页面事件处理函数 onPullDownRefresh：下拉刷新 需要在app.json中的window选项或page.json中开启enablePullDownRefresh 处理完数据刷新后，可以使用wx.stopPullDownRefresh可以停止当前页面的下拉刷新 onReahBottom：上拉触底 可以在app.json的window选项中或页面配置中设置触发距离onReachBottomDistance 在触发距离内滑动期间，本事件只会触发一次 onPageScroll：页面滚动 参数为object，包含scrollTop也现在垂直方向已滚动的距离，单位px onShareAPPMessage：用户转发 只有定义了此事件处理函数，右上角菜单才会出现转发按钮 用户点击转发按钮时调用 此事件需要return一个object，其中定义转发内容title与path，分别为转发标题与转发路径 其他函数，在页面的函数中可以通过this访问 object内容在页面加载时会进行一次深拷贝，需注意其大小对深拷贝影响 页面其他数据 Page.prototype.route：获取当前页面路径 Page.prototype.setData()： 同步改变对应的this.data值，也可用于新增数据 异步将数据同步至视图层 参数： data：object，必填 callback：在本次setData对视图层渲染完毕后调用 直接使用this.data修改数据不会同步至视图层 设置undefined值将会被忽略，且会导致其他问题 页面路由 页面栈 路由切换时，页面栈表现如下 路由方式 页面栈表现 初始化 新页面入栈 打开新页面 新页面入栈 页面重定向 当前页面出栈，新页面入栈 页面返回 页面不断出栈，直到目标返回页，新页面入栈 tab切换 页面全部出栈，只留下新的tab页面 重加载 页面全部出栈，只留下新的页面 getCurrentPages() 返回值为数组，数组顺序为栈的顺序，第一个元素为首页，最后一个元素为当前页面 路由方式 不同路由切换方式对页面生命周期函数触发不同 具体参见页面路由 模块化 文件作用域 在 JavaScript 文件中声明的变量和函数只在该文件中有效 通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置 // app.js App({ globalData: 1 }) 模块化 通过module.exports向外暴露模块接口，暂不支持npm 通过require引入模块，require暂不支持绝对路径 视图层 WXML 数据绑定 WXML中所有的数据均来自对应page中的data，data也可在调用组件时指定 数据的绑定使用双大括号包裹变量 列表渲染wx:for 当前项变量名默认为item，当前项下标默认为index : 使用wx:for-item修改当前项变量名，使用wx:for-index修改当前项下表名 : wx:key为列表中每一项提供唯一的标识符，当视图层重新渲染时，保证这些项不会被重新创建，以保持其自身状态，如input中输入内容与选择器的选中状态，并且提高渲染效率。 key的提供方式： 字符串，依赖于item的某个property，需要取值独一无二 关键字*this，代表for循环中的item自身，需要item本身是一个唯一的字符串或数字 注意： 当针对字符串使用wx:for，会将字符串拆解为字符数组 花括号与引号之间存在空格时，循环内容会最终被解析为字符串 //等价于 条件渲染wx:if 惰性渲染，渲染与销毁 1 2 3 wx:if与hidden关系同v-if与v-show，频繁切换使用hidden更好 wx:if切换消耗高 hidden初始渲染消耗高 模板 模板定义，使用name属性 {{index}}: {{msg}} Time: {{time}} 模板使用，使用is属性，is属性值可以动态绑定 动态绑定： 模板作用域，只使用data传入数据与其wxs模块 事件 组件中事件的绑定 Click me! 事件捕获与冒泡： 冒泡事件列表 事件绑定： key使用bind或catch开头，bind:eventName、catch:eventName，旧版本下没有冒号 value为字符串，内容为函数名 bind事件绑定不会阻止冒泡事件冒泡，catch会阻止事件冒泡 capture-bind在捕获阶段触发事件，capture-catch将会终端捕获阶段和取消冒泡阶段 事件对象： 默认情况下事件触发时，处理函数会收到一个事件对象 event： BaseEvent 基础事件对象属性列表 CustomEvent 自定义事件对象属性列表（继承 BaseEvent） TouchEvent 触摸事件对象属性列表（继承 BaseEvent） type 事件类型 timeStamp 页面打开到触发事件经过的毫秒数 target 触发事件的源组件 currentTarget 事件绑定的当前组件 dataset 读写数据 在组件使用中可以使用data-self-data设置自定义数据。 自定义数据的名称不能有大写字符，大写字符自动转为小写。多个单词使用短横线连接，框架会自动将其转化为驼峰 使用event.currentTarget.dataset.selfData可以获取与设置自定义数据。此处使用驼峰写法 touches 数组，每个元素为touch对象，canvas触摸事件中为touches是CanvasTouch数组 changedTouches，数据格式同touches detail，自定义事件携带的数据，如表单提交事件中用户的输入等 引用 import，import目标文件后可以在被文件中调用引入的组件 {{text}} include，可以将目标文件除了 外的整个代码引入 相当于将引入的组件直接拷贝到include的位置使用 WXS：WeiXin Script wxs代码可以编写在wxml文件的wxs标签内，或者一个.wxs的文件中 note wxs与JavaScript是不同的语言，二者语法不一致 wxs与JavaScript运行环境隔离。wxs不能调用JavaScript的函数，也不能调用小程序API wxs不能作为组件事件回调 wxs与JavaScript结合使用示例： var add = function(num) { var result = num + 1; return result; } module.exports.add = add; {{m1.add(num)}} 模块 每个wxs文件和wxs标签都是一个单独的模块，作用域独立，通过module.exports向外暴露接口 wxs文件可以被其他的wxs文件或者wxs标签引用 // 标签引用 // wxs文件引用 var tools = require(\"./tools.wxs\"); wxs文件的require注意事项： 只能引用wxs文件模块，且必须使用相对路径 wxs模块为单例，第一次被引用时初始化为单例对象，此后在多个地方、多个页面、多次引用均使用的同一个wxs模块对象 如果一个wxs模块定义后从未被引用，则其不会被解析与运行 wxs标签 src，引用wxs文件的相对路径，仅当本标签为单闭合标签或标签的内容为空时有效 相对路径，单例模式，不引用不会解析执行 module，当前wxs标签的模块名。 重复的模块名会按照先后顺序覆盖，其命名遵循变量命名规则 标签中，只能使用定义该 的 WXML 文件中定义的 模块 变量 wxs中的变量均为值的引用 没有声明的变量直接使用，定义为全局变量 声明未赋值的变量，默认值undefined var与JavaScript中相同，存在变量提升 其他参见ES5 WXSS 与CSS区别在于尺寸单位与样式导入 尺寸单位： rpx：规定屏幕宽度为750rpx，针对屏幕真实宽度进行自适应 样式导入： 外联样式表：@import 相对路径; @import \"common.wxss\"; 内联样式：使用style绑定动态样式，避免在其中使用静态样式 支持选择器类型：id，class，tag，before，after，element element app.wxss中样式为全局样式，作用于所有页面 page.wxss中样式为局部样式，作用于当前页面，覆盖app.wxss 自定义组件 低耦合度，组件复用 创建自定义组件 自定义组件问价的组成方式类似于页面，但需要在page.json中进行自定义组件声明，将component字段设为true { \"component\": true } WXML与WXSS与普通页面大体相同 在组件wxss中不应使用ID选择器、属性选择器和标签名选择器 js文件 使用Component()注册组件 properties对象声明外部参数 data对象声明初始参数 methods对象声明自定义方法 代码示例： Component({ properties: { // 这里定义了innerText属性，属性值可以在组件使用时指定 // 使用时通过this.data.innerText调用 innerText: { type: String, value: 'default value', } }, data: { // 这里是一些组件内部数据 someData: {} }, methods: { // 这里是一个自定义方法 customMethod: function(){} } }) 使用自定义组件 page.json中进行引用声明 { \"usingComponents\": { \"component-tag-name\": \"path/to/the/custom/component\" } } wxml中直接使用自定义组件 注意属性注入时的大小写问题 因为WXML节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符 组件模板与样式 slot分发 组件模版的写法与页面模板相同。组件模版与组件数据结合后生成的节点树，将被插入到组件的引用位置上。 多个slot需要现在component函数中进行声明 Component({ options: { multipleSlots: true // 在组件定义时的选项中启用多slot支持 }, properties: { /* ... */ }, methods: { /* ... */ } }) 不同slot之间通过name进行区分 这里是组件的内部细节 slot使用 的位置上 --> 这里是插入到组件slot name=\"before\"中的内容 的位置上 --> 这里是插入到组件slot name=\"after\"中的内容 组件样式 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器 继承样式，如 font 、 color ，会从组件外继承到组件内 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效 组件可以指定它所在节点的默认样式，使用 :host 选择器 /* 组件 custom-component.wxss */ :host { color: yellow; } 这段文本是黄色的 Component构造器 用于定义组件，指定组件的属性、数据和方法等 data properties：外部传入数据，type表示类型，value表示属性初始值，observe表示属性值改变时响应函数 methods：组件自定义方法 behaviors：组件间代码复用 created：生命周期函数，组件实例进入页面节点树时执行，此时data尚未创建 attached：生命周期函数，在组件实例进入页面节点树时执行 ready：组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息 moved：组件生命周期函数，在组件实例被移动到节点树另一个位置时执行 detached：组件生命周期函数，在组件实例被从页面节点树移除时执行 relations：组件间关系定义 options：组件参数选项 生命周期函数与observe中使用this访问组件实例 组件实例属性： is：组件的文件路径 id：节点id dataset：节点自定义属性 data：组件数据，包括内部数据与属性值 组件实例方法： setData hasBehavior：检查是否具有behavior triggerEvent：触发事件 createSelectorQuery：创建一个 SelectorQuery 对象，选择器选取范围为这个组件实例内 selectComponent：使用选择器选择组件实例节点，返回匹配到的第一个组件实例对象 selectAllComponents：使用选择器选择组件实例节点，返回匹配到的全部组件实例对象组成的数组 getRelationNodes：获取所有这个关系对应的所有关联节点 properties定义中，属性名使用驼峰写法 wxml中，指定属性值使用连字符写法，component-tag-name property-name=\"attr value\" wxml中，数据绑定时采用驼峰写法，attr=\"\" 组件事件 自定义事件的绑定与触发 自定义事件的绑定： 自定义事件的触发与传参： Component({ properties: {} methods: { onTap: function(){ var myEventDetail = {} // detail对象，提供给事件监听函数 var myEventOption = {} // 触发事件的选项 this.triggerEvent('myevent', myEventDetail, myEventOption) } } }) myEventDetail为事件携带参数，在触发对象中可以使用event.detail获取 myEventOption为事件的触发选项，其内容包括： bubbles：是否冒泡 composed：事件是否可以穿越组件边界，即跨组件触发事件 capturePhase：事件是否拥有捕获阶段 behaviors 用于组件之间代码的共享 mixins（组合模式）用于传统语言的多重继承，在ES中即为将多个对象的方法集成到一个对象上去，如jquery中的extend。React中mixins的实现效果为将多个component的属性相叠加，如生命周期函数 每个behavior使用Behavior构造器定义，包含一组属性、数据、生命周期函数和方法 在组件中使用require引入相关behavior 同名字段覆盖规则 同名属性或方法，behaviors数组中后面会覆盖前面，组件本身会覆盖behaviors 同名的properties，如果是对象类型则进行合并，非对象类型则进行覆盖 生命周期函数不会被覆盖，则对应的触发时机进行依次调用。若同一个behavior被一个组件引用多次，则其生命周期函数只会被执行一次 组件的内置behaviors 自定义组件可以通过引用内置的 behavior 来获得内置组件的一些行为 Component({ behaviors: ['wx://form-field'] }) wx://form-field： 使得自定义组件有类似于表单控件的行为 组件间关系 Component({ relations: { './custom-li': { type: 'child', // 关联的目标节点应为子节点 linked: function(target) { // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后 }, linkChanged: function(target) { // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后 }, unlinked: function(target) { // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后 } } }, methods: {} }) relations中每一项所需字段： 选项 | 类型 | 描述 type| string | 与目标组件的相对关系，取值有parent、child、ancestor、descendant linked | function | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后 linkChanged | function | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后 unlined | function | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后 target | string | 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联 relations必须在相关联的两个组件中同时指定 可以为组件与behavior之间指定关系，则当前组件与所有包含此behavior的组件之间均具有此关系（在包含的组件中仍然需要建立relation） 分包加载 将整个小程序划分为不同的子包，构建时打包成不同的分包，按需加载 分包小程序内容如下： 一个主包，其中放置默认启动页面或TabBar页面，以及所有分包都需要的公共资源 分包情况根据开发者配置进行划分 加载规则： 小程序启动时，默认下载主包并启动主包内页面 打开分包页面时，下载对应分包进行展示 打包原则：在app.json中的subPackages字段声明项目分包结构 声明subPackages后，将按subPackages配置路径进行打包，subPackages配置路径外的目录将被打包到 app（主包） 中 app（主包）也可以有自己的 pages（即最外层的 pages 字段） subPackage 的根目录不能是另外一个 subPackage 内的子目录 首页的 TAB 页面必须在 app（主包）内 引用原则： packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件 packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源 兼容 通过 wx.getSystemInfo 或者 wx.getSystemInfoSync 获取到小程序的基础库版本号 通过wx.canIUse判断小程序的API，回调，参数，组件等是否在当前版本可用 接口兼容示例 if (wx.openBluetoothAdapter) { wx.openBluetoothAdapter() } else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: '提示', content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。' }) } 接口参数兼容示例 wx.showModal({ success: function(res) { if (wx.canIUse('showModal.cancel')) { console.log(res.cancel) } } }) 组件兼容示例 Page({ data: { canIUse: wx.canIUse('cover-view') } }) play 小程序运行机制 热启动：户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动 更新机制 小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上 运行逻辑 小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁 再次打开逻辑 性能 性能优化建议 setData比较容易引发性能问题 setData操作优化 避免频繁setData 长时间占用js线程，导致用户操作事件处理延迟 避免setData数据量过大 后台页面的setData 当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行 图片资源 图片影响内存 大图片与长列表图片，影响iOS上WKWebView内存回收 图片影响页面切换 大图片也会造成页面切换的卡顿 代码包大小 代码包内图片资源 清理未用到的代码与资源 性能分析工具 性能trace工具 微信内部性能面板 "},"wechat/小程序组件.html":{"url":"wechat/小程序组件.html","title":"小程序组件","keywords":"","body":"小程序组件 视图容器 view 视图容器，类似于div 属性: hover-class:指定按下去的样式类 hover-stop-propagation:是否阻止本节点点击状态冒泡到祖先 hover-start-time：按住后多久出现点击态，单位ms hover-stay-time：松手后点击态保留时间，单位ms scroll-view 可滚动视图区域，其内部可以滚动 swiper 滑块视图容器，实现效果类似于轮播图 swiper-item 只能放置在swiper组件中，宽高自动100% note： 如果在 bindchange 的事件回调函数中使用 setData 改变 current 值，则有可能导致 setData 被不停地调用，因而通常情况下请在改变 current 值前检测 source 字段来判断是否是由于用户触摸引起 movable-area 可移动区域，其内部的movable-view可拖拽 注意：movable-area 必须设置width和height属性，不设置默认为10px movable-view note movable-view必须在组件中，并且必须是直接子节点，否则不能移动 movable-view 必须设置width和height属性，不设置默认为10px movable-view 默认为绝对定位，top和left属性为0px 当movable-view小于movable-area时，movable-view的移动范围是在movable-area内；当movable-view大于movable-area时，movable-view的移动范围必须包含movable-area（x轴方向和y轴方向分开考虑） cover-view 覆盖在原生组件上的文本视图，可以覆盖map、video、canvas、camera，只能嵌套cover-view、cover-iamge cover-iamge 覆盖在原生组件之上的图片视图，可覆盖的原生组件同cover-view，支持嵌套在cover-view里 基础内容 icon 图标 属性： type：icon的类型，success, success_no_circle, info, warn, waiting, cancel, download, search, clear size：icon大小，单位px color：icon颜色，同color text 文本 属性： selectable：文本是否可选 space：是否显示连续空格，取值ensp、emsp、nbsp decode：是否解码 note： decode可以解析的有   & '     各个操作系统的空格标准并不一致。 组件内只支持 嵌套。 除了文本节点以外的其他节点都无法长按选中 rich-text 富文本标签，其中可以包含HTML节点 属性： nodes：Array/String，节点列表/HTML String，支持文本节点与元素节点，通过type区分，默认元素节点 type = node，属性： name：标签名 attrs：属性 children：子元素列表，结构与nodes一致 type = text，属性： text：文本 支持默认事件，包括：tap、touchstart、touchmove、touchcancel、touchend和longtap 支持class与style属性，不支持id nodes推荐使用数组 rich-text组件内屏蔽所有节点事件 attrs属性不支持id，支持class name属性不区分大小写 如果使用了不受信任的HTML节点，该节点及其所有子节点将会被移除。 img仅支持网络标签 如果在自定义组件中使用 rich-text 组件，那么仅自定义组件的 wxss 样式对 rich-text 中的 class 生效 progress 进度条 表单组件 button 按钮 较为重要属性： bindcontact：客服消息回调函数 bindgetphonenumber：获取用户手机号回调 binderror：使用开放能力时，发生错误的回调 note： 注1：button-hover 默认为{background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;} 注2：bindgetphonenumber 从1.2.0 开始支持，但是在1.5.3以下版本中无法使用wx.canIUse进行检测，建议使用基础库版本进行判断。 注3: 在bindgetphonenumber 等返回加密信息的回调中调用 wx.login 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态 checkbox-group 多项选择器，内部由多个checkbox组成 属性： bindchange：选中状态发生改变时回调函数 checkbox 多选项目 value：标识，选中时触发的 change 事件，并携带 的 value disable：是否禁用 checked：是否默认选中 color：checkbox的颜色，取值同color form 表单。当点击 表单中 formType 为 submit 的 组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。 input label 用来改进表单组件的可用性，使用for属性找到对应的id，或者将控件放在该标签下，当点击时，就会触发对应的控件 picker 从底部弹起的滚动选择器，现支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器 picker-view 嵌入页面的滚动选择器 其中只可放置组件，其他节点不会显示 picker-view-column 仅可放置于中，其孩子节点的高度会自动设置成与picker-view的选中框的高度一致 radio-group 单项选择器，内部由组成 radio 单选项目 slider 滑动选择器 switch 开关选择器 textarea 多行输入框 导航 navigator 页面链接，定义不同的跳转方式 媒体组件 audio 音频 image video camera live-player 实时音视频播放，默认宽度300px、高度225px，可通过wxss设置宽高 tip: live-player组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。可使用 cover-view cover-image覆盖在上面。 tip: 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 live-player 组件。 tip: css 动画对 live-player 组件无效。 live-pusher 实时音视频录制 tip: live-pusher组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。可使用 cover-view cover-image覆盖在上面。 tip: 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 live-pusher 组件。 tip: css 动画对 live-pusher 组件无效 地图 map 地图，可以指定多个覆盖物，点、线、圆、控件等 画布 canvas note: canvas 标签默认宽度300px、高度225px 同一页面中的 canvas-id不可重复，如果使用一个已经出现过的 canvas-id，该 canvas 标签对应的画布将被隐藏并不再正常工作 bug & tip: tip: canvas 组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。 tip: 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 canvas 组件。 tip: css 动画对 canvas 组件无效。 bug: 避免设置过大的宽高，在安卓下会有crash的问题 开放能力 暂时忽略 "},"wechat/快应用基础.html":{"url":"wechat/快应用基础.html","title":"快应用基础","keywords":"","body":"快应用开发 快应用基础 CSS 仅支持border-box，不支持content-box与box-sizing 长度仅支持px与%，其中px含义与前端不同 相当于在自身项目中配置屏幕宽度，可以在自身项目中借鉴 模板 不能在p元素中直接放置文本内容 for、if、show、slot与vue相同 show只能针对原生组件使用，自定义组件可以通过传参控制组件内容展示与否 block块相当于vue中模板中的template块，只支持 for 和 if/elif/else 属性 引入自定义组件方式不同 数据 页面跳转 使用a标签：跳转链接可以跳转其他页面或应用，链接需手写，跳转其他页面可以使用search传递参数 使用router操作路由跳转，同时可传参，在protected属性中可接受跳转参数 跨页面/组件间双向传参：在app.ux中增加数据对象，提升数据位置，相当于简化版vuex $on、$off、$emit围绕页面级别自定义事件展开，$emit触发当前实例上监听的事件 组件上事件绑定与vue相同，onclick缩写为@click $emitElement用于事件的动态触发，只能用于原生组件 如果想改变父组件传入参数，可以watch该参数，然后在回调中向本组件数据赋值后改变 子组件向父组件传参方式： 直接修改传入的对象（不太友好） 子组件dispatch触发父组件内部$on监听事件，传参 子组件$emit触发父组件在其上onevent1或@event-type1监听的事件，传参 父组件直接向子组件传参： props父子组件传参 调用parentVm.$broadcast()触发子组件监听的对应事件，完成向下传递 方法 使用async代替callback与promise，需要额外配置 generator是一种异步编程解决方案，如果其中要使用同步回调代码，需要将同步代码改造为异步方式，如promise（待考证） $app 与$app.$def 前者会执行onCreate、onDestroy方法，其中this指向$app对象，后者不能执行 全局方法通过两者都可以调用，但是注意this不同 回调函数被调用时，会自动在参数末尾增加event对象 优化 函数共享：通过this.$app.$def共享定义在APP上的全局函数 懒加载 报错处理：快应用建议重新部分函数以避免在每个调用处写try catch，但是可以在最外层加try catch 使用疑问 页面的声明周期，组件的生命周期呢？ 基本相同 onclick事件行内绑定，如何解绑？ onclick其实就是元素属性，解绑需要将元素onclick属性置为null 组件中各类数据声明的使用区别 data：会被外部数据覆盖，不要在页面级组件中使用 public：允许被传入的数据覆盖 protected：页面跳转传参使用 private：成员变量量，不允许被覆盖，页面级别数据 局部变量：函数内部变量 页面局部变量：定义在外部的变量 自定义组件中使用data和props 踩坑 flex布局的使用 全部默认flex布局，使用很不方便 标签使用不灵活 很多HTML标签没有，标签嵌套有强制规则，标签内容也有规定 css属性使用问题 font属性不能继承 很多属性不能使用 margin不合并 没有元素选择器 未按照W3C标准实现，使用存在问题 如想使用a标签实现点击态，但是又不想真正跳转，通常做法为href=\"javaScript:\"，但是这样在快应用中仍会导致跳转 上述的一些问题也是未按照标准实现所带来的，不再详述 调试器存在部分问题，修复中 如列表渲染问题等，但是在修复中 总结 总体来说，快应用相较于小程序更偏向于底层，目前其优势在于 更方便的系统交互，相较于小程序会好一些 无需安装，这一点与微信小程序相同，依托于手机自身预装平台 相较于传统native较轻，但是目前app均为hybrid模式，也在朝着前端方面发展 快应用的实现标准与W3C不一致，前端开发过程中需要注意，可能会遇到很多与习惯不符的问题，bless "},"HTTP1.1/":{"url":"HTTP1.1/","title":"HTTP1.1","keywords":"","body":"HTTP 1.1 简介 协议相关参数 HTTP信息 连接 HTTP缓存 HTTP首部字段 "},"HTTP1.1/overview.html":{"url":"HTTP1.1/overview.html","title":"简介","keywords":"","body":"Hypertext Transfer Protocol -- HTTP/1.1 HTTP/1.1 HTTP是应用层协议，分布式协作 标准目的 HTTP协议第一个版本是HTTP/0.9 HTTP/1.0进行改进，允许消息采用类似MIME的格式，包含有关传输数据的元信息和对请求或响应语义上的修饰。 但是HTTP/1.0未充分考虑分层代理、缓存、长连接和虚拟主机等方面的需求 HTTP/1.1拥有更严格的要求，用于保证功能的可靠实施 HTTP需要更多的功能项已完成search、front-end update与注释等功能，故采用了开放式方法和头部对请求进行描述。HTTP协议建立在URI基础上，其数据传输格式由MIME进行定义 HTTP同时也被用作UA和代理或网关到其他网络系统之间的通用通信协议，如SMTP、FTP、NNTP等。通过这种方式，HTTP允许基本的超媒体访问各种应用程序提供的资源 \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"等名词说明 无条件遵从：满足所有MUST或REQUIRED级别和所有SHOULD级别要求 有条件遵从：满足所有MUST或REQUIRED级别，但不满足所有SHOULD级别要求 整体运行 HTTP协议是关于请求与响应的协议。 客户端向服务端发送一个请求，报文中包含 请求方法、URI、HTTP协议版本号 紧接着是类似于MIME信息的请求描述信息，客户端信息 最后可能会有body内容 客户端响应中包含 状态栏，包含协议版本号与响应状态码 紧接着是类似于MIME信息的服务端描述信息，元信息 最后可能会有body内容 UA向Origin Server请求并得到响应过程中，整个请求响应链可能会有多个中介响应或请求，其中可能会存在代理、网关或隧道。缓存可以起到缩短请求响应链的作用，HTTP中可以使用描述符对缓存进行特殊要求。 HTTP/1.1的目标是支持已部署的各种配置，同时引入协议构造，以满足构建需要高可靠性的Web应用程序的需求，并且当失败时，至少有可靠的失败提示 HTTP一般建立在TCP/IP的基础上，但是也可以使用以太网的其他协议，或者其他数据链路。 HTTP依赖于可靠的数据通信，故可以提供可靠数据通信的协议都可以使用HTTP。 HTTP/1.0中大部分情况需要为每个请求或相应新建一个连接 HTTP/1.1中一个连接可以被用于一个或多个请求或响应的数据交换 符号惯例 \"literal\"：文字被双引号包围，无特殊说明大小写不敏感 *rule：最少n个最多m个，当n为0或m为正无穷时可省略 (rule)：括号中元素被当做一个简单元素 [rule]：[foo bar]等价于*1(foo bar) 基础规则 CR：carriage return，回车 LF：linefeed，换行 SP：space，空格 HT：horizontal-tab，横向tab CTL：control character and DEL，控制字符和DEL LWS：linear white space，连续空格 "},"HTTP1.1/protocol-parameters.html":{"url":"HTTP1.1/protocol-parameters.html","title":"协议相关参数","keywords":"","body":"协议相关参数 HTTP版本号 HTTP版本号采用.的形式，通信双方通过版本号的沟通获知消息的格式与HTTP通信的能力 minor递增：协议中消息格式不改变，但可能会有消息语义或其他功能的改动 major递增：协议中消息格式被改变 HTTP版本号在消息的第一行指定，采用格式为 HTTP-Version = \"HTTP\" \"/\" \".\" 和中的前导0将不会被发送，并且会被接收方忽略 网关和代理不能发送高于其实际HTTP版本的信息，故当其收到高版本的HTTP请求时，需要做版本降级或使用隧道，或者返回错误码 网关和代理的响应必须和请求的major版本号相同，属于历史遗留问题 3.2 URI URI代表一个资源的标识符，资源的类型可以使多种多样的 URI分为绝对路径和相对路径，其中相对路径依赖于已知的基准URI，绝对路径以协议名，后跟冒号 HTTP协议不会对URI长度做任何限制 URI如果过长导致服务器不能处理，会返回414 URI与URL区别见TCP/IP第一章 http URL http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]] port默认80，表明资源所在主机的TCO服务监听端口号 abs_path：资源请求路径，当不使用时，应当使用/代替，作为通用请求路径、在host为IP地址时，应该避免使用abs_path 当代理收到的host不是一个完整host时，可能会进行补全，但是如果收到的时完整的host，不得进行更改 如将baidu.com补全为https://www.baidu.com/ URI 比较 端口号为空或未给出等同于默认端口号 协议与host大小写不敏感，其他大小写敏感 空的path使用/代替 字符可以使用16进制编码 3.4 字符集 HTTP中使用与MIME相同的字符集定义 charset = token 取值大小写敏感 一些HTTP/1.0中Content-Type如果没有charset参数，则接收方会自行猜测。但是部分老版本的HTTP/1.0不能正确处理charset参数 HTTP/1.1规定必须正确处理Content-Type中的charset参数，如果支持该字符集的则必须使用 3.5 内容编码 内容编码表示对内容进行编码转换，主要是用于允许一个文档被压缩或者有用的改变而不失去其底层媒体类型的身份,没有信息丢失，由接收方进行解码 content-coding = token 取值大小写敏感，HTTP/1.1在Accept-Encoding和Content-Encoding中使用内容编码 3.6 传输编码 传输编码transfer-coding是指为确保网络安全传输，对消息进行编码。 与内容编码区别在于传输编码针对消息，内容编码针对内容实体 "},"HTTP1.1/HTTP-Message.html":{"url":"HTTP1.1/HTTP-Message.html","title":"HTTP信息","keywords":"","body":"4 HTTP Message HTTP信息包含客户端向服务端的请求和服务端向客户端的响应，一般消息格式为 generic-message = start-line *(message-header CRLF) CRLF [ message-body ] 起始行，也称状态行 0或多个HTTP头部 标志header结束的回车换行，即空行 body信息 服务端在接收请求时，会忽略起始行中的空行 HTTP/1.0 客户端会在POST请求后跟上一个额外的空行 HTTP/1.1 客户端不能在请求之前或之后跟上额外的空行 4.2 消息头 包括 通用头 请求头 响应头 实体头：包含元信息 header字段可以扩展到多行，每个字段前要加上空格或者tab message-header = field-name \":\" [ field-value ] field-name = token field-value = *( field-content | LWS ) field-content不包含其之前或之后的连续空格，在解释语义或转发消息流时连续空格会被替换为单个空格，连续空格不会改变语义 消息头的发送顺序并无特殊语义，但是最好是依照通用头 -> 请求头/响应头 -> 实体头的顺序 相同field-name的多个消息头字段应该被合并为一个，将后续的字段值合并到第一个，使用逗号分隔，不改变语义，此时组合后的字段值顺序不能被更改 4.3 消息正文 消息正文用于承担请求或响应的实体信息entity-body，当使用Transfer-Encoding时实体信息会被编码 message-body = entity-body | Transfer-Encoding属于消息的一项属性，在请求响应链中可以被添加或移除 请求和响应的消息正文存在不同 对于请求的消息正文： 通过请求头中包含Content-Length or Transfer-Encoding可以表明请求中消息正文的存在 部分请求方法不允许发送请求的消息正文 服务器应该可以读取和转发任何请求的消息正文 当请求方法没有为消息正文定义语义时，服务器处理请求时消息正文会被忽略（与第二条相对应） 对于响应的消息正文： 响应消息中是否包含消息正文依赖于请求方法和响应状态码 HEAD请求的响应不能包含消息正文，即使存在对应的实体头 1xx消息、204不改变当前页面、304缓存可用都不允许包含消息正文 其他的所有响应都会包含消息正文，即使长度为0 4.4 消息长度 消息的传输长度是指消息正文经过传输编码后的长度 当消息正文位于一个消息中，其传输长度按照以下规则决定（规则顺序具有优先级）： 当响应被规定不能包含消息正文，无论其消息头中字段如何定义，响应会在消息头之后的第一个空行处结束 当消息头中的Transfer-Encoding被指定为除identity之外的其他值时，传输长度取决于当前传输编码的分块，除非连接被关闭 所有的HTTP/1.1发送实体信息时必须使用分块传输编码，故其消息长度不能够被提前给出 当消息头中的Content-Length被指定，其十进制形式同时表示实体信息长度和传输长度。当这两个值不同，Content-Length不会被发送，如使用了Transfer-Encoding 如果接收方收到的消息头中同时包含Transfer-Encoding和Content-Length，后者必须被忽略 消息中不能同时包含Content-Length头与非identity的Transfer-Encoding头，如果包含，前者将被忽略 如果消息使用媒体类型multipart / byteranges，并且未另外指定Transfer-length，则此自我限制媒体类型定义传输长度。除非发件人知道收件人可以处理，否则不能使用此媒体类型 通过服务器关闭连接决定。关闭连接不能用于表明请求正文的结束，因为在此情况下服务器将无法返回响应 兼容性 为了兼容HTTP/1.0，除非明确知道服务端兼容HTTP/1.1，否则当请求中包含请求正文时，请求头中必须包含有效地Content-Length字段 当请求中包含请求正文，但是未给出Content-Length，如果服务端无法判断消息的长度，服务端应该返回400(bad request)或411(length required) Content-Length的取值必须与消息正文相匹配，如果UA检测到一个无效长度时必须通知用户 4.5 通用头信息 有一些头字段对请求和响应消息具有普遍适用性，但仅适用于正在传输的消息，不适用于实体。 Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade Via Warning 通用头字段可以随着版本号进行扩展。但是新的或实验中的字段如果不能被识别为通用头字段，将被当做实体头字段处理 5 Request请求 客户端向服务端的请求信息，应该包括请求行、请求方法、资源URI与协议版本 Request = Request-Line *(( general-header | request-header | entity-header ) CRLF) CRLF [ message-body ] 5.1 请求行 Request-Line = Method SP Request-URI SP HTTP-Version CRLF 5.1.1 请求方法 OPTIONS：预检请求 GET HEAD：类似于GET，但服务器不返回消息体，相应头中的元信息。常用于获取请求的元信息 POST PUT DELETE TRACE CONNECT 其他扩展方法 各请求方法介绍 请求方法使用 可以在ALLOW头中列举出本资源可以使用的请求方法 当使用远程服务器已知但是不允许的方法请求资源时，服务器应该返回405Method Not Allowed 当使用远程服务器不能识别的方式请求资源，服务器应该返回501Not Implemented 所有的多用途服务器都必须支持GET与HEAD方法，其他方法为可选项，如果使用必须按照标准进行实现 5.1.2 Request-URI 注意请求URI与http_URL的不同 Request-URI = \"*\" | absoluteURI | abs_path | authority 请求URI的取值取决于请求的性质 *：请求并不依赖于特定的资源，只是针对服务端的请求，该URI只能在请求方法不一定针对资源时使用，如 OPTIONS * HTTP/1.1 预检请求在跨域时用于判断服务器是否接受当前域名下的请求方法 绝对路径URI：一个请求链中可能经过网络代理，网络代理会根据请求的绝对路径对请求进行转发。为了避免请求循环，代理必须能够识别其所有服务器名称，包括任何别名，本地变体和数字IP地址 所有使用HTTP/1.1的服务器都必须支持绝对路径 authority：仅用于CONNECT请求 绝对路径：绝对路径可以作为Request-URI，但同时需要在请求头中包含Host域名 此时绝对路径不能为空，如果未指定，则应该置为\\ 如果Request-URI使用十六进制编码，则服务端必须进行解码以获取正确的请求。服务器针对错误的请求URI应该返回对应的相应值 禁止重写规则：网关代理在转发请求时严禁重写Request-URI中的绝对路径，使用\\代替空的绝对路径除外 禁止重写规则旨在当远程服务器错误地将非保留URI用于保留目的时，阻止代理更改请求的含义。但是一些HTTP/1.1之前的代理仍会更改请求URI 5.2 请求的资源 请求的资源由Request-URI和Host头共同决定 对HTTP/1.1请求 如果源服务器不允许根据请求host的不同返回不同资源时，其可以忽略请求头中Host头 如果源服务器需要根据请求host（有时也被称为虚拟host）的不同返回不同资源，其必须基于以下规则： 如果请求URI使用绝对路径URI，此时Host已经是请求URI中的一部分，请求的任何host头取值都必须被忽略 如果非绝对路径URI，同时请求头中包含Host头，则其取值将会决定请求host 如果前两条规则获取的host是无效值，服务端将会返回400Bad Request错误信息 HTTP/1.1请求的接收方缺失Host头时会尝试采用启发式的方法以便确定请求的资源，如根据URI路径寻找特定的host 5.3 请求头字段 请求头允许客户端向服务端传输请求与客户端的额外信息，作为一些语义化的参数 Accept Accept-Charset Accept-Encoding Accept-Language Authorization Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards：最大可转发次数 Proxy-Authorization Range Referer TE User-Agent 请求头的name只有在协议升级时才能被可靠地扩展，但如果通信中的各部分均能识别一些新的或者实验性的请求头字段，也可以进行对应扩展。不能识别的头字段将被当做实体头对待 6 响应 接收和解析请求信息之后，服务器将会返回一个HTTP响应信息 Response = Status-Line *(( general-header | response-header | entity-header ) CRLF) CRLF [ message-body ] 6.1 状态行 响应信息的第一行为状态行，包括HTTP版本、状态码与描述文本，使用空格相连，最后为回车换行 Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF 6.1.1 状态码与描述短语 状态码为三位整数，描述短语用于给状态码一个简短的描述 状态码是机器可读的，原因短语是人可读的，状态码的描述短语可能会被替换，客户端并不需要检测或展示原因短语 状态码的第一位代表响应的分类 1xx：信息响应，请求收到，客户端继续发送请求 2xx：成功响应，请求成功接收与解析 3xx：重定向，需要采取进一步操作以完成请求 4xx：客户端错误，请求包含错误的语法或无法实现 5xx：服务端错误，服务端无法处理一个有效请求 HTTP的状态码是可扩展的，HTTP应用并不需要理解所有的状态码，但是其必须能够明根据状态码的第一位进行分类，任何不识别的状态码等价于X00，同时此响应不能被缓存。在这种情况下，UA应当向用户呈现随响应返回的实体，其中可能会包含解析该异常的信息 6.2 响应头 服务端可以在响应头中传输不能在状态行中传递的额外信息，这些头字段提供关于服务端与进一步访问Request-URI所需的信息 Accept-Ranges Age ETag：对应请求头中的If-None-Match Location Proxy-Authenticate Retry-After Server Vary WWW-Authenticate 扩展规则与请求头相同 7 实体 请求和响应消息如果没有请求方法或响应状态代码的限制，可以传递实体消息。实体消息包括实体头字段与实体正文，有时部分响应会仅包含实体头 实体消息在请求和响应中均可以发送，其发送方和接收方不固定 7.1 实体头字段 实体头字段定义实体正文的元信息，当没有实体正文时，其定义所请求资源的元信息 这些元信息中部分是可选的，另一部分是必须的 entity-header = Allow | Content-Encoding | Content-Language | Content-Length | Content-Location | Content-MD5 | Content-Range | Content-Type | Expires | Last-Modified | extension-header extension-header = message-header 扩展头机制允许在不改变协议的情况下增加额外的实体头字段，但是接收方可能不识别这些字段。接收方应该忽略其不能识别的字段，传输代理应该对这些字段透明转发。 7.2 实体正文 实体正文伴随着HTTP请求或响应发出，其格式与编码方式在实体头字段中定义，最终采用二进制形式传输 仅当信息中出现消息正文时，实体正文才会出现，如同4.3节所讲。为确保安全和正确的传输消息，从消息正文中通过解码获取实体正文 7.2.1 数据类型 当消息中包含实体正文时，消息头字段中的Content-Type和Content-Encoding决定了其中的数据类型，其内容模型如下： entity-body := Content-Encoding( Content-Type( data ) ) Content-Type特指实体正文数据的媒体类型 Content-Encoding指应用于数据的附加内容编码，通常用于数据压缩。没有默认的编码方式 HTTP/1.1消息中，任何包含实体正文的消息，都应该包含Content-Type头字段用于指定正文中的媒体类型。当且仅当Content-Type未给定时，接收方会尝试通过检查其内容或资源URI扩展名来识别资源，如果媒体类型依然未知，该资源将会被当做application/octet-stream类型对待 7.2.2 实体长度 消息的实体长度即为传输编码前消息正文的长度 消息正文的传输长度在4.4节给出 "},"HTTP1.1/Connection.html":{"url":"HTTP1.1/Connection.html","title":"连接","keywords":"","body":"8 连接 8.1 长连接（持久连接） 注意长连接、短连接、长轮询、短轮询 当不使用长连接时，每次请求url都需要建立单独的TCP连接，此举增加了HTTP服务器的开销并且造成网络拥堵。 使用内联图片和其他一些数据资源往往需要客户端在短时间内向同一个服务端进行多次请求，可以针对此类情况建立长连接，多次请求均在一个TCP/IP连接中进行。实际HTTP/1.1实现的实施经验和测量结果都显示出良好的结果，同时其他替代方案也在探索中，如T/TCP HTTP长连接优点： 减少建立的TCP连接数目，节省路由器和主机的CPU占用，节省主机关于TCP协议控制的内存占用 提高单个TCP连接的效率，减少其空闲时间。在一个连接中，HTTP请求和响应可以被流水线操作，允许客户端同时发起多个请求而不必等待每一个的响应。 HTTP/1.1与HTTP/2请求过程的不同 HTTP/1.0同域名下单个请求单个TCP连接 HTTP/1.1同域名下多个请求单个TCP连接，但是只能串行执行，FIFO，每个TCP连接上只能同时有一个请求或响应 HTTP/2同域名下多个请求单个TCP连接，并行执行 减少网络拥塞。通过减少TCP连接与断开减少网络上的数据包从而减少网络拥塞，同时给与TCP连接足够的时间确定网络拥塞状况 后续请求中没有TCP的建立与三次握手，减少请求延迟 HTTP可以更优雅，当发生错误时可以回传错误信息，而不是直接关闭TCP连接。 HTTP长连接缺点 即使是空闲状态，也会消耗服务器资源 重负载时，可能会遭受DoS attacks攻击。故应该尽早释放空闲连接，减轻对性能的影响 总之HTTP协议的实现应该包含长连接 8.1.2 整体操作 HTTP/1.1中长连接是任何HTTP连接的默认行为，这是其与更早版本的HTTP协议之间一个标志性的不同。这意味着除非具有特殊声明，客户端应该申请和服务端之间建立长连接，即使服务端返回了一个错误的响应 长连接机制提供了一种机制，客户端和服务端可以通过信号控制TCP连接的关闭，其使用Connection头字段作为信号。一旦信号发出，客户端在当前连接中禁止再发送任何请求 传输 当Connection头字段值位close时，长连接将被断开。 如果HTTP/1.1服务器希望在返回响应后立即断开长连接，其应该将响应头中Connection置为close 如果HTTP/1.1客户端希望在本次请求后断开长连接，其应该将请求头中Connection置为close 长连接是否保持基于请求与响应中的Connection头字段，如果请求或响应任意一方的Connection字段为close，则该请求是当前连接中的最后一个请求 除非有特殊声明，否则当HTTP版本低于1.1时，客户端与服务端不应该采用长连接 为了保持长连接，连接中的所有消息都必须包含一个自定义的消息长度，如4.4中所述，当有一条消息未携带此字段，连接会被关闭。注意Content-Length与Transfer-Encoding之间联系 流式处理（流水线技术） 支持长连接的客户端也许会对其请求做流式处理，即可以连续发送多个请求不用等待其响应，服务器必须按照收到请求的顺序发送其对应的响应 支持长连接和流式处理的客户端，在连接建立后，如果第一次流处理失败，应该立刻重试连接 如果客户端进行了这样的重试，其必须知道当前连接是长连接后才会进行流式处理 如果服务端在发送完所有响应前关闭了连接，客户端必须重发这些请求 客户端不应该使用流式处理发送使用非幂等的请求方法或非幂等性序列的请求方法，否则过早的终止连接将会带来不可知的结果。如果客户端想要发送一个非幂等请求，应该等之前请求响应都接收到之后再发送 幂等请求方法：一种HTTP方法，多次调用不会产生不同的结果 并不是所有类型的 HTTP 请求都能用到流水线：只有idempotent 方式，比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试 8.1.3 代理服务器 代理服务器必须与其连接到的客户端和源服务器（或者其他代理服务器）分别维持长连接，每个长连接都会单独占用一个传输链路 代理服务器禁止与一个HTTP/1.0的客户端建立HTTP/1.1的长连接（不过很多HTTP/1.0客户端使用Keep-Alive头字段，这也带来了一些问题RFC 2068） HTTP/1.0中试图使用Keep-Alive实现长连接，但是其中存在问题，部分客户端会盲目向代理服务器发送该请求头导致连接被挂起不能释放，故被废弃，目前HTTP/1.0中使用Connection头标志是否进行长连接 Connection: Keep-Alive 8.1.4 实践中的注意事项 当服务器通常会有一些timeout超时值，超过这个值服务器将不在保持不活动的连接。由于客户端和同一个服务端之间可能会同时存在多个连接，所以代理服务器可能会将这个值变得更大。使用长连接的地方无需使用timeout，无论是对客户端或服务器 当客户端或服务端希望将连接超时中断时，其应该被优雅的关闭，客户端与服务端应该不断监听另一侧的连接状况，并且做出适当响应。如果不及时检测另一端的连接状态，可能会造成网络上不必要的资源浪费 请求链中的任意一方都可能在任何时刻关闭连接，如一方在关闭的同时另一方正好在发送，因此需要各方必须能够从异步的关闭事件中恢复过来。 在客户端中 如果请求序列是幂等的，应该重新开启传输连接，并重新发送被中断的请求，无需用户干预 如果请求方法或请求序列是非幂等的，禁止自动重发 如果第二次重发仍失败，不应该继续重发请求序列 服务端中，如果可能的话，在每个连接中服务端应该至少响应一个请求。除非怀疑网络或客户端报错，服务端不应该在发送响应途中关闭连接 使用长连接时，客户端应该限制与给定服务器的并行连接数。（以下两规则紧密相连） 单用户客户端与任何服务器或代理的连接不应该超过两个 一个代理与其他另一个服务器或代理间应该最多使用2*N个连接，N为同时活动的用户数 这些注意事项都是为了提高HTTP的响应时间，避免网络拥塞。 8.2 信息传递要求 8.2.1 长连接和流控制 HTTP/1.1中服务端应该维持长连接并且使用TCP的流控制解决临时负载过重问题，而不是关闭连接等待客户端重连，否则会恶化网络拥塞情况 8.2.2 监控错误状态的连接 使用HTTP/1.1与更高协议的客户端，在传送请求发送消息体时，应该监控网络连接，以防出现错误状态。当客户端监听到错误状态时，应该立刻停止发送消息体。 如果正在使用chunk分块编码发送消息正文，则可以使用零长度块和空trailer来标记消息的提前结束。如果正文前面有Content-Length消息头，客户端必须关闭连接 8.2.3 100状态(Continue)的使用 100(continue)状态的目的是在客户端发送请求正文前，远程服务器将基于请求头决定是否接受该请求，如果接受，返回100响应，客户端发送一个携带请求正文的请求 部分情况下，当服务端拒绝接受请求时，该状态的使用将会变得十分低效 对HTTP/1.1客户端的要求： 如果客户端在发送请求正文前，需要等待100响应，则必须在请求头中加入Expect: 100-continue项 当客户端不需要发送请求正文时，禁止发送Expect: 100-continue请求头 但是由于旧版本协议的存在，协议允许客户端发送Expect: 100-continue请求头后不再等待417Expectation Failed或100Continue响应。故当客户端向服务端或代理发送该请求头后，在发送请求body前不必无限等待响应的返回 对HTTP/1.1服务端的要求： 当收到包含Expect: 100-continue的请求后，服务端必须在响应100状态码，继续读取输入流和响应一个最终的状态码中二选一。源服务器禁止在发送100响应之前等待请求body的到来。如果响应了最终的状态码，则可能关闭传输连接或者继续读取但丢弃剩余的请求。如果返回最终的状态码后，将不能执行所请求的方法 当请求头中不包含Expect: 100-continue时，远程服务器不应该返回100(continue)响应，并且，如果该请求来自于HTTP/1.0客户端，绝对禁止返回该响应 例外：服务器可能会对HTTP/1.1中PUT和POST请求返回100状态码，即使其没有该请求头。此做法目的在于最大程度上减小客户端中与100状态相关的未声明等待所造成的处理延迟，此例外仅对HTTP/1.1生效，对其他版本无效 在一串连贯的请求中，当服务器已经接收到一部分或者所有的请求正文时，其可能会不在发送100响应 远程服务器发送100状态码后，一旦开始接收和处理请求正文，就必须在整个过程完毕后返回一个最终状态码，除非服务器提起终止了连接 如果远程服务器接收到的请求中不包含Expect: 100-continue请求头，而包含请求正文，服务器将在读取全部的请求正文前响应最终状态码。在读取到全部请求正文或客户端关闭连接前，服务器不应该关闭连接，否则客户端也许并没有接收到响应消息 对HTTP/1.1代理服务器要求： 代理收到包含Expect: 100-continue的请求后， 如果其知道下一跳服务器支持HTTP/1.1或更高版本，或者不知道下一跳服务器的HTTP版本，则必须如实转发请求 如果其知道下一跳服务器版本是HTTP/1.0或更低，则禁止转发请求，直接响应417状态码 代理应该维持一份缓存，记录最近使用过的下一跳HTTP版本 当发出请求的客户端版本低于HTTP/1.1或其请求头中不存在Expect: 100-continue时，代理禁止向其转发100状态码 8.2.4 服务器提前终止连接时客户端行为 如下情况客户端应该重发请求 客户端发送一个携带了请求正文的请求，但是请求头中没有Expect: 100-continue 客户端未能连接到一个HTTP/1.1源服务器 客户端在收到服务器响应前发现连接断开 客户端重发规则： 和服务器之间创建一个新连接 传输请求头 初始化一个变量R，用于估算来回服务器双程所花时间（基于建立连接所花时间），如果双层时间不可估算，则取定值5秒 计算T = R * (2**N),N为重发次数 等待服务器的错误响应或时间T 如果未收到错误响应，则时间T后再次重发请求body 如果客户端发现连接被提前关闭，则重复步骤1知道请求被接收，收到错误响应，或者用户不再等待主动关闭重发过程 当任何时刻收到错误响应时，客户端应该立刻 停止重发过程 如果请求消息未发送完，则关闭连接 9 请求方法 (#Method_Definitions) 所有的请求中都必须包含Host请求头 9.1 安全与幂等的方法 9.1.1 安全的方法 开发者应该认识到软件代表用户在互联网上进行交互，同时应该注意让用户清楚其任何操作都将对他们自己或他人带来未知的影响 特别的，规则约定了GET和HEAD请求除了检索外，不应该具有采取其他操作的含义，即规则认为GET和HEAD方法是安全的。不过不能保证服务端在处理GET请求时是否会造成其他的影响，但这与请求本身没有任何关系 其允许用户代理在特殊情况下用这两种方式标识其他请求方法，如POST、PUT和DELETE，以便用户意识到正在进行的请求可能是不安全的操作 9.1.2 幂等方法 幂等性：请求方法的一种属性，代表N>0次的请求造成的影响与单次请求影响（除去错误与请求过期问题）相同 GET、HEAD、PUT与DELETE方法都具有此属性 OPTIONS与TRACE方法不会造成影响，本身即具有幂等性 但是可能一些请求序列不是幂等的，即使其中每一个请求方法都是幂等的。幂等序列要求整个序列重新执行结果不变，或者其部分序列重新执行结果不变。同样，如果序列执行不会造成影响，则其即为幂等的 9.2 OPTIONS请求 OPTIONS方法表示请求使用Request-URI标识的请求/响应链上可用的通信设置信息，该请求方法可以使客户端确定与资源相关的一些选项或服务器的处理信息，而不用真正进行资源的请求。 OPTIONS请求的响应无需缓存 如果OPTIONS请求包含实体body，其媒体类型必须在Content-Type字段中说明（请求body的存在会由Content-Length or Transfer-Encoding说明）。 不过HTTP/1.1协议中暂时还未定义OPTIONS请求中body的使用，将来可能会在扩展中使用body 如果OPTIONS请求的Request-URI是*，则该请求一般是针对服务器的请求，而不是针对特定资源的请求 通常一个服务器的通信设置是因资源而异的，这种Request-URI是*的请求一般用于ping或一些空操作的方法，其仅用于客户端测试服务端的可用性。如，其可以用于测试代理是否支持HTTP/1.1 如果OPTIONS请求的Request-URI不是*，则OPTIONS请求仅针对其给定的资源，请求其对应的设置信息 OPTIONS请求的200响应 头字段中应该包含服务器实现并适用于该资源的可选功能，可能还会包含一些其他的扩展项 响应正文中应该包含通信设置项信息。 如果不包含响应正文，则响应必须包含Content-Length头字段且取值为0 Max-Forwards头字段也许会在请求中使用。当代理收到一个可以转发的绝对路径OPTIONS请求时，需要检查该属性值 若属性值为0，则禁止转发该信息，并且应该响应自己的通信设置信息 若属性值为大于0整数，则当转发该信息时需要将此值递减 如果请求中没有这个头字段，则转发后也不能有这个头字段 9.3 GET请求 GET请求表示请求由Request-URI标识的任何数据 如果Request-URI指向了一个数据处理过程，则应该将处理完的数据放入响应实体返回，而非返回处理前的原数据 条件式GET请求 当GET请求包含If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range头字段时，其语义会变为条件GET请求，请求结果依特定首部取值而定。条件GET请求的目的在于通过允许缓存实体，减少请求数量，从而减少不必要的网络传输 局部式请求 当请求头中包含Range头时，GET请求会变为局部式请求。局部请求只会传输实体的一部分，不用传输客户端已经缓存的数据，节省网络流量 GET请求可以按需进行缓存 9.4 HEAD请求 除了服务端不会在响应中返回消息正文外，HEAD请求与GET请求相同，如响应头中的元信息 HEAD请求可以在避免传递消息实体的情况下获取元信息，该方法常用于测试超链接的有效性、可访问性和最近的修改 HEAD请求的响应可以被缓存，因为响应中包含的信息可以用于更新之前缓存的资源。如果响应中新的头字段通过Content-Length,Content-MD5,ETag或Last-Modified表明已缓存的实体与最新的实体不同，则缓存需要将目前的缓存进行过期处理 9.5 POST请求（非幂等） POST方法用于向远程服务器发送请求实体，其作为由Request-URI标识资源的从属 POST方法被设计用于以下功能： 向现有资源添加注解 将消息发布到公告板，新闻组，邮件列表或类似的文章组 向数据处理过程提供数据块，如提交表单的结果 通过附加操作扩展数据库 实际功能由服务器决定，通常依赖于Request-URI 执行结果： POST方法的执行结果可能不会生成可以使用URI标识的结果，此时可以适当返回200(OK)或204(No Content)，具体取决于响应中是否包含描述结果的实体 如果远程服务器生成了新的资源，则返回201(Created)，响应实体中描述请求状态并指向新的资源，响应头中包含Location POST方法的响应不可缓存，除非响应中包含适当的Cache-Control或Expires头。但是303(See Other)响应可以指示用户代理检索可缓存的资源 POST方法需要遵循安全策略与传输要求 9.6 PUT请求（幂等） PUT方法将请求所包含的实体存储在提供的Request-URI下，通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容 如果Request-URI指向已存在的资源，则源服务器应该使用请求实体进行更新，此时应该返回200(OK)或204(No Content) 如果对应的Request-URI不存在，则源服务器可以为该URI创建资源，此时必须返回201(Created) 如果Request-URI对应的资源不能被创建或更新，应该返回响应告知原因。服务器严禁忽略Content-*类的请求头，如果其不能理解或实现，必须返回501(Not Implemented)响应 PUT方法响应不可缓存 POST与PUT方法基本差异在于请求URI的含义 POST请求的URI标识处理请求实体的资源，其形式可能多种多样 PUT请求的URI标识请求附带的实体，服务器不得尝试将请求应用于其他资源。如果服务器需要将其应用到其他的URI，必须返回301永久重定向，由UA决定是否进行请求的重定向 一个资源可能对应着多个不同的URI，如多个URI对应不同的版本。如果PUT方法使用一个通用URI，则可能导致其他URI对应的资源也被改变 HTTP/1.1中未定义PUT方法该如何改变服务端的状态 9.7 DELETE请求 DELETE方法用于请求远程服务器删除Request-URI所标识的资源。 DELETE方法在服务器上可能会因为人工干预或其他原因被拒绝 客户端不能保证操作已执行,即使从源服务器返回的状态码表示请求已经成功完成。 服务端在返回响应时，除了计划删除资源或将其移动到不可访问的位置外，其他情况不应该返回成功 当返回成功时，可以选择以下几种状态码： 200(OK)：响应中包含实体 202(Accepted)：操作尚未执行 204(No Content)：操作已执行，但响应中不包含实体 9.8 TRACE请求 TRACE方法沿着到目标资源的路径执行一个消息环回测试，请求的最终接收者应当将其接收到的消息作为200响应的实体返回。最终接收者是指远程服务器或者到达最大跳数的网关或代理 TRACE请求不能包含请求实体 TRACE方法允许客户端查看请求链的另一端接收到的内容 Via头字段的值跟踪记录了请求链的路径 Max-Forwards头字段允许客户端限制请求链的长度 如果请求是有效的，则响应的实体中应当包含请求信息，其Content-Type为message/http TRACE请求的响应不能被缓存 CONNECT 规范保留方法，用于代理切换到隧道连接 10 响应状态码 10.1 1xx 信息类响应 这类状态码表明一个临时的响应，该响应仅包含一个起始行和可选的响应头，并且以空行结束，对此类响应没有响应头的要求 由于HTTP/1.0没有定义1xx类的状态码，所以服务端禁止向HTTP/1.0返回1xx类响应 客户端必须做好在常规响应之前接收一个或多个1xx类响应的准备，意料之外的1xx类响应可能会被UA忽略 代理必须转发1xx响应，除非代理与客户端之间连接被关闭，或者是代理自己向服务端请求的1xx类响应 100 continue：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它 101 Switching Protocol：该状态为响应客户端的 Upgrade 标头发送的，服务器将在终止101响应的空行之后立即将协议切换到响应的Upgrade头字段定义的协议。只有当对双方有利时才会使用 102 Processing：服务器已经收到并正在处理请求，但没有响应可以使用 103 Early Hints：允许UA启动预加载资源 10.2 2xx 成功类响应 200 OK：请求成功，成功的含义取决于请求方法 GET：请求的资源已经在响应中发送 HEAD：请求的实体头已经在响应中发送，且不包含消息体 POST：描述操作结果的资源在消息体中传输 TRACE：最终服务器收到了请求 201 Created：该请求已成功，并因此创建了一个新的资源 202 Accepted：请求已经接收到，但还未响应，没有结果 203 Non-Authoritative Information：服务器已成功处理了请求，但返回的实体头部元信息不是来自于原始服务器，而是本地或者第三方的拷贝，可能经过代理服务器的修改 204 No Content：服务器成功处理响应，但不需要返回任何实体body，有时会返回更新了的元信息。 204响应将不会造成用户页面上的任何更改 204响应禁止包含响应实体，所以总是以header后的第一个空行结尾 205 Reset Content：重置文档视图 服务器已经成功处理请求，UA应该重置发送请求的文档页面，便于用户的下一次输入。 与204响应相同，禁止包含响应实体 206 Partial Content:服务器已经成功处理了部分GET请求，此类响应可以实现断点续传或者一个大文件分解为多个下载段同时下载 请求必须包含Range头指明请求区间，也可以包含If-Range头作为请求条件 对应的响应必须使用如下头字段： Content-Range与Content-Length Date ETag and/or Content-Location Expires, Cache-Control, and/or Vary 缓存相关 当请求使用If-Range头，响应返回206时需要避免返回其他实体头，其意义在于避免缓存实体正文与更新请求头之间的冲突。否则该响应返回的实体头与200响应相同 如果使用强缓存校验，响应中不应该包含其他的实体头 如果使用弱缓存校验，响应中禁止包含其他的实体头 如果ETag或Last-Modified头不能被匹配，则响应不能使用缓存 如果缓存不支持Range和Content-Range，则不能缓存206响应 10.3 3xx 重定向类 此类状态码需要UA进一步操作才能完成请求，第二个请求只能使用GET或者POST。 客户端应当检测无限重定向循环，避免网络流量浪费。在之前的版本中，会被最大重定向次数为5次 300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向 301 Moved Permanently：永久重定向，该响应可缓存 请求的资源已经被转移到了新的URI，将来任何针对此资源的请求都应当使用本次返回的URI。功能支持时，客户端应该讲请求地址替换为服务端返回的地址 新的重定向地址在响应的Location字段中给出，除HEAD请求外，响应的实体还会包含简短的指向新URI的超链接 当收到GET或HEAD请求之外的301响应时，UA禁止自动重定向请求，除非得到用户批准，因为这可能会改变发出请求的条件，如在HTTP/1.0下，301转发POST请求可能会变为GET请求 302 Found：临时重定向 请求的资源暂时从其他URI响应。由于这样的重定向是暂时的的，所以客户端应当继续使用原有请求地址 只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 重定向响应字段与响应实体与301相同，禁止自动重定向规则也和301相同 NOTE：目前规则禁止客户端修改请求方法，但是大部分UA将302与303处理规则相同，无论之前请求方法是什么全部使用GET请求获取新资源。故在303和307状态码中明确服务端希望得到哪种反应 303 See Other 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用GET的方式访问那个资源，该方法主要用于将POST请求转化为GET请求 303响应本身禁止被缓存，但是第二个GET请求可以被缓存 很多HTTP/1.1之前的版本不能正确识别303响应，此时可以使用302响应代替 304 Not Modified 客户端执行条件GET请求（即携带If-none-match等）且请求已被允许，而文档的内容自上次访问以来或根据请求的条件未发生改变 304请求禁止包含请求正文，故请求始终以消息头后的第一个空行结尾 如果一个304响应表明一个实体没有被缓存，则缓存必须忽略该响应然后重新发起请求，此时不携带缓存条件 如果缓存使用接收到的304响应更新缓存项，则缓存必须更新该项以反映响应中给定的新字段值 305 Use Proxy：被请求的资源必须通过指定的代理才能被访问，废弃 307 Temporary Redirect 307状态码大部分与302、303相同，不同之处在于307不会改变请求方法，POST请求重定向时，在获得用户允许后，会再次发起一个新的POST请求 10.4 4xx 客户端错误 4xx状态码适用于客户端出错的情况 400 Bad Request：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求 401 Unauthorized：当前请求需要用户验证 402 Payment Required：用于数字支付系统，未使用 403 Forbidden：服务器已经理解请求，但是拒绝执行它 身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交 如果请求是一个非HEAD请求，并且服务器希望公布请求为何被拒绝，则应该在实体中描述对应原因 如果服务端不希望客户端知道拒绝原因，也可以返回404 404 Not Found：对应Request-URI资源未找到 404状态码不能够表明此情况是永久的还是暂时的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址 404状态码广泛用于 服务器不想揭示到底为何请求被拒绝 没有其他适合的响应可用 405 Method Not Allowed：请求行中指定的请求方法不能被用于请求Request-URI资源 响应必须返回一个Allow头，其中列出Request-URI允许的请求方法 PUT、DELETE方法会对服务器资源进行写操作，大部分网页服务器都不支持，均会返回405错误 406 Not Acceptable：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体 407 Proxy Authentication Required 与401类似，但是是代理服务器需要验证，与代理服务器有关 408 Request Timeout：请求超时 客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改 409 Conflict：由于和被请求资源的当前状态之间存在冲突，请求无法完成 只在服务器认为用户能够解决冲突的情况下使用，且会提交新的请求。响应中包含足够信息以便用户发现冲突的源头 410 GONE：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址 411 Length Required：服务器拒绝接受未定义Content-Length的请求 在增加了有效地Content-Length头之后，客户端可以重发请求 412 Precondition Failed：先决条件验证失败 服务器验证请求头字段中给出的先决条件时，验证失败 该状态码允许客户端在请求头中增加元数据，作为先决条件在服务器上进行判断，避免请求方法用在期望的内容之外 413 Request Entity Too Large：请求体过大 请求实体过大，超出服务端接受范围，导致服务端将关闭与客户端之间的连接 这种情况是暂时的，服务端将返回Retry-After头字段告知客户端多久之后重试 414 Request-URI Too Long 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。一般出现在POST请求误用GET请求发送导致参数过多 415 Unsupported Media Type：请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝 416 Requested Range Not Satisfiable：数据范围不重合 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码 417 Expectation Failed：服务器无法满足 Expect 请求标头字段指示的期望值 10.5 5xx 服务器错误 当服务器出错或不能执行请求时使用，响应应当包含错误情况解释，是临时错误还是永久错误，UA应该向用户进行展示 500 Internal Server Error：服务器遭遇未知情况 501 Not Implemented：请求方法不被服务器支持且无法被处理 只有GET和HEAD是要求服务器支持的，这两种方法必定不会返回此错误代码 502 Bad Gateway：网关或代理处理请求时，从上游的服务器得到一个错误的响应 503 Service Unavailable：服务不可用 由于暂时过载或服务器维护导致目前服务器无法处理请求，这种情况应该是短暂的，在一定延时之后会被减轻，故通常不会被缓存。 如果延时可知，应该在响应的Retry-After头中告知等待时间，如果未给出等待时间，将响应当做500处理 NOTE：503状态码并不是服务器过载时必须使用，一些服务器也许希望使用较为简单的状态码拒绝连接 504 Gateway Timeout：服务器作为网关不能及时得到响应时返回次错误 505 HTTP Version Not Supported：服务器不支持或拒绝支持请求中使用的HTTP协议版本 服务器表示它无法或不愿意使用与客户机相同的主版本完成请求，响应中应该说明不支持此版本的原因与服务器支持的协议 11 权限鉴定 HTTP提供了几种可选的质询 - 响应认证机制，服务器可以使用它来质询客户端请求，并由客户端提供认证信息 12 内容协商机制 HTTP响应中包含的实体传递大量信息，但是由于用户需求、UA能力等不同，并非所有用户需要相同实体。 HTTP提供内容协商机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配。两种协商机制：服务端驱动型（主动型，更常见）与代理驱动型（被动型） 任何包含实体正文的响应，可能都遵循内容协商，包括错误响应 12.1 服务端驱动型内容协商机制 如果内容协商机制算法位于服务器端，则被称为服务端驱动型内容协商机制，协商机制基于响应的可用表示（如language、content-coding等），和请求中携带的请求头和其他详细信息（如网络地址），通过内部算法来选择最佳方案提供给客户端 服务器会使用Vary消息头来说明实际上哪些消息头被用作内容协商的参考依据（确切来说是与之相关的响应消息头），这样可以使缓存的运作更有效 此方法缺点： 无法真正得出最佳结果，应该这需要获取完整的客户端与响应信息 请求低效的和潜在的隐私风险 使得服务端实现变得复杂，规模化存在问题 共享缓存的效率会降低 HTTP/1.1规定描述UA能力的请求头：Accept、Accept-Charset、Accept-Encoding、Accept-Language、User-Agent。但是服务端也可以使用请求头之外的数据或扩展头字段 12.2 代理驱动型内容协商机制 在从源服务器接收到响应之后，UA从响应列表中选择出响应的最佳表示 代理驱动协商的优缺点： 优点是无需从请求中获知客户端能力，减轻服务端负载 缺点是需要第二个请求来获得最佳替代表示，第二个请求仅在使用缓存时才有效 当服务器不愿或无法使用服务器驱动协商时，可以通过300或400状态码，使用代理驱动的内容协商机制 12.3 透明协商机制 即为两种协商机制联合使用。 优点为分配协商工作，否则需要增大服务器负载或增加延迟 "},"HTTP1.1/cache.html":{"url":"HTTP1.1/cache.html","title":"HTTP缓存","keywords":"","body":"13 HTTP缓存 重要哦 HTTP是通常用于分布式信息系统,可以对响应进行缓存提高性能 缓存的目标 减少发送请求：减少网络请求往返 减少发送完整响应：减少所需网络带宽 13.1 缓存存储机制 13.1.1 正确的缓存 正确的缓存必须是一个使用缓存持有的最新一次的respond响应request，并且符合以下条件之一 通过与源服务器重新验证响应，已检查它是否与源服务器返回的内容等效。 缓存未超时 响应消息是304、305或请求错误（4xx或5xx） 当缓存无法与远程服务器通信时，如果缓存能够满足响应则应该直接使用，否则应该返回错误或警告出现通信错误 当缓存接收到响应时，应该直接转发给发出请求的客户端，即使响应已经超时也不应该添加任何或移除任何Warning头。响应可能在传输过程中超时，所以为了避免无穷循环，不应该由缓存在此处进行校验。当UA收到没有Warning的超时响应时，可能需要向用户展示一个警告信息 13.1.2 告警信息 当缓存返回一个被转发来的或已经超时的响应时，HTTP/1.1应该在响应上添加Warning头，允许客户端进行适当的操作 Warning头可能被用于缓存或其他功能，使用Warning的目的在于区分其与真正的请求错误 Warning头取值有三位，第一位用于判断是否必须从存储的缓存项中删除警告，1为删除，2为不删除 13.1.3 缓存控制机制 HTTP/1.1中基本的缓存控制使用Cache-Control头，可以在其中发送各种指令，通常这些指令会覆盖默认的缓存算法 但是部分情况下，Cache-Control的语义性被弱化 13.1.4 UA显示缓存相关警告 UA可以覆盖基本的缓存机制，但是应该提前通过用户的显式操作进行明确配置 当用户使用十分降低缓存效率的方式覆盖缓存机制时，UA应该不断向用户提示此状态 13.1.6 客户端控制缓存 缓存信息的主要来源时原始服务器，但是客户端也可以通过Cache-Control字段控制缓存 指定响应缓存的最长可使用时间，类似于max-age 指定响应到期前剩余的最短时间，类似于expires 13.2 缓存过期模型 13.2.1 服务器指定过期时间 当缓存完全避免向源服务器发出请求时，HTTP缓存效果最佳。 避免请求的主要机制是原始服务器在将来提供明确的到期时间，表明可以使用响应来满足后续请求，缓存可以在不首先联系服务器的情况下返回新响应 源服务器可以为每一个响应分配一个过期时间，响应的缓存在用于后续请求之前进行有效性验证。即服务器使用Expires或Cache-Control中的max-age指令显示指定过期时间 到期时间不能用于强制用户代理刷新其显示或重新加载资源，其语义仅适用于缓存机制，并且此类机制仅需在启动对该资源的新请求时检查资源的到期状态 13.2.2 启发式过期时间 源服务器不一定总会提供明确的过期时间，故HTTP缓存也会通过使用Last-Modified等头部字段，分配启发式的过期时间 启发式过期时间影响语义透明度，应当谨慎使用 13.2.3 缓存年龄计算 缓存是否可用取决于两点： 缓存的当前年龄 缓存可用的最终时间点 本节着重于第一点 Date头字段：HTTP/1.1中需要源服务器针对每个响应发送，用以标识响应生成时间 Age头字段：age字段的值是指从原始服务器获取响应以来，该响应被缓存的时间长度，单位为秒 即age字段是指源服务器在多久前创建了响应 则缓存的当前年龄 = max(当前系统时间 - Date, Age) + (now - request_time) 后面为对往返网络延迟时间的修正，此计算方法较为保守 HTTP/1.1规定代理使用缓存创建响应时必须添加Age字段，即在HTTP/1.1协议下如果发现响应中有Age字段，则响应不是第一手的。但是反之不可以，因为可能存在比较低的协议 13.2.4 缓存过期时间计算 本节计算缓存可用时间 Max-age优先级高于Expires 如果响应中指定max-age，则缓存可用时间 = max-age 否则，如果响应指定expire，则缓存可用时间 = Expires - Date 这两种计算方法所用信息均来自源服务器，故不受客户端时钟偏差影响 当响应中没有max-age、expires，并且响应不包含其他对缓存的限制时，可以使用启发式的计算缓存可用时间 如果响应中指定Last-Modified，则启发式的到期时间不应该超过自该时间以来的某个时间间隔，典型设置为10%，即取响应头中的Date与Last-Modified之间的差值的10%作为缓存有效时间 缓存是否可用：缓存可用时间 > 已缓存时间 13.2.5 边界情况 由于计算机制原因，可能出现同一个资源在两个缓存中过期时间不同的情况 如果客户端发现自身缓存的Date字段收到的非第一手响应还要新，则会忽略该响应，并使用Cache-Control：max-age = 0指令重试请求，以强制检查源服务器 如果缓存中针对同一个响应有两个条目，则应该使用Date字段更新的一个，如果相等，可以使用任意一个，更谨慎的情况下可以向服务器发起新请求 第二条中的cache-control字段即为客户端强制检查缓存，此处有两个选择 Cache-Control: max-age=0：强制所有中间缓存向源服务器进行验证 Cache-Control: no-cache：强制所有中间缓存从源服务器获取新副本 13.3 缓存对比机制 条件缓存：当缓存过期后，客户端需要向源服务器或代理验证缓存的可用情况 缓存良好时无需重新传输完整响应 缓存无效时，不用支付额外往返开销 原始服务器生成完整响应时，会附加某种验证器，缓存条目中也会保持一致。客户端发出条件请求时，会携带这些验证器，服务器会对验证器进行检查 如果匹配，返回304未修改，不携带实体主体 如果不匹配，返回完整响应，包含响应实体 条件请求除了携带验证器外，其他与普通请求相同 如果响应没有携带验证器，其依然可以被缓存与使用，但是过期之后无法被刷新 验证器字段 Last-Modified：实体上次修改时间，如果自Last-Modified值以来未修改实体，则响应有效，单位为秒 ETag：资源的唯一性标识符，弥补Last-Modified单位为秒的不足。分为强ETag和弱ETag 13.3.3 强验证与弱验证 强验证：当实体发生任何变化时，验证器也会变化。可用于任意上下文 弱验证：仅当实体在语义上发生重大变化时，验证器才会变化，资源更改并不总会修改弱验证器。仅在不要求两次请求实体完全相同时可用 客户端只能使用弱验证器发出简单GET请求，不能在其他请求方式中使用 Etag标签通常为强验证器，但是也提供了弱验证的机制，其中弱值会随着实体含义的变化而变化 强ETag值：不论实体发生多么细微的变化都会改变其值 弱ETag值：弱ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生语义性差异时才会改变ETag 值。这时，会在字段值最开始处附加W/ Last-Modified通常被默认为弱验证器 13.3.4 Etag与Last-Modified联合使用的规则 针对源服务器： 除非源服务器不能产生Etag，否则应该发送ETag头 当考虑性能因素或强ETag可不用时，可以使用弱ETag 源服务器应该发送Last-Modified 一般情况下，HTTP/1.1源服务器更倾向于发送强ETag和Last-Modified 针对客户端： 如果源服务器应提供了ETag，则在条件请求中If-None-Match或If-Match头必须使用该ETag 如果源服务器仅提供了Last-Modified，则条件请求中应该在If-Modified-Since中使用该值 如果源服务器提供了ETag和Last-Modified，则缓存的条件请求中两个验证器都应该使用，HTTP/1.0和1.1中均是 304响应的返回条件： HTTP/1.1的源服务器，在接受到包含Last-Modified日期或ETag的条件请求后，只有所有的条件请求头是符合要求时，才可以返回304 HTTP/1.1的缓存代理，除非缓存的响应与请求中的所有条件头字段一致，才可以向客户端返回本地缓存的响应 此处为所有的条件头字段，即必须ETag与Last-Modify-Since都验证通过才可以返回304，具体顺序是先ETag后Last-Modified HTTP/1.0中ETag值会被忽略，但是部分情况下使用Last-Modified会导致严重问题，故 ETag：HTTP/1.1提出，更精确，强ETag与弱ETag Last-Modified：兼容HTTP/1.0版本 在此之外，不会使用其他头部进行缓存验证比较 13.4 响应的可缓存性 当响应既没有验证器，也没有相关的显示到期时间时，期望响应不应该被缓存 客户端可以通过响应的Date时间戳与当前时间进行对比，判断此响应是否使用了缓存 一些情况下处于语义或安全性考虑，响应不应该被缓存： 包含Authorization头的响应，用于告知服务器用户代理的认证信息 当缓存不支持Range和Content-Range头时，不能缓存206（部分内容）响应 如果响应是其他的状态码，如302或307，其中没有显式的缓存控制指令(cache-control或expires)，否则不能对后续的请求返回此响应 13.5 从缓存中构造响应 条件缓存下，当本地缓存可用时，缓存将把条件请求的一部分与缓存的一部分组合起来返回给用户，即将新响应的部分内容与已缓存的内容组合在一起 13.5.1 根据缓存分类请求头 端到端：传输给请求或响应的最终接收者 响应中的端到端头必须存储为缓存条目的一部分，并且必须在由缓存条目形成的任何响应中传输 跳到跳：仅在传输过程中用到，不会在缓存中存储，较少，详见文档 透明代理禁止改变或增加以下请求头： Content-Location Content-MD5 ETag Last-Modified 透明代理也不能修改Expires，但是其可以为请求增加Expires头，此时取值与Date相同 13.5.3 响应头的合并 当缓存发出条件请求得到响应后 如果是304，则缓存会使用缓存的实体作为响应的实体主体 如果是206，且ETag和Last-Modified完全匹配，则缓存会把存储在缓存中的内容与响应中接收的新内容组合，并将结果作为发送给客户端的实体主体 响应头的变化 此过程中，原来缓存中的响应头也会被使用，但是： 304或206响应中获取到的端到端类响应必须取代从缓存中获取到的对应的响应头 同时覆盖更新缓存中所有对应的端到端类响应头，warn头除外 该规则允许源服务器使用304或206对缓存的响应进行响应头更新，但是此规则不会删除某一个响应头。 13.5.4 响应体按范围合并 有时缓存中可能会保存实体的若干范围，故接下来的响应只需要传输其他范围即可，然后由缓存进行合并。 如果这两部分的缓存验证器不相匹配，则只使用拥有最新Date值的响应，忽略其他响应中缺失的其他部分 13.6 缓存协商策略 缓存协商策略使用服务器驱动的协商机制，Vary字段改变缓存将响应用于后续请求的协商条件和过程，详情参阅Vary头字段 服务器应该使用Vary字段通知给缓存，用于表示哪些请求头字段被用于服务器的缓存协商策略 当缓存接收到命中缓存实体的请求后 如果缓存实体中包含Vary字段，则会对新请求与缓存请求的Vary指定请求头的取值进行比较，如果完全匹配，则直接使用缓存 如果响应的Vary被指定为*，则之后的响应只能从源服务器获取 否则向源服务器发起条件请求 如果返回304，则可以使用缓存，且新响应的响应头被用于更新缓存中的响应头 如果返回其他响应码，则需要使用响应 如果缓存实体中包含ETag，则条件请求中会将其值包含在If-None-Match请求头中，用于服务端进行匹配 如果现有的缓存条目仅包含实体的部分内容，则条件请求中不应该使用If-None-Match，除非仅针对该范围进行请求 表明ETag优先级比Last-Modified高 当缓存收到一个成功响应，其Content-Location字段与同一Request-URI的现有缓存条目匹配，其ETag与现有条目的ETag不同，并且其Date比现有条目的Date更新 ，现有的条目应该从缓存中删除 Content-Location：用于表明报文主体返回的资源对应的URI 13.7 共享缓存与非共享缓存 出于安全与隐私角度考虑，缓存有必要分为共享缓存与非共享缓存。当缓存仅用于单一用户时，其是非共享的，其可访问性应该由适当的安全机制强制执行。其他情况下的缓存都是共享缓存 13.8 错误或部分响应的处理 缓存有时接收到的响应不是一个完整响应(响应的数据量小于Content-length中指定的值)，此时缓存可以将部分响应存储起来进行拼接，但是缓存必须意识到这是一个部分响应 此情况下，对于缓存有一定要求 禁止向客户端返回使用206标识的部分响应 禁止向客户端返回使用200标识的部分响应 当缓存在重新验证请求时收到5XX响应，缓存可以将错误响应直接返回给客户端，如果之前缓存的可用响应中没有必须重新校验缓存控制指令，也可以将之前响应发送给客户端 13.9 GET和HEAD请求的副作用 一般无需考虑这两种请求的副作用 但是如果请求的URI中带有search，可能这是一个非幂等请求，此时除非明确说明响应过期时间，否则缓存禁止缓存该响应。这是对HTTP/1.0的一个修订 13.10 缓存更新后的旧缓存的失效问题 一些HTTP方法必须导致对应的缓存实体失效，可能是Request-URI、Location或Content-Location引用的实体 HTTP方法有POST、PUT、DELETE 只有缓存实体的host部分与响应的Request-URI相同时，才会执行基于Location或Content-Location中URL的失效 传递缓存不理解的方法时，应该使Request-URI引用的任何实体无效 13.11 会引起服务器资源变更的请求 除GET和POST外，其他所有可能引起服务器资源变更的请求必须由源服务器直接响应，缓存不能回复来自客户端的此类请求，因为可能引起资源的不一致问题 13.12 缓存的替换 缓存收到新的响应时，根据13.6节中的相关规则，判断该响应是否可以替换之前的缓存。他可以被插入到缓存存储器中，以响应之后的相关请求。缓存的替换过程中需要注意响应头的更新 如果新响应的Date值比现有响应的Date更旧，则不应该进行缓存更新 13.13 历史机制 用户的历史记录与缓存不同，历史记录旨在显示用户曾经查看的资源，即使该资源缓存已过期，也仍然应该显示在历史记录中 总结 缓存应用的目的，减少网络请求，从而降低往返延迟与带宽需求 条件请求：ETag（强验证与弱验证）与Last-Modified（资源最后修改时间），ETag为HTTP/1.1新增，优先级更高 缓存控制头：Cache-Control头，取值max-age、no-cache等 缓存过期时间 服务器指定过期时间：Expires、max-age无需与服务端商议 启发式过期时间：Last-Modified，根据响应头计算 默认过期时间：响应头中的Date与Last-Modified之间的差值的10%作为缓存有效时间 · 响应头合并：304或206会更新对应响应头，但是不会删除任何一个响应头 缓存协商策略：Vary头增加被用于协商的头字段 其他问题 "},"HTTP1.1/headers.html":{"url":"HTTP1.1/headers.html","title":"HTTP首部字段","keywords":"","body":"14 HTTP首部字段 通用头 请求头 响应头 实体头 Cache-Control Cache-Control中指明了必须被缓存机制执行的指令，其会覆盖缓存机制的默认算法，同一个请求与响应对的Cache-Control指令不一定相同 所有的网关或代理都必须转发Cache-Control指令，这条指令可能对整条请求响应链生效，无法为某一处特定缓存指定对应的指令 Cache-Control可以用于重写缓存指令 能否缓存 \"public\"：该响应可以在任何情况下被缓存，即使其一般不能被缓存或只能在非共享缓存中使用 \"private\"：该响应的全部或部分仅供单个用户使用，不能用共享缓存进行存储，其他用户请求时无法使用 private仅用于控制在何处缓存响应，不确保消息的私密性 \"no-cache\"：简言之，一般no-cache会缓存但不会使用，不过此处存在两种用法 直接使用no-cache，则不得使用缓存满足后续请求 使用no-cache=，headers为一个或多个字段名，则可以使用缓存满足后续响应，但不得发送指定的headers HTTP/1.0可能不会遵循这些规则 缓存能否存储 \"no-store\"：禁止缓存，防止敏感消息外泄或保留，保证在尽最大努力转发后尽快从易失性存储中删除信息 如果在请求中发送，则缓存不得存储该请求或其任何响应的任何部分 如果在响应中发送，则缓存不得存储该响应或已发它的请求的任何部分 该属性可以改善隐私，但并不能完全去报隐私安全 缓存过期机制 缓存到期机制依赖于两个首部字段 Expires：指定缓存过期的绝对时间（HTTP/1.0） HTTP/1.0中Expires值如果小于或等于Date，会被视为no-cache，HTTP/1.1中作相同处理，以保持兼容性。此特性可以用于在使用缓存新特性时的兜底策略 max-age：优先级高于Expires，指定缓存过期的相对时间，当使用max-age时，代表响应是可缓存的（HTTP/1.1） 使用max-age的过期策略与本地时间无关，不受时钟不同步的影响 s-maxage：针对共享缓存使用，优先级高于maxage与expires，会被专用缓存忽略 min-fresh：缓存可用时间不小于当前时间 + min-fresh max-stale 如果指定一个值，则过期时间不超过此值的响应，均可使用 如果不指定值，则无论响应过期多久，都可以使用 如果缓存返回一个过期的响应，则要么是使用了max-stale，要么是响应的过期时间被覆盖 当请求与响应均具有max-age时，会使用较小的值作为缓存的过期时间 缓存的重新生效与重新加载 如果源服务器错误估计了缓存过期时间，则需要缓存重新生效 此处分两种情况，客户端有本地缓存副本的称为特定的端到端重新生效，没有本地副本的称为非特定的端到端重新生效 如果缓存发生了损坏，则需要缓存的重新加载 三种情况的不同处理 重新加载：使用no-cache，服务端禁止使用缓存响应此类请求 特定的端到端重新生效：使用max-age=0，迫使请求链路中的每个缓存都重新进行验证。初识请求中包含客户端现有缓存的验证条件 非特定的端到端重新生效：使用max-age=0，初识请求中不包含客户端现有缓存的验证条件，但之后会携带请求链路中第一份缓存的验证条件 通用首部字段 Connection Connection首部字段用于发送方指定一些特定的连接信息，不能被代理用于其他链接 `Connection : (connection-token)` HTTP/1.1代理必须在转发消息前，删除与connection-token同名的任何头字段。Connection通过connection-token进行信息的传递，不使用任何附加头 Connection头中禁止包含任何端到端的头部，例如Cache-Control Connection: close，标志着处理完当前响应后连接将会关闭 不支持HTTP/1.1长连接的应用程序每个消息中都必须包含close Date 标识该消息的发出时间，与orig-date相同予以，HTTP日期格式 除特殊情况外，源服务器必须返回Date字段： 响应时100或101，具体关乎服务器配置 服务器出错，可能不能返回可用的时间 服务器没有时钟，此时返回近似时间，且响应中不能使用Date等字段 客户端应该只在包含实体主体的消息中发送Date头字段，没有时钟的客户端不得在请求中发送Date 理论上，Date应该代表实体生成前的时刻，但实际上可以在消息发起期间的任何时间生成日期，而不会影响其语义值 Transfer-Encoding Transfer-Encoding标识已将何种传输编码应用于message body，以便于在发送方与接收方之间进行安全的转换，常用的取值有chunked 与Content-Encoding区别： Transfer-Encoding是消息属性，应用于body，范围更大 Content-Encoding是实体属性，应用于entity，范围更小 如果一个消息体应用了多种编码，则按照应用的顺序列出来编码格式，附加信息可由其他头字段给出 很多较旧的HTTP/1.0程序不了解Transfer-Encoding Via 网关和代理必须使用via字段指示请求与响应链中的中间协议与接收者，避免请求循环以及识别请求/响应链上所有发送者的协议 请求首部字段 用于补充请求的附加信息、客户端信息、对响应内容的优先级等相关信息 以下挑一些看 Accept 指定UA能够处理的媒体类型及其相对优先级q，取值范围0-1，可缺省，默认为1.0，格式如下 text/html;q=0.9, 服务器将优先返回权重最高的内容 Host Host首部表明请求资源所在的互联网主机名与端口号，在HTTP/1.1中要求必须携带 Host存在意义在于可能在单台服务器上存在多个域名的虚拟主机，此时IP地址相同，需要使用Host进行区分 If-Match 条件请求使用，携带ETag值请求服务端，用于更新缓存信息，防止缓存的错误更新 如果任何ETag值与类似GET请求得到资源的ETag匹配，或If-match值为*可以匹配到所有资源，则服务器执行该请求 否则，服务器会响应412（条件验证失败） 这种情况下只能使用强ETag 当If-match的值与服务端资源不匹配时，请求不会被执行，可以避免在用户不知道远程资源更新的情况下请求成功 If-none-match 条件请求使用，和If-Match语义相反，用于以最小开销更新缓存信息 如果任何ETag值与类似GET请求得到资源的ETag匹配，或If-none-match值为*可以匹配到任意资源，则继续比较步骤3Last-Modified-Since 如果步骤1中比较发现不匹配，则忽略Last-Modified-Since，直接执行该请求 如果资源的修改时间与Last-Modified-Since不匹配时，请求仍需执行，否则请求无需执行 此处表明ETag优先级比Last-Modified-Since高，且HTTP/1.1中先比较ETag，后比较Last-Modified-Since，如果前者比较失败，则直接执行请求 返回的响应 对GET或HEAD请求，如果匹配一个缓存相关的header，则应该返回304 对其他所有的请求方法，服务器必须返回412（条件验证失败）。其他方法为非幂等，可能造成消息不对等 If-Modified-Since 条件请求使用，以最小的代价更新缓存信息 If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT If-Modified-Since的使用遵循以下规则 如果该请求返回200之外的内容或If-Modified-Since无效时，则该请求的响应与普通GET请求相同 当该字段值晚于服务器当前时间时，会被判定无效 如果请求的资源从该字段指定时间后发生变化，则请求的响应与普通GET请求相同 如果请求的资源从该字段指定时间后发生没有变化，则服务端应该返回304(Not Modified)响应，且不包含响应体 If-Modified-Since中的值为之前响应中服务端给定的Last-Modified，不受客户端时钟影响 请求中同时拥有If-Modified-Since和If-Match或If-Unmodified-Since的情况未定义，这几种header意义相反 但是牢记，ETag优先级高于Last-Modified，服务器先比较ETag，如果成功，在比较Last-Modified，如果再成功，则返回304 Referer Referer头用于标识获取资源的地址，服务器可以根据Referer头进行请求来源的过滤、日志记录、缓存优化等操作 目前较为常见的应用为使用referer过滤请求，防止非法请求源的访问，反爬虫等 如果Request-URI是从没有自己URI的源发起的，如用户直接在地址栏输入，则不得发送Referer头字段 User-Agent User-Agent头用于标识有关发起请求的用户代理信息，该字段可以包含多个产品领跑和标识代理以及构成用户代理重要组成部分的任何子产品的注释 User-Agent可以被用于如下场景 防盗链，即在一个app中可以打开的url在另一个app中无法打开，或进行其他提示 针对不同的用户代理直接展示不同的页面，如淘宝或微信中展示页面不同可能根据此原理（猜想） Max-Forwards Max-Forwards标识本条消息可以被转发的剩余次数 在TRACE和OPTIONS请求中用于限制与目标服务器之间的网关数量，可以用于客户端尝试追踪失败或循环的请求链路 每个代理或网关在接受到包含Max-Forwards标头字段的TRACE或OPTIONS请求后，都必须在转发请求之前检查并更新其值。如果接收到的值为0，则接收者不得转发请求，且必须作为最终收件人进行响应。 如果收到的Max-Forwards值大于零，则转发的消息必须包含一个更新的Max-Forwards字段，其值减1。 对于其他请求方法，可以忽略Max-Forwards头部 响应首部字段 Age 标识自源服务器生成响应以来经过的时间，常用于缓存服务器，十进制，以秒为单位 如果响应是由缓存生成的，则其中必须包含Age首部，Age最大为2^31，溢出后也是这个值 ETag 强弱ETag，见cache章节 Location Location字段用于将接收方重定向到Request-URI之外的其他位置，以完成请求或标识新资源，字段值为单个绝对URI 对于201，指向请求创建的新资源的位置 对于3xx，指向服务器的首选URI，用于自动重定向到资源 实体首部字段 Content-Encoding 一般用作媒体类型的标识，用于指示已将哪种内容编码机制应用于实体，如所以需要用对应的解码机制才能获取Content-Type所标识的媒体类型 Content-Encoding主要用于允许压缩文档而不会丢失基础媒体类型的标识，如gzip等 如果request中的Content-Encoding不被服务器接受，则会返回415（不支持的媒体类型） 如果一个实体应用了多种编码，则应该逐一列出 Content-Type 指示发送给接收方的媒体类型，如果是HEAD请求，则表示当此请求时GET时的媒体类型 Content-Language Content-Length 指示发送给接收方的实体大小，十进制，如果是HEAD请求，则表示当此请求时GET时的实体大小 注意Content-Length与Transfer-Encoding的冲突： 如果接收方收到的消息头中同时包含Transfer-Encoding和Content-Length，后者必须被忽略 消息中不能同时包含Content-Length头与非identity的Transfer-Encoding头，如果包含，前者将被忽略 在HTTP中，只要在传输之前可以确定消息的长度，就应该发送该消息，除非与其他规则相冲突 Content-Location 当可以从与请求资源的URI不同的位置访问该实体时，可以使用Content-Location字段提供资源位置 主要用于是指定要访问的资源经过内容协商后的结果URL，无需进一步的内容协商 NOTE 缓存不能假定当前的请求实体可以直接用于响应之后Content-Location中URI的请求，但是可以用Content-Location区分不同实体 Location与Content-Location区别： Location对应响应，一般用于指定重定向地址 Content-Location对应内容，与返回的数据关联，提供可访问资源的直接地址 "},"TCPIP/":{"url":"TCPIP/","title":"图解TCPIP","keywords":"","body":"图解TCPIP 第一章网络基础知识 第二章TCPIP基础知识 第三章数据链路 第四章IP协议 第五章IP协议相关技术 第六章TCP与UDP 第七章路由协议 "},"TCPIP/第一章网络基础知识.html":{"url":"TCPIP/第一章网络基础知识.html","title":"第一章网络基础知识","keywords":"","body":"网络基础知识 1.5 协议分层 上下层之间交互时所遵循的协定叫做接口 同一层之间的交互所遵循的约定叫做协议 OSI模型 应用层：针对特定应用的协议 表示层：设备固有数据格式和网络标准数据格式转换 会话层：通信管理，建立和断开通信 传输层：管理数据传输，负责可靠数据传输，TCP层 网络层：地址管理与路由选择，IP层 数据链路层： 互联设备之间的传送和识别数据帧 物理层：界定连接器等设备规格 分层意义： 各层之间是独立的 灵活性好 结构上可分隔开 易于实现和维护 能促进标准化工作 1.6 模型通信处理 网络路由器位于IP层 传输方式分类 面向连接与面向无连接 电路交换与分组交换 电路交换：独占线路进行数据传输 分组交换：数据细分、共享线路，路由器连接通信线路，FIFO 根据目标地址个数分类 单播，一对一 广播，一对所有与之相连的主机 多播，与广播相似，限制某一组主机作为接收方 任播，与多播相似，但是选取一组主机中的一台作为接收方，如DNS根域名解析服务器 1.8 地址 MAC地址、IP地址、端口号 地址唯一性 广播、多播、任播中一组设备赋予相同地址 地址层次性 用于高效找出目标地址，进行地址分层 IP地址具有层次性，分为网段与主机号，用于路由控制表，其中存储集中之后的网络号（涉及子网掩码） MAC地址在每块网卡上写死，用于地址转发表，其中存储真实的MAC地址 1.9 网络构成要素 设备 协议层 作用 中继器 物理层 物理层面延长网络，负责信号的调整与放大不能在传输速度不同的媒介之间转发 网桥（2层交换机） 数据链路层 能够识别数据链路层中的数据帧，并临时存储于内存，再重新生成信号作为全新的帧转发给相连的另一个网段。因此可以连接传输速率不同的数据链路，且不限制连接网段的个数。网桥可以根据FCS数据位进行数据校验抛弃错误数据网桥根据物理地址进行处理，包括MAC地址、硬件地址、物理地址和适配器地址，即网络上针对NIC分配的具体地址自学式网桥：保存曾经通过自己转发的所有数据帧的MAC地址 路由器（3层交换机） 网络层 根据IP地址进行处理连接两个网络，转发分组报文，分担网络负荷 4-7层交换机 传输层至应用层 分析收发数据，进行特定处理，如负载均衡 网关 传输层到应用层 数据的转换与转发，不同协议间的翻译如代理服务器、防火墙 传输速率：单位bps，单位时间内传输的数据量多少，又称为带宽 吞吐量：主机之间的实际传输速率，单位与带宽相同，与带宽、CPU处理能力、网络拥堵程度、报文中数据字段份额均有关 应用协议 URI：Uniform Resource Identifier，用于表示资源，不局限于表示互联网资源，作为所有资源的标识码，可以用在除www之外的其他应用协议中 URL：Uniform Resource Locator，用于表示资源的具体位置，是URI的一种形式，专用于www URN：Uniform Resource Name，统一资源名称，如邮箱 URL是一个狭义的概念，URI是一个广义的概念，目前RFC文档已经转而使用URI 表示层：HTML、JPEG、GIF、ASCII、ASCII、MIME等 应用层：FTP、HTTP、WWW、TELNET、SNMP等 MIME：Multipurpose Internet Mail Extensions，广泛用于互联网并极大扩展了数据格式 SDN：软件定义网络，简介 "},"TCPIP/第二章TCPIP基础知识.html":{"url":"TCPIP/第二章TCPIP基础知识.html","title":"第二章TCPIP基础知识","keywords":"","body":"TCP/IP基础知识 2.3 基础知识 传输协议：TCP、UDP 网际协议：IP、ICMP、ARP 路由控制协议：RIP、OSPF、BGP 应用协议：HTTP、SMTP、FTP、TELNET、SNMP Internet：网际网 The Internet：互联网 2.4 TCP/IP协议分层模型 物理层 数据链路层 网络层 网络层使用IP协议，基于IP地址转发分包数据，连接互联网的所有主机和路由器都必须实现IP功能。 IP IP协议使用IP地址作为主机的标识，将数据包跨越网络传递到接收端 IP协议中隐含数据链路层功能，通过IP协议，相互通信的主机之间不论经过怎样的底层数据链路都能实现通信 IP协议是不可靠传输协议，不具有重发机制，即使分组数据包传输失败也不会重发 ICMP 用于当IP数据包无法到达对端地址时给发送端一个异常通知，也被用于诊断网络的健康状况（ping） ARP 从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议 传输层 传输层主要功能为实现应用程序之间的通信，计算机内部，不同应用程序占用不同的端口号，传输层根据端口号进行区分 TCP 面向有连接的传输层协议，保证两端通信主机之间的通信可达。能够正确处理丢包、乱序等情况，可以有效利用带宽，缓解网络拥堵 但是为了保证可靠性，造成了网络流量的浪费，定义了大量复杂规则，不利于部分情况下的使用 UDP 面向无连接的传输层协议，不关注对方是否真正收到数据，常应用与分组数据较少或多播、广播以及视频通信等多媒体领域 应用层 HTTP：HyperText Transfer Protocol，应用层协议 HTML：HyperText Markup Language，表示层协议 2.5 TCP/IP通信示例 2.5.1 数据包首部 数据报由首部加上层数据组成。 每个分层中都会对所发送的数据附加一个首部，首部中包含了该层的必要信息。下一层丛上一层接收到的包全部被认为是本层的数据 包：所有的数据都可以用包来称呼 帧：数据链路层中包的单位 数据报：IP和UDP等网络层以上分层中包的单位 段：TCP数据流中的信息 消息：应用协议中数据的单位 2.5.2 发送数据包 应用程序将数据交给TCP层 TCP模块处理：根据应用层指示，负责建立连接、发送数据以及断开连接 在应用层数据前端增加TCP首部，其中包括源端口号和目标端口号（TCP层使用端口号区分应用）、序号（当前发送数据在发送端整体数据中的序列号）和校验和（用于判断数据是否被损坏），再将整个包交给IP层 IP模块处理 在TCP首部前端增加IP首部，其中包含接收端IP地址以及发送端IP地址。紧跟IP首部的数据用于标志后面数据使用了TCP还是UDP协议，之后将整个包交给数据链路层 数据链路层处理 数据链路层在接收到的数据之前加上以太网首部，其中包含接收端和发送端的MAC地址以及标志以太网类型的以太网数据协议。 以太网数据报 将通过物理层传输给接收端。发送处理中将进行FCS计算，添加到包的最后，用于判断数据包是否被破坏 2.5.3 分组数据包 每个包首部都至少会包含两个信息：一个是发送端与接收端的地址，一个是上一层的协议类型 2.5.4 数据包接收处理 包的接收程序是发送程序的逆序过程 特点在于会从包首部中取出地址检查是否与自己的地址相匹配，如果匹配，则接收数据并查找上一层的协议，然后将其交给相应的程序处理 "},"TCPIP/第三章数据链路.html":{"url":"TCPIP/第三章数据链路.html","title":"第三章数据链路","keywords":"","body":"数据链路 着重介绍TCP/IP中的具体数据链路，以太网、无线局域网、PPP 3.1 数据链路的作用 数据链路层协议定义了通过通信媒介互联的设备之间传输的规范 数据链路层主要功能为在互连同一种数据链路的节点之间进行包的传递 数据链路的段是指一个被分割的网络，但是从不同的视角观察，分割标准不同。 从物理层角度，一条网线即为一个段 从网络层角度，通过中继器可以将物理层上处于不同段的网络相连接，组成一个段 网络拓扑即为网络的连接和构成形态，包括总线型、星型、环型、网状型等。拓扑不仅用于直观的配线方式，也用于逻辑上网络的组成结构，二者有时可能不一致。 3.2 网络链路相关技术 3.2.1 MAC地址 MAC地址用于识别数据链路层中互联的节点，任何一个网卡的MAC地址都是唯一的，网卡的MAC地址直接烧入ROM中 MAC地址长48比特，即48位，6个字节 第1位：单播地址（0），多播地址（1） 第2位：全局地址（0），本地地址（1） 第3-24位：厂商识别码，IEEE管理，各厂商不重复 第25-48位：厂商内部识别码，厂商各产品不重复 3.2.2 共享介质网络 从通信介质的使用方式上，网络可以分为共享介质型和非共享介质型 共享介质型网络由多个设备共享一个通信介质，由于设备之间使用同一个载波信道进行发送和接收，所以基本上采用半双工通信，需要对介质进行访问控制。访问控制方式有争用方式与令牌传递方式。 争用方式 不同节点争夺获取数据传输权利，也称载波监听多路访问CSMA。网络中各个节点采用先到先得的方式占用信道发送数据，如果多个节点同时发送帧，则会产生冲突现象。导致网络拥堵性能下降。 后来部分以太网采用CSMA/CD，即每个节点提前检查冲突，一旦发生冲突，尽早释放信道 令牌传递方式 沿着令牌环发送一种叫做令牌的特殊报文，只有获得令牌的节点才能发送数据。 优点： 不会产生冲突 每个节点都有通过平等循环获得令牌的机会 故即使网络拥堵也不会造成性能下降，但是可能会降低网络利用率，为此衍生了多种令牌使用方式尽可能提高网络利用率。 令牌环网中，当目标节点接收到数据后，会设置数据的‘已接收数据’标志位，然后沿着环继续转发下去。当数据帧回到发送源后会被丢弃，然后令牌沿着环传递给下一个节点。 3.2.3 非共享介质网络 非共享介质网络是指不共享介质，是对介质采取专用的一种传输控制方式。 此情况下，每个节点直连交换机，由交换机负责转发数据帧。由于发送端与接收端不共享通信介质，所以可以采用全双工通信，并且不会产生冲突。 非共享介质网络的核心为交换机，可以利用其高级特性构建虚拟局域网（VLAN）、进行流量控制等 3.2.4 根据MAC地址转发 共享介质网络规模扩大，性能会明显下降，需要使用交换集线器，也称为以太网交换机，将非共享介质网络中使用的交换机应用在以太网中。 以太网交换机是持有多个端口的网桥，其会参考转发表，根据每个数据帧的目标MAC地址决定从哪个网络端口发送数据。 转发表可以根据交换机自学生成 数据链路层每个通过点在接收到包时，会将包的源MAC地址和接收该地址发送数据包的接口作为对应关系记录到转发表中，此时即可获知该MAC地址与该端口相连。故以该MAC地址作为目标地址的包，经由该接口送出即可。 当数据帧的目标MAC地址不确定端口时，交换机会向所有的端口发送数据帧 MAC地址没有层次性，当设备数量增多，转发表也会随之变大，检索转发表的时间也会变长。故当连接多个终端，建议将整个网络分为多个数据链路，使用类似于IP地址一样对地址进行分层管理 交换机转发方式： 存储转发：检查以太网数据帧末尾的FCS位后再进行转发，避免转发错误帧 直通转发：只需要得知目标地址即可开始转发，优势在于延迟较短，但是具有发送错误帧的可能性 3.2.5 环路检测技术 通过网桥连接网络，如果网络中存在环路，最坏的情况下数据帧会在环路中持续转发，当这种数据帧积累较多时会导致网络瘫痪。所以需要解决网络的环路问题。 解决环路问题有生成树与源路由两种方式。网桥具有此功能后，只要搭建合适环路，就可以分散网络流量，绕行故障路由，提高容灾能力。 生成树协议STP 每个网桥必须在每1-10秒内相互交换BPDU包(Bridge Protocol Data Unit)，从而判断哪些端口使用哪些端口不使用，以便消除环路。一旦发生故障，则自动切换通信线路，利用那些没有被使用的端口继续进行传输。 BPDU是运行STP的交换机之间交换的消息帧，其中包含了STP所需的路径和优先级信息。网桥会为每个端口存储其收到的最佳BPDU，当有其他BPDU到达交换机端口时，会判断其是否比原来的好，如果好则替换掉原有值。 RSTP：快速生成树协议，STP协议发生故障时切换较慢，RSTP可以更快的收敛网络 源路由法 源路由法中判断发送数据的源地址是通过哪个网桥进行传输，将该网桥信息写入数据帧的RIF(Routing Information Field)字段中。网桥根据RIF信息发送帧给目标地址。 故即使网桥中出现环路，数据帧也不会被重复转发，但是要求发送端本山具备源路由功能 3.2.6 VLAN 网桥按照其端口区分了多个网段，通过网段可以对广播数据的传播范围进行限制，减少网络负载提高安全性 VLAN指无需更改网络拓补结构，通过网桥的的网段划分，修改网络结构，即可切断不同VLAN之间的通信，过滤多余的包 但是异构的两个网段之间想要实现通信，需要利用具有路由功能的交换机或在各段之间通过路由器连接才能实现 3.3 以太网 3.3.2 以太网分类 传输速度相同情况下，可以使用中继器或集线器连接不同的传输介质 传输速度不同情况下，必须采用允许变更速度的设备如网桥、以太网交换机或路由器连接不同传输介质 计算机内部采用二进制，但是以太网的传输速率采用十进制 以太网规定了通信电缆的类型 3.3.4 以太网帧格式 前导码：长度8字节，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志 前导码的末尾是两个比特的SFD，值为11，SFD之后是以太网的本体 以太网帧本体 目标MAC地址：6字节 源MAC地址：6字节 上层协议类型：2字节 数据：46-1500字节 FCS校验位：4字节，检查帧是否有所损坏 接收端会对整个帧进行相同的运算，如果得出的FCS与以太网帧中的FCS相同，则说明接收到的帧没有差错 IEEE802.3 Ethernet 和一般的以太网的帧在首部上稍有区别，在上层协议类型的位置有一定不同 数据链路层可以细分为两层： 介质访问控制层：根据不同数据链路所特有的首部信息进行控制 逻辑链路控制层：根据不同数据链路所共有的首部信息进行控制 3.4 无线通信 3.4.1 无线通信的种类 短距离无线 无线PAN（802.15）：蓝牙，频率2.4GHz，通信终端最多允许八台设备 无线LAN（802.11）：wifi 无线MAN（802.16）：WIMAX 无线RAN 无线WAN：手机通信，3G、4G、LTE等 3.4.2 802.11 IEEE802.11定义了无线LAN协议中物理层与数据链路层的一部分，是所有IEEE802.11相关协议的基础 MAC层中物理地址与以太网相似，均使用MAC地址 介质访问控制使用CSMA/CA，其与CSMA/CD相似 物理层上使用电磁波或红外线进行通信 IEEE802.11协议族 IEEE802.11b与IEEE802.11g 物理层使用2.4GHz频段，最大传输速度分别可以达到11Mbps和54Mbps。不过其使用频段与微波炉使用频段相同，容易受到干扰 IEEE802.11a 物理层使用5GHz频段，最大传输速度54Mbp，不易受到干扰。 其与IEEE802.11b/g存在一定兼容性问题 IEEE802.11n 在IEEE802.11g和IEEE802.11a的基础上，采用同步多条天线的MIMO技术，实现高速无线通信。 物理层使用2.4GHz与5GHz，当不受其他2.4G频段系统干扰时，可以达到以上协议的数倍带宽40MHz，最大传输速度150Mbps IEEE802.11i 使用增强型的加密技术 3.5 PPP 3.5.1 PPP定义 即Point-to-Point，点对点协议，一对一连接计算机的协议，位于数据链路层 以太网和FDDI不仅与数据链路层有关，也与物理层有关，以太网需要使用同轴电缆或双绞线电缆，可以决定其中的0/1该被解释为何种电子信号 PPP是纯粹的数据链路层协议，与物理层无关，可以搭配各种各样的物理层 当前实现互联网介入的主要方式 ADSL PPPoE：PPP over Ethernet，在以太网的数据中加入PPP帧进行传输 3.5.2 LCP与NCP 开始进行数据传输前，需要先建立一个PPP级的连接 PPP的主要功能包括两个协议： LCP：Link Control Protocol，不依赖上层 LCP主要负责建立和断开连接、设置最大接收单元、设置验证协议（PAP或CHAP）以及设置是否进行通信质量的监控 NCP：Network Control Protocol，依赖上层。如果上层为IP，则NCP也称为IPCP IPCP负责IP地址设置以及是否进行TCP/IP首部压缩等设置 通过PPP连接时，通常需要进行用户名和密码的验证，并且对通信两端进行双方向验证。验证协议有PAP和CHAP PAP：通过两次握手进行验证，其中密码明文传输，安全性不高 CHAP：使用一次性密码OTP，有效防止窃听，建立连接后定期密码交换，检验对端是否被中途替换 3.5.3 PPP帧格式 PPP协议基于HDLC协议，二者在帧格式方面十分相似 在每个帧的前后加上8位01111110的标志码区分帧，两个标志码之间不允许出现连续6个以上的1 在发送帧时，当出现连续5个1时后面必须插入一个0，在接收帧时，当收到连续5个1且后面跟着的是0，就必须删除0 使用标志码区分帧的启示与终止 上述工作和FCS的计算都会交由计算机CPU处理，故PPP的使用会为计算机带来大量负荷 3.5.4 PPPoE 有些互联网接入商利用PPPoE提供PPP功能，通信线路由以太网模拟，服务由PPP提供 PPP帧作为以太网的数据传输，PPP首部在PPP帧的最前端 3.6 其他数据链路 以太网、无线通信、PPP 3.6.1 ATM ATM(Asynchronous Transfer Mode)是以信元（5字节首部，48字节数据）为单位进行传输数据链路，特点为线路占用时间短，高效传输大容量数据 特点： ATM是一种面向连接的数据链路，需要在通信传输前设置通信线路。 ATM允许同时与多个对端建立通信连接 ATM中增加了限制带宽的细分功能 ATM没有类似于以太网中的介质访问控制，允许在任何时候发送任何数据，容易诱发网络拥堵甚至网络进入收敛状态，因此ATM中需要限制带宽 网络收敛状态：网络十分拥堵时，路由器或交换机无法完成包的处理，从而丢弃这些包的一种状态 传输模式 ATM采用异步传输模式，在TDM的基础上进行扩展，不使用固定时隙，按照包到达的顺序进行传输，使用5字节首部标识具体的通信类型，其中包含相应识别码，识别码是在直连的两个ATM交换机之间有效。 ATM信元传输所占时隙不固定，一个帧所占的时隙数也不固定，时隙之间不要求连续，故可以有效避免TDM带来的空闲时隙问题，提高线路利用率。 不过额外使用首部增加了网络开销，也在一定程度上降低了通信速度 ATM交换机仅进行信元转发 与ATM交换机相连的超出ATM网络的其他设备进行信元的拼接，恢复其原来的数据包 ATM与上层协议 ATM一个信元只能发送固定48字节数据，传输上层数据是需要进行分割传输。而IP首部和TCP首部均为20字节，此时需要用到AAL(ATM Adapter Layer)以适配上层协议，在上层为IP时，叫做AAL5 由于整个IP包被分割为多个ATM信元，一个信元丢失就会导致整个IP包被损坏，从而导致所有信元被丢弃重传，从而诱发网络收敛。故ATM网络在构建时，必须保证终端的带宽合计小于主干网的带宽，并且信元不易丢失。 3.6.3 FDDI 分布式光纤数据接口，早期为使用光纤和双绞线实现100Mpbs传输速率而使用的数据链路，随着高速LAN的使用，逐渐被抛弃 3.6.4 HDMI 高清晰度多媒体接口，通过一根缆线实现图像和声音等数字信号的高品质传输。目前也可以传输以太网帧 3.7 公共网络 3.7.1 模拟电话线路 利用固定电话线路进行通信，其中的音频带宽用于拨号上网，已逐渐被淘汰 3.7.3 ADSL 对模拟电话线路进行拓展，通过调制将电话音频信号与数据传输信号隔离，避免产生干扰，类似的通信方式统称XDSL 3.7.4 FTTH Fiber To The Home，光纤到户，通过ONH将计算机与光纤相连，ONH负责光信号与电信号的转换，实现稳定高速上网 Fiber To The Building Fiber To The Curb 3.7.7 VPN VPN虚拟专用网络用于连接距离较远的地域 IP-VPN 在IP层上建立VPN 在IP层使用MPLS(多协议标签交换技)构建VPN服务，MPLS在IP包中附加一个叫做标签的信息进行传输控制，每个用户标签信息不同，在经过MPLS时即可判断出目的地址 广域以太网 在数据链路层建立VPN 在作为数据链路层的以太网上利用VLAN虚拟局域网实现VPN，但是由于使用数据链路层技术，可能会导致一些不必要的信息传输，需要谨慎使用 3.7.8 公共无线LAN 总结 第三章主要介绍了数据链路层的内容，主要内容包括 MAC地址的划分 共享介质网络与非共享介质网络下不同线路资源使用方式 交换机的自学原理，转发表的生成 以太网，数据链路层+物理层，以太网帧格式，前导码，MAC地址，协议类型，数据，FCS 无线通信 PPP点对点协议，数据链路层协议，连接与断开，身份验证，PPP帧 其他数据链路层 "},"TCPIP/第四章IP协议.html":{"url":"TCPIP/第四章IP协议.html","title":"第四章IP协议","keywords":"","body":"IP协议 IP协议位于网路层，主要负责将数据包发送给最终的目标计算机 4.1 IP即网际协议 IP，包括IPv4与IPv6，位于网络层 网络层主要作用为实现终端节点之间的通信，也称为点对点通信 数据链路层主要作用是在互连同一种数据链路的节点之间进行包传递，当跨域多种数据链路时，就需要借助网络层，网络层可以跨域不同的数据链路 网络层与数据链路层关系： 数据链路层提供直接连接的两个设备之间的通信能力 网络层提供在没有直接连接的两个网络之间进行通信传输 4.2 IP基础知识 IP层分为三大模块：IP寻址、路由、IP分包与组包 IP地址属于网络层地址 MAC地址是用来表示同一个链路中不同计算机的一种标识码 IP地址是用于在连接到网路中的所有主机中识别出进行通信的目标地址，所有主机和路由器都必须设定自己的IP地址，无论其与那种数据链路相连，IP地址形式均保持不变 无需连接到网络层的设备不需要设置IP地址，如网桥、交换集线器（以太网交换机）等物理层或数据链路层数据包转发设备 4.2.2 路由控制 路由控制是指将分组数据发送到最终目标地址的功能 跳是指网络中的一个区间，一跳是指利用数据链路层一下分层的功能传输数据帧的一个区间。以太网使用MAC地址传输数据帧，一跳指从源MAC地址到目标MAC地址之间传输帧的区间 多跳路由：多跳路由是指主机或路由器在转发IP数据包时只指定下一个路由器或主机，而不是将所有通路全部指定出来。每个区间在转发IP数据包时，均会指定下一跳的操作，直至包到达最终目标地址 路由控制表：路由控制表决定IP数据下一步应该发送给哪个路由器，IP包根据这个路由表在各个数据链路上传输 4.2.3 数据链路的抽象化 IP是实现多种数据链路之间通信的协议，不同数据链路各有特点。 IP协议可以对数据链路层进行抽象化，使得上层协议忽略底层网路构造的细节 4.2.4 IP的无连接性 IP是面向无连接的，不需要建立与对端目标地址之间的连接，需要发送数据时，立刻就会发送出去。IP层提供尽力服务，不做收到与否的验证 无连接优点：简化 + 提速 面向连接相对复杂，管理连接比较繁琐，每次通信前都需要建立连接，降低处理速度。需要面向连接服务时，可以委托上一层提供 为了提高可靠性，上一层的TCP采用面向连接的处理方式。TCP负责保证对端主机确实收到数据，进行数据查收的验证 IP与TCP分离的必要性：简化协议实现，明确每种协议作用与责任，同时有利于之后的扩展与优化 4.3 IP地址的基础知识 IP地址是TCP/IP通信的基石 4.3.1 IP地址定义 IPv4地址为32位，为方便表示，将其每8位位为一组，分割为4组，使用十进制标识，以.隔开 每台主机上的每块网卡都配置了相应的IP地址，通常一块网卡只设置一个IP地址，路由器需要配置两个以上的网卡，故需要设置两个以上的IP地址 IP地址由网络标识和主机标识两部分组成 网络标识(网络地址)：网络标识在数据链路的每个段配置不同的值，相互连接的每个段网络地址不重复，同一个段内相连的主机网络地址相同 主机标识(主机地址)：主机标识不允许在同一个网段中重复出现 4.3.3 IP地址分类 A类地址 A类地址是首位以0开头的地址 第1位到第8位是它的网络地址，后24位是主机地址，一个网段可以容纳2^24-2台主机 B类地址 B类地址是前两位是10的地址 第1位到第16位是它的网络地址，后16位是主机地址，一个网段可以容纳2^16-2台主机 C类地址 C类地址是前三位是110的地址 第1位到第24位是它的网络地址，后8位是主机地址，一个网段可以容纳2^8-2(254)台主机 D类地址 D类地址是前四位是1110的地址 第1位到第32位是它的网络地址，D类地址没有主机标识，常被用于多播 NOTE 主机标识不可全部为0或全部为1，全部为0表示对应的网络地址或IP地址不可获知，全部为1的主机地址常作为广播地址。因此每种地址的主机地址数量计算时都要减去这两种情况 4.3.4 广播地址 广播地址用于同一个链路中相互连接的主机之间发送数据包。 将IP地址中主机地址部分全部置为1即为广播地址 广播分为本地广播和直接广播 本地广播：在本网络内的广播称为本地广播，路由器会屏蔽本地广播包，不会向外部网络链路转发 直接广播：不同网络间的广播称为直接广播，可以向别的网络发送该网络内的广播包，实现对该网络所有主机的广播 直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发 4.3.5 IP多播 多播用于将包发送给特定组内的所有主机，直接使用IP协议，不存在可靠传输 多播技术出现前，通常使用广播方式实现此功能，然后在主机的IP层上判断是否需要接收数据，造成流量浪费 多播优点： 提高效率：只向网络传递一个多播数据包，路由器将复制该数据包并将其传递到多个主机，减少发送端工作 可以穿透路由：广播不能穿透路由，只能在同一个网络中使用 不浪费过多流量：只针对必要的主机组发送数据包 多播使用D类地址，除固定前四位外，剩下28位是多播的组编号。224.0.0.0~224.0.0.255，这是为路由协议和其它用途保留的地址，在同一个链路内使用，路由器并不转发属于此范围的IP包 使用多播时需要将路由器与主机加入到一定的IP组中，详见相关文档 4.3.6 子网掩码 使用子网+子网掩码的方式，将原来A类、B类或C类地址中主机地址部分用作子网地址，可以将原网络分为多个物理网络，实现更小粒度划分 IP地址使用子网掩码，可以自由的定位自身的网络标识长度，不再受制于网络类型 子网掩码也是32位，对应IP地址网络标识部分全部为1，对应IP地址主机标识部分全部为0 子网掩码的两种表示方式： 172.20.100.52 255.255.255.192 172.20.100.52/26 4.3.7 CIDR与VLSM CIDR：采用任意长度分地割IP址的网络标识与主机标识，有效利用IPv4地址 使用CIDR后，再采用子网掩码的形式，可以将两个不同的IP划分到同一个网络下。 子网掩码最初为网络内部固定长度，为了更高效使用IP地址，需要子网掩码可以根据网络内主机数量可以进行调整，即可变长子网掩码VLSM CIDR与VLSM相对缓解了IP地址不够的问题，但是绝对数量不足的问题需要使用IPv6的方式进行解决。 4.3.8 全局地址与私有地址 起初，互联网上的任意一台主机或路由器都必须由一个唯一的IP地址，IP地址出现冲突时，发送端无法判断将数据包发送给哪个地址，并且会带来IP地址不足的问题 但是独立网络中的设备只要在网络中地址唯一即可，无需全网络地址唯一，可以不用考虑互联网即可配置相应IP地址，即私有网络内的IP地址 私有网络IP地址范围： A类地址：10.0.0.0 ~ 10.255.255.255 /8 B类地址：172.16.0.0 ~ 172.31.255.255 /12 C类地址：192.168.0.0 ~ 192.168.255.255 /16 此范围内的IP地址属于私有IP，在此之外的IP地址属于全局IP，全局IP需要在整个互联网范围内保持唯一，私有IP只需要在同一个域中保持唯一 私有IP结合NAT技术，配置私有IP的主机可以通过路由器与配置全局地址的互联网主机实现通信 但是解决IP地址不足问题的根本途径还是IPv6 全局地址由专门机构进行管理，使用需要进行申请 4.4 路由控制 数据包通过路由控制表确定转发方向，发往目标地址 路由控制表形成方式： 静态路由控制：管理员手动设置路由控制表 动态路由控制：路由器与其他路由器互相交换信息时自动刷新，通过路由协议制作路由控制表，该协议不属于IP协议 4.4.1 IP地址与路由控制 IP地址的网络部分用于路由控制 路由控制表中记录着网络地址与下一跳应该发送到的的路由器地址。发送IP包过程为 确定IP包首部中的目标地址 从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器 如果存在多条相同的网络地址记录，以最吻合的，即相同位数最多的为准 其他概念： 默认路由： 一张路由表中包含所有网络和及其子网信息较为浪费，故采用默认路由的形式作为默认转发选项 默认路由一般标记为0.0.0.0/0或default，可以和任何IP地址进行匹配 主机路由： IP地址/32被称为主机路由，即IP地址的所有位都将参与路由，而不是基于该地址的网络地址部分 主机路由多用于不希望通过网络地址路由的情况 环回地址 环回地址是在同一台计算机的程序之间进行网络通信时所使用的一个默认地址，IP为127.0.0.1，主机名为localhost 使用这个IP或主机名时，数据包不会流向网络 4.4.2 路由控制表的聚合 利用网络地址的比特分布可以有效地进行分层配置，聚合路由表，减少路由表条目，提高性能 即在网络地址的基础上再进行聚合 4.5 IP分割处理与再构成处理 不同类型的数据链路，其使用目的不同，则最大传输单元MTU不同 IP层作为数据链路的上一层，不受限于不同数据链路MTU的大小 当IP数据包大小超过MTU时，路由器会对数据包进行分片发送，但是路由器只负责分片，不负责重组 经过分片之后的IP数据包在被重组时，只能在目标主机进行。这样是为了防止由路由器进行组装，可能在传输过程中面临重新分片的可能，避免给路由器带来多余负担，提高网络传输效率 IP首部中的片偏移字段标识分片后每个分片在用户数据中的相对位置和该分片之后是否还有后续其他分片。根据这个字段可以判断一个IP数据报是否分片以及当前分片在整个数据报中的相对位置 路径MTU的发现 传统分片机制不足： 加重路由器负荷：计算机网络物理传输速度不断上升，高速链路对路由器和计算机网络的处理速度提出了更高要求 网络安全要求：路由器需要进行的工作较多，如网络过滤，不希望其进行分片处理 网络利用率问题：一旦某一个分片丢失，整个IP包需要重新发送，降低网络利用率 路径MTU即为从发送端到接收端整个路径中不需要进行分片时的最大MTU，即路径中存在的所有数据链路中最小的MTU。 路径MTU发现要求发送主机按照路径MTU的大小将数据报拆分后进行发送，这样可以避免在中途的路由器上进行数据报分片，也可以在TCP层发送更大的包 UDP的路径MTU发现机制： 发送时IP首部分片标志位设置为不分片，途中遇到需要需要分片的情况，路由器会丢包，同时通过ICMP包向发送主机传递数据链路上的MTU值 UDP中没有重发机制，发送端收到的MTU值会在下一次发送给同样的目标主机时使用，在IP层进行分片处理，IP层不区分UDP首部与UDP数据 如此反复，直到数据包被发送到目标主机为止再也没有收到任何ICMP，就认为最后一次ICMP通知的MTU是一个合适的MTU 所有的分片到达目标主机后被重组，再传给UDP层 一个MTU值会最少缓存10分钟，超过十分钟会重新进行一次路径MTU发现 TCP的路径MTU发现机制： ICMP部分与UDP相同 发送端TCP层会根据路径MTU的大小计算出最大段长度，在TCP层完成分段，不会由IP层进行数据报的分片处理 接收端数据被原样发送给TCP层，不需要重组 4.6 IPv6 IPv6是为了根本解决IPv4地址耗尽问题而被标准化的网际协议 IPv6地址长128比特，一般写为8个16位字节 IPv6特点： IP地址的扩大与路由控制表的聚合 IP地址依然能够适应互联网分层构造，分配与其地址结构适应的IP地址，尽可能避免路由表膨胀 性能提升 包首部长度采用固定值，不再采用首部校验码，简化首部结构，减轻路由器负荷，路由器不再进行分片 支持即插即用 没有DHCP服务器也能够实现自动分配IP 采用认证与加密 多播、mobile IP成为扩展功能 4.6.3 IPv6的标记方法 为简化标记并区分IPv4，IPv6标识方法为： 将128位地址每16比特位一组，每组之间用:隔开，每组内部可以使用4个16进制数字表示 出现连续的0时可以将其省略，并使用::两个冒号隔开 但是每个IP地址中只允许出现一次两个连续的冒号 如1080:0:0:0:8:800:200C:417A可以简化为1080::8:800:200C:417A 4.6.4 IPv6的地址结构 IPv6类似于IPv4，使用IP地址的前几位标识IP地址的种类 全局单播地址，整个互联网中唯一，使用最为广泛 48位全局路由前缀 + 16位子网ID + 64位接口ID，即前64比特网络标识，后64比特主机标识。 通常接口ID中为64位MAC地址值，但是不希望MAC地址泄露时，此地址可以临时生成并定时更新 本地单播地址：在同一个数据链路中唯一的地址，用于不经过路由器，在同一个链路中的通信 1111 1110 10 + 54位的0 + 64位接口ID，即FE80::/10 通常接口ID中即为64位MAC地址 唯一本地地址：唯一本地地址是在不进行互联网通信或通过NAT或者网关（代理）联网时所使用的地址，通信时需要经过路由器 在限制型网络中，即不与互联网直接接入的私有网络，可以使用唯一本地地址。限制型网络与互联网通信时通常会通过NAT或者网关（代理）进行 该地址根据一定算法生成随机数并融合到地址中，可以自由使用，也称唯一单播地址， 1111 110 + L + 40位全局ID + 16位子网ID + 64位接口ID，L被置为1或0，即FC00::/7 多播地址：FF00::/8 环回地址：::1/128 在IPv6的环境下，可以同时将这些IP地址全都配置到同一个网卡NIC上，按需灵活使用 4.6.8 IPv6的分段处理 IPv6的分片处理只在发送端主机上进行，但是IPv6的最小MTU位1280字节 因此对于CPU或内存有一定限制的设备来说，可以不进行路径MTU发现，在发送IP包时直接按照1280字节为单位分片发出 4.7 IPv4首部 版本：长度4比特，标识IP首部的版本号。 IPv4版本号为4，IPv6版本号为6，中间存在跳跃。原因在于互联网中有众多机构致力于IP协议的完善，为了让这些机构能够验证其相应的协议，会为其顺序分配具体的版本。经过反复试验之后，从众多版本中挑选出最佳产物进行标准化。IP version 6正是经历了这些过程才成为IPv4的下一代IP协议 首部长度：长度4比特，表明首部大小，单位为4字节 区分服务：TOS(Type Of Service)，长度8比特，表明服务质量 但是由于实现TOS控制技术复杂性较高，目前没有被投入使用。而是将TOS分为DSCP与ECN两部分 DSCP：Differential Services Codepoint，查分服务代码点，简称DiffServ，用于进行质量控制。 TOS的第0-5位为DSCP，其中前三位可以提供八种类型的质量控制级别，值越大优先级越高。后面全部置为0 ECN：Explicit Congestion Notification，显式拥塞报告，用于报告网络拥塞情况 TOS的第6位ECT用于通知上层TCP层是否处理ECN，第7位当网络拥塞时，路由器将此为置为1 总长度：标识IP首部与数据部分合起来的总字节数 长16比特，故IP包最大长度为2^16-1=65535字节，目前还没有能够传输最大长度IP包的数据链路存在。 但是由于IP可以分片处理，在IP包的上一层看来，可以忽略这一点，无论底层采用何种数据链路，都认为能够以IP的最大包长传输数据。 标识：用于分片重组，标识不同分片 同一个分片的标识值相同，不同分片标识值不同。通常每发送一个IP包，标识值逐渐递增 即使ID值相同，如果目标地址、源地址或者协议不同，也会被认为是不同的分片 标志：表示包被分片的相关信息，每一位有其具体含义 片偏移：13比特，表示被分片的每一个分段相对于原始数据的位置，单位为8字节，最大可表示8*2^13 生存时间TTL：表示数据包可以中转多少个路由器。每经过一个路由器TTL减1，直至变成0后被丢弃 协议：标识IP包传输层的上层协议编号 首部校验和：只校验数据报的首部，不校验数据部分 源地址：32比特，发送端IP地址 目标地址：32比特，接收端IP地址 可选项 填充：首部长度不是32比特整数倍时，向该字段填充0，调整为32比特整数倍 数据 4.8 IPv6首部 版本 通信量类：相当于区分服务（Type Of Service）字段 流标号：准备用于服务质量 有效载荷长度：不包括首部，只表示数据部分的长度。当有可选项时，包含可选项数据的所有长度就是有效载荷长度 下一个首部：通常表示IP的上一层协议类型，当存在扩展首部时，表示第一个扩展首部的协议类型 跳数限制：Hop Limit，跳数限制，同生存时间TTL，每经过一个路由器就减1，减到0丢弃数据 源地址 目标地址 IPv6扩展首部 IPv6首部长度固定，通过扩展首部的形式进行功能扩展，其位置介于IPv6首部与TCP/UDP首部之间，长度任意。扩展首部当中还可以包含扩展首部协议与下一个扩展首部字段。 IPv6首部中没有标识以及标志字段，在需要对IP数据包分片时，可以使用扩展首部 总结 第四章主要讲述了IP层的内容，重点内容包括： 网络层功能，与数据链路层的区别，自身特性 IPv4地址与分类 子网掩码，路由控制表与路由聚合 TCP与UDP的路径MTU，IPv4与IPv6分段区别，IPv6只能发送端分 IPv6地址结构 IPv4与IPv6首部 "},"TCPIP/第五章IP协议相关技术.html":{"url":"TCPIP/第五章IP协议相关技术.html","title":"第五章IP协议相关技术","keywords":"","body":"IP协议相关技术 实际通信中，仅依靠IP协议远远不够，还需要众多支持IP的相关技术才能实现最终通信 5.2 DNS IP地址不便于记忆，平时不会直接使用IP地址，而是使用一个字符串，DNS将字符串转化为IP地址 TCP/IP刚开始为每个主机指定唯一的主机识别码，进行网络通信时直接使用主机名即可，系统会将主机名转换为具体的IP地址。主机名与IP地址的对应关系存储在hosts数据库文件中，网络中每接入一台主机就需要更新hosts文件 但是随着网络规模扩大，使用单一hosts文件可行性太低 5.2.2 DNS的产生 DNS（Domain Name System）系统主机管理机构负责维护一个主机名与IP地址之间对应关系的数据库 用户输入主机名时，DNS会自动在数据库中检索定位其对应的IP地址。并且需要并更主机名与IP地址对应关系时，在组织机构内部进行处理即可，可以在一个较小的范围内对网络进行管理 5.2.3 域名的构成 顶级域名：包括国别顶级域名、通用顶级域名等 分层域名：在顶级域名下，可以有多层域名 域名服务器：管理域名的主机和相应的软件，根部所设置的DNS叫做根域名服务器 每层域名服务器都注册着再往下一层域名服务器的IP地址，如果下面没有其他分层，就可以自由指定主机名称或子网名称 当需要修改域名服务器的名称或IP地址时，需要在其上层的域名服务器中进行追加或修改 域名和域名服务器需要分层设置，如果服务器宕机，则无法进行DNS查询，故为了提高容灾能力，一般会设置多个域名服务器 所有域名服务器都必须注册根域名服务器的IP地址，DNS进行IP检索时，是从根域名服务器开始的 解析器：进行DNS查询的主机和软件叫做解析器，其必须至少注册一个以上域名服务器的IP地址，才可以进行DNS查询 5.2.4 DNS查询过程 客户端检查hosts文件是否有网址映射关系 若无，查找本地DNS解析器缓存 若无，向DNS服务器查询域名的IP地址 在接收查询请求的DNS服务器中，会先在自己的数据库中查找 如果查询到，直接返回 如果未查询到，则向上一层根域名服务器进行查询。根域名服务器返回其存储的主域名的DNS服务器IP地址。 DNS服务器再向步骤2中拿到的DNS服务器请求域名的IP地址。 重复步骤2与步骤3，直至拿到域名的IP地址，返回给客户端 客户端与对应域名开始通信 解析器和DNS服务器将最新了解到的信息暂时保存在缓存中，缓存时间由TTL参数指定，减少每次查询的性能消耗 所有DNS请求和回答报文使用UDP数据报经过端口53发送 DNS系统如同互联网中的分布式数据库，其中也存储了一些别的信息 5.3 ARP 在数据链路层通信需要了解每一个IP地址所对应的MAC地址 ARP是一种解决地址问题的协议，以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。 ARP只适用于IPv4，IPv6下使用ICMPv6代替ARP发送邻居探索消息 5.3.2 ARP工作机制 ARP借助ARP请求与ARP响应两种类型的包确定MAC地址 源主机广播发送ARP请求包，请求目标主机MAC地址 目标主机收到后，将自身MAC地址通过ARP响应返回给源主机 为节约网络流量，可以将收到的MAC地址与IP地址对应关系缓存在ARP缓存表中，下次无需再次发送ARP请求。每次执行ARP时，对应的缓存内容会被清除。在接收ARP请求的主机上，也可以对源主机的MAC地址和IP地址进行缓存，提高效率。缓存具有一定期限，超过期限后，缓存内容将被清除 ARP可以动态进行MAC地址解析，在TCP/IP网络中只要有IP地址即可，无需事先知道MAC地址 5.3.3 IP地址与MAC地址关系 IP地址与MAC地址相互依托 MAC地址实现数据包在数据链路层的传输，数据链路层使用MAC地址进行传输，MAC地址决定数据包的下一个路由器 IP地址实现数据包在网络层的传输，网络层可以根据IP地址的网络标识进行层层分组，建立集约机制，减轻交换机压力，实现网络正常通信 5.3.4 其他概念 RARP：反向ARP，即根据MAC地址定位IP地址，需要先架设一台RARP服务器，注册相应MAC地址的IP地址，再于对应MAC地址的设备进行通信，通知其IP地址。 代理ARP：ARP包会被路由器隔离，采用代理ARP的路由器可以将ARP请求转发给临近的网段。由此，两个以上网段的节点可以像在同一个网段中一样通信 5.4 ICMP 5.4.1 辅助IP的ICMP ICMP用于确认网络是否正常工作，以及遇到异常时进行问题诊断 ICMP主要功能： 确认IP包是否成功送达目标地址 通知在发送过程中IP包被废弃的具体原因，如路径MTU发现 改善网络设置等 ICMP消息分类： 通知出错原因的错误消息 用于诊断的查询消息 5.4.2 主要的ICMP消息 ICMP目标不可达消息 IP路由器无法将IP数据包发送给目标地址时，会向发送端主机返回一个目标不可达的ICMP消息，并在其中显示不可达的具体原因 ICMP重定向消息 如果路由器发现发送端主机使用次优路径发送数据，其会返回一个ICMP重定向消息，其中包含了最优的路由信息和源数据。下次发送时，发送端主机会直接使用最优路径 但是但部分情况下，此类消息会引发网络问题，一般不使用 ICMP超时信息 TTL为0时，数据包会被丢弃，路由器向发送端返回ICMP超时消息，通知数据包被丢弃 使用TTL可以控制数据包到达的范围，避免IP包无休止的在网络上被转发 traceroute应用利用ICMP超时消息，将TTL从1开始递增，获取发送端到接收端整个路径上的路由器IP地址 ICMP回送消息 用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息。 可以像对端主机发送回送请求的消息ICMP Echo Request Message，也可以接受对端主机发送回来的回送应答消息ICMP Echo Reply Message，ping命令即通过此种方式实现 ICMP原点抑制消息：一般不使用 ICMP路由器探索消息 用于发现与自己相连网络中的路由器，主机发出ICMP路由器请求，路由器返回ICMP路由器公告消息 ICMP地址掩码消息 主要用于主机或路由器想要了解子网掩码的情况，向目标主机发出请求消息，接受应答消息 5.4.4 ICMPv6 ICMP在IPv4中仅为辅助作用，但在IPv6中地位更加重要，起到决定性作用 IPv6中的ICMP分为错误消息（0-127）和信息消息（128-255）两种 邻居探索协议 邻居请求消息用于查询IP地址与MAC地址的对应关系，并由邻居宣告地址得知MAC地址，使用IPv6的多播地址实现传输 IPv6实现了即插即用，所以没有DHCP服务器也可以实现IP地址的自动获取。 没有路由器的网路，使用MAC地址作为链路本地单播地址 有路由器的网路，从路由器获得IP地址的前面部分，后面64位有MAC地址进行生成。关于路由器的部分可以使用路由器请求消息与路由器宣告消息进行设置 5.5 DHCP DHCP：只要接入网络，即可自动获取TCP/IP通信所必需的设置，即插即用 5.5.2 工作机制 主机的DHCP客户端向DHCP服务器请求设置IP地址和子网掩码（广播） DHCP服务器通知可以使用的网络设置（单播） 客户端通知想要使用得到的网络设置（广播） 服务器允许使用（单播） IP地址的分配方式有随机挑选与根据MAC地址固定匹配两种，可以同时使用 DHCP故障会导致整个网段无法进行TCP/IP通信，因此一般架设两台及以上服务器 5.5.3 DHCP中继代理 DHCP中继代理使用一个DHCP服务器，然后在每个网段上设置其DHCP中继代理，可以在服务器上注册每个网段IP地址的分配范围，进行统一管理与维护 DHCP客户端向DHCP中继代理发送DHCP请求包（广播） DHCP中继代理将广播包发给DHCP服务器（单播） 服务器向DHCP中继代理返回应答（单播） DHCP中继代理将应答转发给客户端（单播） 从而实现不在一个数据链路上也可以统一分配和管理IP地址 5.6 NAT NAT(Network Address Translator)是指在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术 NART：在NAT的基础上附加端口号的转换 NAT实质上是为解决IPv4地址枯竭开发的技术，但是IPv6中为了提高网络安全也用到NAT，IPv4与IPv6通信使用NAT-PT 5.6.2 NAT工作机制 私有地址向互联网发送消息时，途中的NAT服务器会自动生成一张转换地址表，将私有地址转换为全局IP地址，然后再发送数据。发过来NAT服务器收到数据包后会根据表中映射关系，将目的地址转换为私有地址，再转发数据包 当私有网络中多台主机同时与外部通信时，仅依靠地址转换无法起到节约全局IP地址的作用，此时需要使用NART技术，将私有地址+端口号一起转换为全局IP地址+端口号，依靠端口号的不同进行发送方的区分。 转换表在NAT服务器上自动生成 5.6.4 NAT的潜在问题 NAT依赖于自己的转换表，其限制在于： 无法从NAT外部向内部服务器建立连接 生成转换表需要开销 NAT异常重启时所有TCP连接会被重置 主要问题为无法从外接向服务器内部建立连接，目前解决办法为通信前，服务器内侧的主机先向服务器发送一个虚拟网络包，使得服务器自动生成转换表，称为NAT穿越 NAT技术需要维护转发表，使得IP协议变为面向连接，并且涉及到更改端口号的操作，违反了传统网络分层模型，破坏了各层独立原则。 5.7 IP隧道 IP隧道即在网络层首部后继续追加网络层首部的通信方式。 其应用场景之一即IPv6网络之间通过支持IPv4的网络进行通信，将IPv6的包统合为一个数据，再为其追加一个IPv4的首部之后转发给目标地址 其他应用场景： Mobile IP 多播包的转播 IPv4网络中传送IPv6的包 IPv6的网络中传送IPv4的包 数据链路帧通过IP层发送 5.8 其他IP相关技术 5.8.1 IP多播相关技术 通过MLD(Multicast Listener Discovery)确认接收端是否存在，是IPv4中IGMP和IPv6中ICMPv6的重要功能之一，没有接收端，发送多播消息会造成网络流量的浪费。 MLD两大作用： 向路由器表明想要接收多播消息，并通知想接受多播的地址 向交换集线器通知想要接收多播的地址，此功能也称为IGMP(MLD)探听。避免交换集线器将多播帧发送到所有端口上，不再向毫无关系的端口发送多播帧，降低网络负荷。 5.8.2 IP任播 IP任播是指为提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的方法。如DNS根域名服务器 IP任播无法保证每次都能与相同的主机建立连接，对TCP或UDP中要求连续多个包通信的情况存在问题 5.8.3 通信质量控制 IP协议是尽力而为，没有通信质量保证。网络发生拥塞（收敛）时，路由器和集线器队列溢出，会出现大量丢包影响性能。 因此提出在尽力而为前提下，对于特殊的包进行优先处理，以保证通信质量。 IntServ：针对特定应用间通信进行质量控制的一种机制。特定应用是指源IP地址，目标IP地址，源端口，目标端口和协议号完全一致。协议复杂，实用性差 DiffServ：针对特定网络进行粗粒度的通信质量控制，实用性较好 5.8.4 显式拥塞通知 网络发生拥塞时，发送主机应该减少数据报的发送量。TCP协议中的拥塞控制是通过数据包的实际损坏判断是否发生拥塞，无法在损坏前减少数据包发送量，因此增加IP层显式拥塞控制ENC。 ENC机制： 拥塞检查在网络层进行，在发送包的IP首部中记录路由器是否遇到拥塞 拥塞通知在传输层进行，在返回包的TCP首部中通知是否发生拥塞，避免遇到不支持拥塞控制的协议，如UDP 两层的互相协助实现拥塞通知功能。发送包为发送端向目标主机发送的数据，返回包为目标主机发送的应答回执 5.8.5 Mobile IP Mobile IP使主机所连接的子网IP发生变化时，主机IP地址保持不变。 否则一旦移动设备连接的子网发生变化，其IP地址也会变化，则无法通过TCP继续通信，UDP协议也存在类似问题 Mobile IP的本质是采用IP隧道的方式进行通信 移动设备通过外部代理发送转发数据包向归属代理通知自己的位置 之后归属代理收到发送给移动主机IP的数据包后使用IP隧道发送给外部代理 外部代理收到数据包后转发给移动设备 由此移动设备可以不改变IP地址进行通信，有点类似于移动通信网络。 目前问题在Mobile IPv6中得到相应解决： 没有外部代理无法通信：外部代理由市县Mobile IPv6移动主机自己承担 IP包成三角形路径转发效率不高：可以不经由鬼事代理进行直接通信 部分网络会丢弃发送端IP地址不在自己域的数据包(当移动设备在外部代理下时，移动设备IP不在外部代理域下)：IPv6首部源地址赋予移动地址，防止防火墙丢弃 总结 第五章主要讲述了围绕IP的其他协议，包括有： DNS，域名的构成，DNS解析过程 ARP，ARP工作机制，IP地址与MAC地址关系，代理ARP ICMP，ICMP功能，ICMP消息种类，ICMPv6邻居探索消息 DHCP，DHCP工作原理，DHCP中继代理统一管理 NAT，所解决问题，NART，潜在问题 IP隧道与Mobile IP 显式拥塞控制，多播任播 "},"TCPIP/第六章TCP与UDP.html":{"url":"TCPIP/第六章TCP与UDP.html","title":"第六章TCP与UDP","keywords":"","body":"TCP与UDP 6.1 传输层的作用 TCP面向连接，可靠地流协议，提供可靠地通信传输 UDP面向无连接的，提供不可靠的通信传输，常用于广播和细节控制交给应用的服务 传输层使用端口号区分应用层中所要进行处理的具体程序 在传统的C/S框架下，服务端会启动一个超级守护进程，即互联网守护进程inetd，该进程在接收到客户端请求后会根据目标端口号fork新的进程并转换为所需的各个服务端程序，也称守护进程 TCP与UDP需要根据需求进行相应选择 套接字Socket 操作系统提供了很多类库，即API，应用在使用TCP或UDP通信时，会广泛使用到套接字(socket)的API，使用其可以设置对端的IP地址、端口号，并实现数据的发送与接收 6.2 端口号 MAC地址用于识别同一个数据链路中不同的主机 IP地址用于识别TCP/IP网络中互连的主机和路由器 端口号用于识别同一台计算机中进行通信的不同应用程序，也称程序地址 通过源IP地址、目标IP地址、源端口号、目标端口号与协议号五个信息识别是否为一个通信，只要其中某一项不同，则被认为是其他通信 6.2.4 端口号如何确定 标准既定的端口号 每一个应用程序都有其指定的端口号，但是不可以随意使用任何一个端口号，每个端口号都有其对应的使用目的 知名端口号：部分广泛使用的应用协议所使用的端口号是固定的，其被称为知名端口号，应用程序应该避免使用知名端口号进行既定目的之外的通信，避免冲突。 时序分配法 也称动态分配法，客户端应用程序不用设置端口号，交由操作系统分配。操作系统为每个应用程序分配互不冲突的端口号，对端口号进行动态管理。 6.2.5 端口号与协议 端口号由其使用的传输层协议决定，不同的传输层协议可以使用相同的端口号，但是使用目的各不相同，端口号上的处理是根据每个传输协议的不同进行处理的，互相独立不受影响。 知名端口号与传输层协议并无关系，只要端口号一致都将分配同一种程序进行处理。如TCP和UDP都使用53号端口进行DNS服务 6.3 UDP UDP：User Datagram Protocol，不提供复杂的控制机制，利用IP提供面向无连接通信服务，并且将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。 UDP无法进行拥塞控制，无法处理丢包，不负责重发，包顺序错乱无法纠正，只提供传输层协议最基本功能，细节控制需要交由应用程序。 UDP面向无连接，可以随时发送数据，简单高效，应用场景： 包总量较少的通信（DNS、SNMP等） 视频、音频等即时通信 限定于LAN等特定网络中的应用通信 广播通信（广播、多播） 6.4 TCP TCP：充分实现数据传输时各种控制功能，面向有连接协议，只在确认通信对端存在时才发送数据，避免流量浪费，在面向无连接的IP层基础上实现高可靠通信 连接：各种设备、线路、网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信线路。一旦建立连接，应用程序间只使用该虚拟线路进行通信，不必考虑IP网络可能存在的各种问题。 TCP负责控制连接的建立、断开、保持等管理工作 TCP可靠传输依赖于：检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制 6.4.2 序列号与确认应答 发送端主机数据到达接收端，接收端主机会返回一个ACK确认应答。 如果发送端收到确认应答，说明数据成功到达对端 如果一段时间没有收到，可能发生数据丢包或ACK丢包，发送端都会认为数据已丢失，进行重发 6.4.3 重发超时时间 重发超时指重发数据前，等待确认应答到来的特定时间间隔。超过此时间仍未收到确认应答，发送端将进行数据重发 考虑到数据包经过不同线路耗时不同，TCP在每次发包时都会计算往返时间RTT及其偏差，将往返时间和偏差相加，重发超时略大于此值，以节省网络流量 Unix和window系统中，超时均已0.5s作为单位进行控制，最初的超时时间一般设置为6s 若重发后仍未收到ACK，则再次进行发送，此时等待确认应答的时间将指数倍延长。到达一定重发次数后，如果仍没有任何确认应答返回，会判断网络或对端主机异常，强制关闭连接，并通知应用通信异常强行终止 6.4.4 连接管理 TCP面向有连接，需要在数据通信开始之前先做好通信两端之间的准备工作。 TCP中一个连接的建立需要经过三次握手，断开需要经过四次分手 三次握手与四次分手如下图示 6.4.5 TCP以段为单位发送数据 MSS：最大消息长度，TCP在建立连接时，同时确定发送数据包的单位。在后续传送中，以MSS的大小对数据分割发送 理想的情况是最大消息长度正好是IP中不会被分片处理的最大数据长度 以太网最大传输单元MTU为1500字节，对应MSS为1460（除去IP首部20字节和TCP首部20字节） 确定方法： 在三次握手建立连接的SYN包相互通知对方网络接口的MSS值 在两者中选一个较小的作为MSS的值，发送数据 6.4.6 利用窗口控制提高速度 解决问题：每发送一个段进行一次确认应答，然后再发送下一个段，包往返时间影响通信性能 引入窗口：使用滑动窗口的方式并行发送 窗口大小：无需等待确认应答而可以继续发送数据的最大值 窗口内的数据即使没有收到确认应答也可以被发送出去 需要缓存窗口内数据，直到收到它们的确认应答，否则需要对丢包数据进行重传 数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可从缓存区清除 收到确认应答后，将窗口滑动到确认应答中的序列号位置 滑动窗口与重发机制 窗口在一定程度较大时，即使有少部分的确认应答丢失也不会进行数据重发。可以通过下一个确认应答进行确认 接收端在没有收到自己所期望序号的数据时，会对之前收到的数据进行确认应答，发送端则一旦收到某个确认应答后，又连续3次收到同样的确认应答，则认为该数据段已经丢失，需要进行重发 6.4.8 流控制 让发送端根据接收端的实际能力控制发送的数据量 接收端主机向发送端主机通知自己可以接收数据的大小（接收窗口：rwnd，receiver window，能保存数据的缓冲区的大小），发送端发送不超过这个限度的数据。该大小限度即窗口大小 在每个TCP连接的整个生命周期中，每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速 由于TCP首部中表示Window Size的字段只有16位，因此按照协议，能表示的最大窗口大小是2^16-1=65535Bytes(64Kb)。采用TCP窗口缩放（TCP Window Scaling），窗口的最大值可以扩展到1G字节 当接收端将发送窗口限制为0时，发送端会暂停发送数据 之后收到接收端发送的发送窗口更新通知才会继续发送数据。 为避免发送窗口更新通知丢失导致无法继续通信，期间发送端主机会不时向接收端发送窗口探测请求，获取最新窗口大小信息 6.4.9 拥塞控制 问题：在网络出现拥堵时，如果两个主机开始通信，突然发送大量数据，可能导致网络瘫痪 流量控制虽然可以防止发送端向接收端过多发送数据，但是在连接建立之初，无法预知可用带宽，因此需要估算机制，并根据网络中不断变化的条件而动态改变速度 解决：慢启动、拥塞预防、快速重发和快速恢复 慢启动 通信开始通过慢启动算法得出的数值，对发送数据量进行控制，过程如下图 拥塞窗口cwnd(congestion window)：发送端对从客户端接收确认（ACK）之前可以发送数据量的限制 慢启动将此值初始化为1个数据段，即1MSS 之后每收到一个ACK，拥塞窗口值加1 客户端和服务器之间最大可以传输（未经ACK确认的）数据量取rwnd和cwnd变量中的最小值，即wnd = min(rwnd, cwnd*MSS) cwnd不会在发送端与接收端直接交换 2013年，RFC 6928将cwnd提高到10个TCP段（IW10） 拥塞窗口可以有效减少通信开始时连续发包导致的网络拥塞，避免网络拥塞情况的发送 TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小，AI保证效率，MD保证收敛，保证TCP流之间的公平性。一般情况下，窗口越大，越会形成高吞吐量的通信 拥塞避免 问题：随着包的往返，拥塞窗口会以指数函数的形式增长，为避免此类情况引入慢启动阈值(ssthresh)。TCP开始通信时，没有设置慢启动阈值 当拥塞窗口的值超过慢启动阈值时，每收到一次确认应答，只允许以下面这种比例放大拥塞窗口，SMSS为一个数据段字节数，故cwnd由指数增长变为线性增长： new_cwnd = old_cwnd + SMSS*SMSS/old_cwnd 快速重传 超时丢包时 将ssthresh设置为当时拥塞窗口一半的大小 cwnd重新置为1MSS 重新进入慢启动过程 重复确认应答：要求至少3次的确认应答数据到达对方主机后才会触发，相比使用超时重发机制网络拥堵要轻一些 将ssthresh设置为当时拥塞窗口一半的大小 将cwnd窗口设置为ssthresh+3个数据段大小 重新进入拥塞避免阶段，该过程属于快速恢复。 快速恢复 当收到3个重复ACK时进入此阶段 快速恢复阶段算法TCP Reno 将cwnd窗口设置为ssthresh+3个数据段大小，重传丢失的分组。 加3原因为收到3个重复ACK，表明有3个“老”的数据包离开了网络 再收到重复的ACK时，拥塞窗口增加1 当收到一个新的数据包ACK时，把cwnd设置为第一步中的ssthresh的值。 原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，退出快速回复状态，重新进入拥塞避免状态 存在问题：只针对当前窗口一个包需要重传，无法应对多个包重传情况 改进：使用NewReno NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量 参见博客 队首阻塞 TCP是按序交付和可靠交付的，如果有分组没能到达接收端，后续分组必须保存在接收端的TCP缓存区，等待丢失分组重发并到达。 这一切发生在TCP层，应用程序对TCP重发和缓存区中排序是分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能通过套接字读数据时感觉到延迟交付。这种效应称为TCP的队首（HOL，Head of Line）阻塞。 因此，对于无需按序交付数据或能够处理分组丢失的应用程序，以及对延迟或抖动要求很高的应用程序，最好选择UDP等协议 优化建议 大部分情况下，TCP的瓶颈都是延迟，而非带宽 因此针对服务器配置： 升级内核版本 增加初始拥塞窗口，使得能够在刚开始就能传输较多的数据量 慢启动重启，在连接空闲时禁用慢启动可以改善瞬时发送数据的长 TCP 连接的性能 窗口缩放：使高延迟连接达到更好的吞吐量 TCP快速打开(TCP Fast Open，TFO)：允许在第一个SYN中发送应用程序数据 对于应用程序： 减少不必要的发送资源 缩短传输距离，使用CDN等技术 重用TCP连接 6.4.10 提高网络利用率的规范 Nagle算法 发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是在以下任一种条件下才发送数据，否则就暂停等待一段时间后再进行数据发送 已发送的数据都已经收到确认应答时 可以发送最大段长度（MSS）的数据时 缺点在于可能会造成数据延迟，一般关闭 延迟确认应答 问题：如果接收主机每次都立刻回复确认应答，因为刚接收完数据，缓冲区已满，可能会返回一个较小的窗口。接收端接收到小窗口通知后，会以它为上限发送数据，从而降低网络利用率 因此受到数据后并不立即返回确认应答，而是延迟一段时间 在没有收到2x最大段长度的数据为止不做确认应答（根据操作系统的不同，有时也不论数据大小，只要收到两个包就即刻返回确认应答的情况） 其他情况下，最大延迟0.5s发送确认应答（很多操作系统设置为0.2s） 不用为每一个数据段都进行一次确认应答。TCP采用滑动窗口，通常可以应答少一些。通常每两个数据段返回一次确认应答 捎带应答 根据应用层协议，发送的消息到达对端并处理后，会返回一个回执。 在此类通信中，TCP的确认应答和回执数据可以通过一个包发送，减少收发数据量 需要启动延迟确认应答。以等待应用处理生成返回数据 6.5 其他传输层协议 UDP-Lite 解决的问题： UDP中，如果校验和出错，则收到的包全部丢弃，有些应用不希望这样 不能关闭校验和，否则如果是端口号或IP地址被破坏后果严重 机制： UDP-Lite提供与UDP几乎相同的功能 自定决定计算校验和的范围 SCTP SCTP，Stream Control Transmission Protocol，流传输控制协议，提供数据到达与否相关可靠性检查的传输层协议 以消息为单位收发 TCP中接收端并不知道发送端应用所决定的消息大小，SCTP可以 支持多重宿主，指同一台主机具备多种网络的接口 比如以太网与无线LAN的各自NIC不同，会获取到不同的IP地址。如果以太网切换到无线，TCP会被断开 但SCTP可以同时管理多个IP使其同时进行通信，因此能够保持通信不中断 支持多数据流通信 TCP中建立多个连接才能通信，SCTP中一个连接就可以 可以定义信息的生存期限 超过生存期限的信息，不会被重发 SCTP主要用于进行通信的应用之间发送众多较小消息的情况。较小的应用消息被称作数据块（Chunk），多个数据块组成一个数据包 DCCP DCCP，Datagram Congestion Control Protocol，数据报拥塞控制协议，辅助UDP实现拥塞控制 同UDP，不能提供发送数据的可靠性传输 面向连接，具备建立连接与断开连接的处理。在建立和断开连接上具有可靠性 能够根据网络拥堵情况进行拥塞控制。可选择两种方式： 类似TCP（TCP-Like）拥塞控制 TCP友好升级控制（TCP-Friendly Rate Control） 为实现拥塞控制，接收端收到包后返回确认应答（ACK）。该确认应答将被用于判断重发与否 6.6 UDP首部格式 6.7 TCP首部格式 在TCP与UDP计算校验和时，会使用伪首部 原因：识别一个通信有五个要素，但是在传输层只知道源端口与目标端口，其他三项在IP首部中，故在验证五项识别码时需要引入伪首部 此外IPv6中IP首部没有检验和字段，TCP或UDP通过伪首部，实现对五项识别码的校验，在IP层并不可靠的情况下提供可靠地通信传输 总结 传输层作用，端口号作用与划分 UDP面向无连接的协议 TCP面向连接的协议 连接的管理，三次握手四次分手，同时告知对方MSS值 滑动窗口机制与流控制rwnd 拥塞控制，慢启动、快回落，cwnd计算，滑动窗口取cwnd与rwnd最小值 超时重发与重复确认应答两种情况的不同 针对滑动窗口机制的优化：增大初始cwnd，慢启动重启，窗口缩放等 其他传输层协议 UDP-Lite自主设置校验和区间 SCTP支持多重宿主 DCCP辅助UDP实现拥塞控制 首部格式，伪首部，五项识别码的使用 "},"TCPIP/第七章路由协议.html":{"url":"TCPIP/第七章路由协议.html","title":"第七章路由协议","keywords":"","body":"路由协议 路由控制协议根据路由控制表转发数据包 静态路由：事先设置好路由器和主机并将路由信息固定 动态路由：让路由协议在运行过程中自动地设置路由控制信息 两种方式各有利弊，可以结合使用 7.2 路由控制范围 EGP（Exterior Gateway Protocol)：外部网关协议，在区域网络之间（或ISP之间）进行路由选择，使用BGP协议 IGP（Interior Gateway Protocol）：内部网关协议，在区域网络内部（或ISP内部）进行主机识别，使用RIP、RIP2、OSPF等协议 7.3 路由算法 7.3.1 距离向量算法 根据距离（代价）和方向决定目标网络或目标主机未知的一种方法，代价相当于要经过的路由器个数 路由器之间可以交换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表，每个路由器的路由控制表不同 处理简单 网络拓扑复杂时耗时较大 容易发生路由循环 7.3.2 链路状态算法 路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。该方法中，每个路由器必须保持同样的信息才能进行正确的路由选择 网络结构复杂时也可以快速达到稳定状态 管理和处理信息需要高速CPU和大量内存 7.4 RIP Routing Information Protocol，距离向量型的一种路由协议，广泛用于LAN 7.4.1 广播路由控制信息 将路由控制信息定期（30秒一次）向全网广播 如果没有收到路由控制信息，等待5次，第6次仍未收到，连接就会被断开 7.4.2 基于距离向量确定路由 距离（Metrics，单位：跳数，即所经过的路由器的个数），RIP希望尽可能少通过路由器将数据包转发到目标IP地址 根据距离向量生成距离向量表 抽出较小的路由生成最终的路由控制表，如果距离相同，通常是随机选择或者轮换使用 7.4.3 使用子网掩码时的RIP处理 从接口IP地址对应分类得出网络地址后，与根据路由控制信息流过此路由器的包中的IP地址对应的分类得出的网络地址进行比较 如果两者网络地址相同，以接口的网络地址为准 如果两者网络地址不同，以IP地址的分类所确定的网络地址为准 7.4.4 RIP中路由变更时的处理 基本行为： 将自己所知道的路由信息定期广播 一旦认为网络被断开，数据无法流过，其他路由器由此可知网络已断开 存在问题：无限计数，RIP信息在两个路由器之间互相转发，跳数不断增加 初步解决方式： 最长距离不超过16，设置最大跳数 水平分割：规定路由器不再把收到的路由信息原路返回给发送端 但是无法解决存在环路的情况，因此进一步采用毒性逆转和触发更新，在链路不通时可以迅速传递消息使路由消息收敛 毒性逆转：当网络中发生链路断开时，将无法发送通信的消息传播出去，即发送一个距离为16的消息 触发更新：当路由信息发生变化时，不等待30s，而是立即发送出去 7.4.5 RIP2 与RIP工作机制基本相同 使用多播：减少网络流量，缩小对无关主机影响 支持子网掩码，RIP只支持分类地址 路由选择域：在同一个网络中使用逻辑上独立的多个RIP 外部路由标志：通常用于把从BGP等获得的路由控制信息通过RIP传入自治系统 身份验证秘钥 但是在一个复杂的网络环境中，路由信息达到稳定状态需要一定时间，解决此问题必须明确掌握网络结构，为此可以采用OSPF 7.5 OSPF Open Shortest Path First，链路状态型路由协议 采用链路状态类型，可解决环路问题 支持子网掩码 引入路由选择域，减少协议间不必要交换 7.5.1 OSPF是链路状态型路由协议 路由器之间交换链路状态信息生成网络拓扑信息 根据拓扑信息生成路由控制表 OSPF对每条链路赋予一个权重，始终选择权重最小的路径作为最终路由。 RIP选择跳数最小的路径 OSPF选择总代价最小的链路 7.5.2 基础知识 OSPF中，不需要在所有的相邻路由器之间进行控制信息的交换，而是确定一个指定路由器，以他为中心交换路由信息即可 OSPF中有五种类型的包： 问候HELLO，用于确认是否连接 数据库描述Database Description，互相发送路由摘要信息和版本信息 链路状态请求Link State Request，如果版本比较老，首先发送该包请求路由控制信息 链路状态更新Link State Update，然后使用更新包接收路由状态消息 链路状态确认Link State ACK Package，最后使用确认宝通知大家本地已经接收到路由控制信息 相比RIP只有路由控制信息包，可以大大减少网络流量，迅速更新路由信息 7.5.3 工作原理 LAN中每十秒发送一个HELLO包，允许空等三次，第四次仍无反馈认为连接断开，进行连接断开或恢复连接操作 由于链路状态发生变化，会发送链路状态更新包通知其他路由器网络状态变化。 其中包含两类消息： 网络LSA：以网络为中心，表明网络与哪些路由器相连 路由器LSA：以路由器为中心，表明路由器与哪些网络相连 根据上面消息生成链路状态数据库 根据数据库，使用最短路径优先算法生成路由控制表 缺点：网络规模扩大时，算法处理的时间较长，对CPU和内存消耗较大 7.5.4 区域分层 问题：网络规模扩大，链路状态数据库过大，路由控制信息计算困难 解决办法：引入区域概念，将一个自治系统划分为多个区域与一个主干区域，其他区域都与主干区域相连 每个区域内的路由器都持有本区域网络拓扑的数据库 区域外的路径信息，只能从区域边界路由器获知距离 7.6 BGP Border Gateway Protocol，边界网关协议用于连接不同组织机构，路径向量型协议，属于EGP 组织会为每个BGP分配一个16比特的AS编号，BGP根据这个编号进行路由控制 BGP使用AS作为度量标准，一般选择AS数最少的路径，但也要遵循各个AS之间签约的细节进行更细粒度的路由选择 在AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径的所有AS编号 路由控制是跨越整个互联网的分布式系统 7.7 MPLS Multi Protocol Label Switching，多协议标记交换技术 路由交换：基于IP地址中最长匹配原则进行转发 标记交换：对每个IP包设定一个标记，然后根据这个标记进行转发 基本操作 LSR：Label Switching Router，标记交换路由器，实现MPLS功能的路由器 LER：Label Edage Router，标记边缘路由器，与外部网络连接的那部分LSR，进行追加标记和删除标记 MPLS中目标地址和数据包都要通过由标记决定的同一个路径，即标记交换路径LSP，Label Swithing Path 优点： 转发速度快，使用固定长度的标记信息，处理简单 利用标记生成虚拟路径，IP协议利用其可以提供质量控制、带宽保证和VPN等功能 总结 AS，EGP与IGP，距离向量算法与链路状态算法 RIP，基于距离向量确定路由 选择跳数最小的路径 无法使用子网掩码，网络地址的确定 路径变更时处理，定期广播，无限计数，毒性逆转，水平分割 RIP2区别，使用多播，子网掩码，路由选择域 OSPF，基于链路状态确定路由 选择总代价最小的路径 五种包，减少网络流量 链路状态变化，更新链路状态数据库，最短路径算法生成路由转发表 区域分层，减少每个区域规模 BGP，边界网关协议，根据AS编号进行转发，选择AS最小的路径 MPLS，多协议标记交换技术 根据标记交换 速度快，生成虚拟路径，为IP协议提供质量保证 "},"nginx/":{"url":"nginx/","title":"nginx","keywords":"","body":"nginx data_structure nginx_config nginx平台初探 nginx语法简介 模块简介 核心功能模块 HTTP核心模块 HTTP功能模块 其他概念 Nginx开发从入门到精通 Nginx中文文档 NGINX官方文档 中文版官方文档 Nginx语法简介 markdown表情包 "},"nginx/data_structure.html":{"url":"nginx/data_structure.html","title":"data_structure","keywords":"","body":"基本数据结构 nginx中为了追求高效，实现了很多颇具特色的数据结构。 ngx_str_t 带长度的字符串结构 typedef struct { size_t len; u_char *data; } ngx_str_t; data为指针，指向字符串第一个字符 len为长度，表示字符串长度 nginx中字符串不以\\0结束 优点： 减少字符串长度的计算 减少不必要的内存分配与拷贝 request_line、uri、args等等，这些字符串的data部分，都是指向在接收数据时创建buffer所指向的内存中，uri，args就没有必要copy一份出来 缺点： 修改字符串时需要确认是否可以修改，修改后对其他引用是否会造成影响 nginx中glic部分函数的字符串参数是以\\0结尾的，传入str作为参数时需要做特殊处理 nginx字符串操作API： ngx_string(str) #define ngx_string(str) { sizeof(str) - 1, (u_char *) str } 将普通字符串构造为nginx字符串 ngx_null_string #define ngx_null_string { 0, NULL } 初始化字符串为空字符串，长度为0，data为NULL ngx_str_set(str, text) #define ngx_str_set(str, text) (str)->len = sizeof(text) - 1; (str)->data = (u_char *) text 设置nginx字符串str为text，text为常量字符串 ngx_str_set(str) #define ngx_str_null(str) (str)->len = 0; (str)->data = NULL 设置nginx字符串str为空串，长度为0，data为NULL note 由于c语言的特性，ngx_string与ngx_null_string只能用于定义时初始化，其他用法参照c语言语法 ngx_str_t str = ngx_string(\"hello world\"); ngx_str_t str1 = ngx_null_string; ngx_str_set与ngx_str_set实质为两条语句，单独使用时需要用花括号括起来 其他API： ngx_strlow(u_char *dst, u_char *src, size_t n) 将src的前n个字符转换为小写存入dst字符串中，src字符串不变动。需要保证dst指向的空间大于n ngx_strncmp(s1, s2, n) 区分大小写的字符串比较，只比较前n个字符 ngx_strcmp(s1, s2) 比较两个字符串整体 ngx_strcasecmp(u_char *s1, u_char *s2) 不区分大小写比较两个字符串 ngx_strncasecmp(u_char *s1, u_char *s2, size_t n) 不区分大小写比较两个字符串的前n个字符 字符串格式化三兄弟 u_char * ngx_cdecl ngx_sprintf(u_char *buf, const char *fmt, ...); u_char * ngx_cdecl ngx_snprintf(u_char *buf, size_t max, const char *fmt, ...); u_char * ngx_cdecl ngx_slprintf(u_char *buf, u_char *last, const char *fmt, ...); ngx_snprintf使用max参数指定buffer大小 ngx_slprintf使用last参数指定buffer大小 推荐使用ngx_snprintf和ngx_slprintf，避免缓冲区空间溢出 将ngx_str_t格式参数传给函数时，要传递指针类型的参数，使用转义符%v，否则会出错 ngx_str_t str = ngx_string(\"hello world\"); char buffer[1024]; ngx_snprintf(buffer, 1024, \"%V\", &str); // 注意，str取地址 ngx_pool_t ngx_pool_t数据结构提供一种资源管理机制，帮助管理一系列的资源，如内存、文件等，使得对这些资源的使用和释放统一进行，避免资源的错误释放 从一个ngx_pool_t对象上获取内存，当ngx_pool_t对象销毁时，由此分配出来的所有内存均被释放，资源的使用和释放统一进行 ngx_pool_t数据结构： typedef struct ngx_pool_s ngx_pool_t; struct ngx_pool_s { ngx_pool_data_t d; size_t max; ngx_pool_t *current; ngx_chain_t *chain; ngx_pool_large_t *large; ngx_pool_cleanup_t *cleanup; ngx_log_t *log; }; cleanup管理一个链表，其中每一项均为一个特殊的需要释放的资源 相关操作函数： ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log); 创建初始化大小为size的pool，log为后续在该pool上进行操作时输出日志的对象 size大小设置： size的大小必须小于等于NGX_MAX_ALLOC_FROM_POOL，且必须大于sizeof(ngx_pool_t) 空间大于NGX_MAX_ALLOC_FROM_POOL会造成浪费，大于该限制的空间 不会被用到 小于sizeof(ngx_pool_t)的值会造成程序崩溃，因为需要一定空间存放ngx_pool_t信息 void *ngx_palloc(ngx_pool_t *pool, size_t size) 从这个pool中分配一块为size大小的内存。注意，此函数分配的内存的起始地址按照NGX_ALIGNMENT进行了对齐。对齐操作会提高系统处理的速度，但会造成少量内存的浪费 void *ngx_pnalloc(ngx_pool_t *pool, size_t size) 从这个pool中分配一块为size大小的内存。但是此函数分配的内存并没有像上面的函数那样进行过对齐。 void *ngx_pcalloc(ngx_pool_t *pool, size_t size) 该函数也是分配size大小的内存，并且对分配的内存块进行了清零。内部实际上是转调用ngx_palloc实现的 void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment) 按照指定对齐大小alignment来申请一块大小为size的内存。此处获取的内存不管大小都将被置于大内存块链中管理 ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p) 对于被置于大块内存链，也就是被large字段管理的一列内存中的某块进行释放。此函数操作效率比较低 void ngx_destroy_pool(ngx_pool_t *pool) 释放pool中持有的所有内存，依次调用cleanup字段所管理的链表中每个元素的handler字段所指向的函数，来释放掉所有该pool管理的资源，并且把pool指向的ngx_pool_t也释放掉了，完全不可用了 void ngx_reset_pool(ngx_pool_t *pool) 该函数释放pool中所有大块内存链表上的内存，小块内存链上的内存块都修改为可用。但是不会去处理cleanup链表上的项目 ngx_array_t ngx_array_t为nginx中数组结构，大块连续内存，内部除了存储数据的内存外还包括一些其他相关描述信息 typedef struct ngx_array_s ngx_array_t; struct ngx_array_s { void *elts; ngx_uint_t nelts; size_t size; ngx_uint_t nalloc; ngx_pool_t *pool; }; elts：指向属鸡的数据存储区域 nelts：数据实际元素个数 size：数组单个元素大小 nalloc：数组的容量，不扩容前提下最多存储的元素个数。当nelts增长到nalloc时，数组大小会扩容到原来的2倍 实质为分配一块新的内存，新内存大小为原来的两倍，将原有数据拷贝到新内存中 pool：数组用来分配内存的内存池 其他方法： ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size) 创建一个新的数组对象并返回 p：数组分配内存使用的内存池 n：数组的初始容量大小，即在不扩容的情况下最多可以容纳的元素个数 size：单个元素的大小，单位为字节 void ngx_array_destroy(ngx_array_t *a) 销毁该数组对象，并释放其分配的内存回内存池 void *ngx_array_push(ngx_array_t *a) 在数组a上新追加一个元素，并返回指向新元素的指针。需要把返回的指针使用类型转换，转换为具体的类型，然后再给新元素本身或者是各字段（如果数组的元素是复杂类型）赋值 void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n) 在数组a上追加n个元素，并返回指向这些追加元素的首个元素的位置的指针 static ngx_inline ngx_int_t ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size) 如果一个数组对象是被分配在堆上的，那么当调用ngx_array_destroy销毁以后，如果想再次使用，就可以调用此函数。 如果一个数组对象是被分配在栈上的，那么就需要调用此函数，进行初始化的工作以后，才可以使用 由于使用ngx_palloc分配内存，数组在扩容时，旧的内存不会被释放，会造成内存的浪费 ngx_hash_t ngx_hash_t实现nginx自己的hash表，使用开链法解决冲突 ngx_hash_t实现特点： 不可以插入或者删除元素，只能进行一次初始化 ngx_hash_t中开链法的实现是开了一段连续的存储空间中，初始化时会进行预计算，节省内存使用 初始化： ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts); 存储hash表key的数组结构： typedef struct { ngx_str_t key; ngx_uint_t key_hash; void *value; } ngx_hash_key_t; 操作函数： void *ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len); 在hash里面查找key对应的value。实际上这里的key是对真正的key（也就是name）计算出的hash值。len是name的长度。查找成功返回指向value的指针，否则返回NULL 其他数据结构 ngx_hash_wildcard_t：处理带有通配符的域名匹配问题，可以匹配通配符在前或者在后的key ngx_hash_combined_t：组合型hash表，包含普通hash表、前向通配符hash表与后向通配符hash表 ngx_hash_keys_arrays_t：处理hash表的key值，便于构建hash表 ngx_chain_t：nginx的filter模块在处理从别的filter模块或者是handler模块传递过来的数据（实际上就是需要发送给客户端的http response）。这个传递过来的数据是以一个链表的形式(ngx_chain_t) ngx_buf_t：ngx_chain_t链表的每个节点的实际数据 ngx_list_t：list数据结构 特殊在于每个节点均为一个固定大小的数组。添加元素时，会在最尾部的节点的数组上添加元素。如果这个节点的数组存满了，就新增一个新的节点到list里面去 ngx_queue_t：双向链表 "},"nginx/nginx_config.html":{"url":"nginx/nginx_config.html","title":"nginx_config","keywords":"","body":"nginx配置系统 主文件 + 配置文件，主文件在任何情况下均被使用，文件位于nginx安装目录的conf目录下 #进行注释 指令概述 nginx.conf中包含若干配置项，配置项包括配置指令和配置参数两部分。配置指令中如果包含空格，需要使用引号括起来 指令参数 指令参数包含简单字符串与复杂配置块。 复杂配置块由大括号括起来，其中可以包含若干其他的配置指令 简单配置项：配置指令参数全部由简单字符串组成 error_page 500 502 503 504 /50x.html; 复杂配置项：指令参数中包含复杂配置块，一般简单字符串写在前面 location / { root /home/jizhao/nginx-book/build/html; index index.html index.htm; } 指令上下文 指令上下文即作用域，不同作用域包含一个或多个配置项 main：nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等 http：与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等 server：http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置 location：http服务中心，某些特定的URL对应的一系列配置项 mail：实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项 指令上下文中可能存在包含的情况，也能包含另一种类型的上下文多次。 简单的server配置项 server { listen 192.168.1.1:80; server_name example.org www.example.org; ... } server { listen 192.168.1.1:80 default_server; server_name example.net www.example.net; ... } server { listen 192.168.1.2:80 default_server; server_name example.com www.example.com; ... } 上例中，匹配顺序如下 根据server块中的目标ip地址与端口号进行匹配，选取命中的server块 在命中的server块中匹配目标server_name 可以为ip地址下不同的端口号指定其默认的server，当访问特定的ip+端口号时，如果没有匹配到对应的server，将交由指定的default_server进行处理 nginx的模块化体系结构 nginx内部结构：核心功能(nginx core) + 功能模块 nginx core：实现了底层的通讯协议，为其他模块和nginx进程构建了基本的运行时环境，并且构建了其他各模块的协作基础，提供了web服务器的基础功能、web服务反向代理功能、email服务反向代理功能 模块概述 nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理，每个模块实现特定的功能 特殊模块：http模块与mail模块。在nginx core之上实现了另外一层抽象，处理与HTTP协议和email相关协议（SMTP/POP3/IMAP）有关的事件，并且确保这些事件能被以正确的顺序调用其他的一些功能模块 模块分类 模块名称 功能 event module 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理 phase handler 此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容 output filter 响应内容输出，负责对输出的内容进行处理，可以对输出进行修改 upstream 实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端 load-balance 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器 nginx请求处理 nginx使用多进程模型对外提供服务，一个master进程和多个woker进程，master进程负责管理nginx本身和woker进程 所有的业务逻辑均在woker进程中处理，woker进程中有个无限循环函数ngx_worker_process_cycle()，不断处理接收到的请求并进行处理，直到nginx服务终止 ngx_worker_process_cycle()处理流程： 操作系统提供的机制（例如epoll, kqueue等）产生相关的事件 接收和处理这些事件，如是接受到数据，则产生更高层的request对象 处理request的header和body 产生响应，并发送回客户端 完成request的处理 重新初始化定时器及其他事件 请求的处理流程 HTTP Request的处理过程： 初始化HTTP Request，读取来自客户端的数据，生成Request对象，其中包含请求的所有信息 处理请求头 处理请求体 如果有的话，调用本次请求想关联的handler 依次调用各parse handler进行处理 nginx命令行参数 nginx自身命令 nginx大部分操作通过配置文件进行，仅保留较少的命令行参数 通过nginx -s signal可以控制nginx运行，signal可以为下列选项 stop：立即停止nginx运行 quit：等待worker进程处理完当前的request请求之后停止运行 reload：重新加载配置文件 master进程收到指令后，会检查新的配置文件语法有效性并且尝试应用配置文件。 如果新的配置文件可用，master进程会开启新的worker进程并且向旧进程发送shut down信号，否则master进程会回滚配置继续运行旧的进程 旧的进程接收到shut down信号会，在处理完当前的request请求后停止工作 reopen：重新开始记录日志文件 使用系统命令管理nginx 杀死nginx进程 kill -s QUIT pid，nginx的master进程pid通常保存在/usr/local/nginx/logs或者/var/run中 获取所有运行的nginx进程 ps -ax | grep nginx， "},"nginx/nginx平台初探.html":{"url":"nginx/nginx平台初探.html","title":"nginx平台初探","keywords":"","body":"初探nginx 特点：高性能，高并发，多进程，异步非阻塞 进程：系统进行资源分配和调度的一个独立单位，各进程互相独立 线程：进程下一个能够独立运行的独立单位，同一进程下的所有线程共享进程拥有的全部资源，线程可以创建和撤销另一个线程 nginx进程模型 nginx中的进程： master进程：用于管理worker进程，通过master进程操作nginx 多个worker进程：用于处理网络事件，各worker进程对等，同等竞争，互相独立 一个请求只可能完全在一个worker中处理，一个worker不可能处理其他进程的请求 worker的个数一般设置与CPU核数对应 使用命令行操作nginx流程： 启动新的nginx进程 解析命令行命令 向master进程发送信号 master操作worker进程 worker进程会抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接，进而进行处理 worker进程请求处理的accept_mutex惊群问题（nginx默认关闭accept_mutex会导致惊群）： 当一个新连接到达时 如果激活了accept_mutex，那么多个Worker将以串行方式来处理，其中有一个Worker会被唤醒，其他的Worker继续保持休眠状态 如果没有激活accept_mutex，那么所有的Worker都会被唤醒，不过只有一个Worker能获取新连接，其它的Worker会重新进入休眠状态 nginx事件处理 同步与异步，阻塞与非阻塞 apcache采用每个请求独占一个线程，处理过程中不同线程间切换 缺点：线程间上下文切换CPU开销较大，影响性能 nginx采用异步非阻塞的方式处理事件，不需要为每个事件创建专属线程，故不存在上下文切换 nginx中worker个数设置为CPU核数 避免太多worker竞争CPU资源，带来不必要的上下文切换 CPU亲缘性选项，将某个进程与CPU某个内核绑定，不会因为进程的切换导致cache的失效 web服务器的事件类型： 网络事件，处理办法如上述 信号，会中断程序当前执行，在改变状态后，继续执行 定时器，事件循环每执行一遍就检查一次定时器红黑树，找出其中所有超时的定时事件，一一执行 基本概念 connection connection是对tcp连接的封装，其中包括连接的socket、写事件和读事 connection作用： 处理http请求 作为邮件服务器 作为客户端请求其他sever数据 与任何后端服务打交道 nginx进程最大连接数 nofile，一个进程能够打开的listenfd最大数，每个socket连接会占用一个fd，fd用完后再创建socket会失败 worker_connections，每个进程支持的最大连接数 实际的最大连接数取nofile和worker_connections中的较小值 连接池 nginx通过连接池管理连接，其中保存的是一个worker_connections大小的一个ngx_connection_t结构的数组 nginx的free_connections中保存所有空闲的ngx_connection_t，每获取一个连接，就从空闲连接链表中获取一个，用完后，再放入空闲连接链表中 nginx最大连接数 普通情况下nginx最大连接数为worker_connections worker_processes 反向代理情况下最大连接数为worker_connections worker_processes/2 因为每个并发会占用两个连接，分别问与客户端的连接和与后端的连接 accept_mutex锁（惊群问题） worker纯粹采用竞争机制获取请求，会导致部分worker负担过重 nginx通过accept_mutex选项控制进程根据自身连接数目情况判断是否添加accept事件，与其他进程竞争获取accept_mutex锁，实现多进程之间连接的平衡 request HTTP请求结构：请求行 + 请求头 + body nginx中ngx_http_request_t数据结构是对一个http请求的封装，其中保存解析请求与输出响应相关的数据 nginx处理请求流程： 由ngx_http_init_request函数开始，设置请求读事件为ngx_http_process_request_line，请求行的处理使用该函数进行 请求行处理，通过ngx_http_read_request_header读取请求数据，调用ngx_http_parse_request_line解析请求行，整个请求行解析到的参数存储到ngx_http_request_t结构中 请求头处理，nginx会设置在ngx_http_process_request_headers中进行读取与解析，调用ngx_http_process_request_headers读取请求头，使用ngx_http_parse_header_line进行解析 解析到的所有请求头保存在ngx_http_request_t的链表结构headers_in中 请求头与body之间使用空行分隔，遇到两个回车换行符请求头解析结束 请求body处理，使用ngx_http_process_request处理请求 将读写事件处理函数设置为ngx_http_request_handler，在该函数内部再进行读写事件的区分 使用ngx_http_handler进行真正请求的处理，执行ngx_http_core_run_phases函数处理请求，产生数据生成响应 生成的所有响应头存放在ngx_http_request_t的链表结构headers_out中 note nginx会将整个请求头放在一个buffer中，如果这个buffer装不下，则会重新分配一个更大的buffer，两个buffer的大小通过client_header_buffer_size与large_client_header_buffers进行配置 为了保证请求头或请求行的完整性，一个完整的请求头或者请求行会被放置在一个连续的内存中，即一个buffer里面 如果请求行大于一个buffer大小，返回414错误 如果请求头大于一个buffer大小，返回400错误 !nginx请求处理流程 keepalive HTTP长连接和短连接本质上是TCP协议的长连接和短连接 长连接：需要提前确定每个请求体与响应体的长度，以便在一个连接上面执行多个请求，长连接可以减少socket的time-wait数量 请求body的长度通过请求头的content-legnth确定 响应body的长度确定与协议有关 HTTP1.0中，使用content-legnth指定body长度，如果没有content-length，客户端会一直接收数据，直到服务端主动断开连接 HTTP1.1中，有两种模式 chunked模式：如果响应头中的transfer-enconding为chunked传输，代表body为流式传输，每个传输块中均会标记当前块长度，不在需要指定body长度 非chunked模式：需要在header中指定content-length 如果非chunked同时没有content-legnth，客户端会一直接收数据，直到服务端主动断开连接 客户端请求头中connection为close表示客户端关闭长连接，为keep-alive表示打开长连接 如果请求头中没有connection字段，不同协议下默认值不同 HTTP1.0默认为close HTTP1.1默认为keep-alive 如果服务端决定打开keepalive，响应头中connection字段为keep-alive，否则为close pipe pipe：基于长连接的流处理 普通keepalive必须等待第一个请求的响应接收完全后才能发起第二个请求，pipeline机制不必等待降低两个响应间隔时间 nginx支持pipeline，但对多个请求依然采用串行处理的办法，利用pipeline减少等待第二个请求的请求头数据时间 处理办法为当处理前一个请求时，会将后续到达的请求也放在buffer中，之前的请求处理完后，会直接从buffer中读取数据，开始处理下一个请求 lingering_close lingering_close延迟关闭机制，nginx关闭连接是先关闭tcp连接的写，等待一段时间后再关闭连接的读 close系统调用时如果tcp write buffer中有内容则会向客户端发送RST报文丢弃write buffer中数据 延迟关闭防止在write()系统调用之后到close()系统调用执行之前tcp write buffer中的数据没有发送完毕，导致客户端接收不到相应数据 nginx配置指令的执行顺序 nginx请求处理阶段有11个，常见三个阶段按照执行顺序排列为rewrite、access、content rewrite阶段 单个请求的处理过程中，前一个阶段的配置指令会无条件的在后一个阶段配置指令之前执行，与书写顺序无关，分属两个不同处理阶段的配置指令之间不能穿插运行 同一个处理阶段中不同模块的配置指令，执行先后顺序视情况而定 对于第三方模块，ngx_array_var、set_by_lua等可以与ngx_rewrite模块配置指令混合执行，是因为其使用了特殊的第三方模块ngx_devel_kit 但是更多的第三方模块指令虽然也运行在rewrite阶段，但是其本身与其他模块是分开独立运行的，其执行顺序依赖于模块的加载顺序，所以对应指令的执行先后顺序一般是不确定的 access阶段 控制访问权限，可以使用ngx_access原生模块与ngx_lua模块中的access_by_lua指令，后者运行于access阶段的末尾，晚于access与deny指令，可以在access请求处理阶段插入lua代码 content阶段 此阶段用于生成内容并输出HTTP响应，运行于rewrite与access阶段之后 避免在同一个location中使用多个模块的content阶段指令 绝大多数 Nginx 模块在向 content 阶段注册配置指令时，本质上是在当前的 location 配置块中注册所谓的“内容处理程序”（content handler）。每一个 location 只能有一个“内容处理程序”。因此，当在 location 中同时使用多个模块的 content 阶段指令时，只有其中一个模块能成功注册“内容处理程序” nginx中proxy模块的proxy_pass 指令与ngx_echo模块的echo指令同属于content阶段，故不能够同时使用，此问题可以采用输出过滤器的方式避免，echo_before_body与echo_after_body指令执行于输出过滤器中，可以与proxy_pass同时使用 输出过滤器：nginx在输出响应体数据时，都会调用nginx的输出过滤器，echo、proxy_pass等指令均会调用，但是输出过滤器不属于任何一个请求阶段，其可以被很多指令调用 一个location中多次调用同一个模块中的指令视情况而定 echo指令可以被多次调用，但是content_by_lua 就不可以 如果location中没有使用content阶段指令，即没有内容处理程序，nginx会将当前请求的URI映射到文件系统的静态资源服务模块，其优先级分别为nginx_index、nginx_autoindex和nginx_static模块 nginx_index，作用于URI以/结尾的请求，其余请求忽略，同时将处理权移交给content阶段的下一个模块。 主要用于在root或alias配置下首页文件的获取，会将获取到的文件名添加到路径之后，请求路径将发生改变，此时将发生内部跳转，重新匹配新路径对应的location块 如果获取不到文件，则放弃处理权给content阶段的下一个模块 nginx_autoindex：找不到index指令对应的文件时，生成一个HTML，其中包含所有文件及子目录的连接 类似于index，作用于URI以/结尾的请求，其余请求忽略，同时将处理权移交给content阶段的下一个模块 nginx_static 实现静态文件服务功能，将真正的文件发送出去 注意配置location块中的content阶段指令，如echo、proxy_pass等，避免其使用默认的静态文件查找导致404错误 其他的处理阶段 11个请求处理阶段包括： post-read 在nginx读取并解析完请求头后开始运行，ngx_realip 位于此阶段中 server-rewrite server块中的rewrite指令会在此阶段执行，当匹配到对应的rewrite时，将直接进行跳转 find-config 此阶段中nginx完成当前请求与location配置块的配对工作。 此阶段之前，请求与location块没有任何关联，故只有server块或者更外层作用域中的指令才会起作用，所以之前post-read和server-rewrite中需要执行的指令都必须写在server作用域下 nginx在此阶段成功匹配到一个location后，会立刻打印一条调试信息到错误日志中 [debug] 84579#0: *1 using configuration \"/hello\" rewrite location配置开始起作用 post-rewrite 完成rewrite阶段产生的内部跳转。 内部跳转是将当前请求的处理阶段强行倒回到find-config，重新进行URI与location的匹配，但是真正的回退操作发生在post-rewrite阶段，以便完成多次的rewrite指令 preaccess access阶段之前进行，标准模块 ngx_limit_req 和 ngx_limit_zone运行于此阶段，ngx_realip 也在这个阶段注册了处理程序 access post-access 不支持模块注册处理程序，主要用于配合 access 阶段实现标准 ngx_http_core 模块提供的配置指令 satisfy 的功能，进行与access相关条件的综合判断 try-files 运行try-files指令 content log "},"nginx/nginx语法简介.html":{"url":"nginx/nginx语法简介.html","title":"nginx语法简介","keywords":"","body":"nginx的简单使用 nginx下载安装 nginx下载 安装过程中注意各项依赖的安装，gcc、pcre、openssl、cmake、zlib，安装完成后默认通过80端口可以访问 nginx.conf为主配置文件，位于/usr/local/nginx/conf中 worker_process # 表示工作进程的数量，一般设置为cpu的核数 worker_connections # 表示每个工作进程的最大连接数 server{} # 块定义了虚拟主机 listen # 监听端口 server_name # 监听域名 location {} # 是用来为匹配的 URI 进行配置，URI 即语法中的“/uri/” location /{} # 匹配任何查询，因为所有请求都以 / 开头 root # 指定对应uri的资源查找路径，这里html为相对路径，完整路径为 # /opt/nginx-1.7.7/html/ index # 指定首页index文件的名称，可以配置多个，以空格分开。如有多 # 个，按配置顺序查找。 location匹配规则 模式 含义 location = /uri = 表示精确匹配，只有完全匹配上才能生效 location ^~ /uri ^~ 开头对URL路径进行前缀匹配，并且在正则之前，前缀匹配不对url进行编码。 location ~ pattern 开头表示区分大小写的正则匹配 location ~* pattern 开头表示不区分大小写的正则匹配 location /uri 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后 location / 通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default 多个location匹配顺序： 精确匹配 前缀匹配，前缀匹配时进行贪婪匹配，按照最大匹配原则进行 按规则书写顺序正则匹配 匹配不带任何修饰符的前缀匹配 通用匹配 当匹配成功后，停止匹配，按照当前规则进行处理 必选规则： 根路径匹配规则，通过域名访问网站首页比较频繁，直接匹配网站根加快首页匹配速度， location = / { proxy_pass http://tomcat:8080/index } 静态文件匹配规则，nginx强项 按目录匹配 location ^~ /static/ { root /webroot/static/; } 按文件匹配 location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ { root /webroot/res/; } 通用规则 location / { proxy_pass http://tomcat:8080/ } rewrite 语法 用于判断的表达式 -f 和 !-f 用来判断是否存在文件 -d 和 !-d 用来判断是否存在目录 -e 和 !-e 用来判断是否存在文件或目录 -x 和 !-x 用来判断文件是否可执行 nginx中部分全局变量 例：http://localhost:88/test1/test2/test.php?k=v $host：localhost $server_port：88 $request_uri：/test1/test2/test.php?k=v $document_uri：/test1/test2/test.php $document_root：D:\\nginx/html $request_filename：D:\\nginx/html/test1/test2/test.php 避免使用if 某些情况下使用if指令会出现错误，发生不可预期的行为。但是相同条件下if的处理是一致的 location区块中if指令下100%安全的指令有：return,rewrite,last 错误原因： if 指令是 rewrite 模块中的一部分, 是实时生效的指令。另一方面来说, Nginx 配置大体上是陈述式的。在某些时候用户出于特殊是需求的尝试, 会在 if 里写入一些非 rewrite 指令, 这直接导致了我们现处的情况。 if的替换 使用 try_files 如果他适合你的需求。在其他的情况下使用 return … 或者 rewrite … last。还有一些情况可能要把 if 移动到 server 区块下(只有当其他的 rewrite 模块指令也允许放在的地方才是安全的)。 location / { error_page 418 = @other; recursive_error_pages on; if ($something) { return 418; } # some configuration # ... } 静态文件服务 配置cache、gzip等 文件缓存 在浏览器和应用服务器之间，存在多种潜在缓存，如：客户端浏览器缓存、中间缓存、内容分发网络（CDN）和服务器上的负载平衡和反向代理，可以提高响应性能，并更有效率的使用应用服务器 配置基础缓存 proxy_cache_path：设置缓存路径和配置，levels、keys_zone、max_size、inactive、use_temp_path等 proxy_cache：启用缓存，可以在location中针对具体路径进行缓存，也可以在server中针对所有未指定自身缓存的服务进行缓存 nginx使用缓存处理服务器错误 当原始服务器宕机或繁忙时，nginx可以将内存中的陈旧内容，提供容错能力，保证在服务器故障或流量峰值的情况下的正常运行 具体配置： location / { ... proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504; } 上面的例子中，当服务器返回error、timeout以及其他5xx错误，就会将缓存中请求文件的旧版本发送给客户端 缓存的其他配置项 proxy_cache_revalidate 指示 Nginx 在刷新来自服务器的内容时使用 GET 请求 proxy_cache_min_uses 该指令设置同一链接请求达到几次即被缓存，默认值为 1 proxy_cache_lock 指示当多个客户端请求一个缓存中不存在的文件（或称之为一个 MISS），只有这些请求中的第一个被允许发送至服务器 日志 access_log：定义访问日志文件的存放路径（包含日志文件名）、格式、缓存大小 access_log path [format_name [buffer=size | off]]; logformat示例： log_format myformat '$remote_addr $status $time_local'; access_log logs/access.log myformat; logformat字段配置： 字段 | 作用 ---- | ---- $remote_addr与$http_x_forwarded_for | 记录客户端IP地址，默认 $remote_user | 记录客户端用户名称，默认 $request | 记录请求的URI和HTTP协议，默认 $status | 记录请求状态，默认 $body_bytes_sent | 发送给客户端的字节数，不包括响应头的大小，默认 $bytes_sent | 发送给客户端的总字节数 $connection | 连接的序列号 $connection_requests | 当前通过一个连接获得的请求数量 $msec | 日志写入时间。单位为秒，精度是毫秒 $pipe | 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.” $http_referer | 记录从哪个页面链接访问过来的，默认 $http_user_agent | 记录客户端浏览器相关信息，默认 $request_length | 请求的长度（包括请求行，请求头和请求正文） $request_time | 请求处理时间，单位为秒，精度毫秒 $time_iso8601 | ISO8601标准格式下的本地时间 $time_local | 记录访问时间与时区，默认 log_format 配置必须放在 http 内，否则会出现警告 Nginx 进程设置的用户和组必须对日志路径有创建文件的权限，否则，会报错 error_log：指定错误日志与错误日志等级 error_log path [level]; level：错误日志等级，debug、info、notice、warn、error、crit、alert、emerg,从左到右日志详细程度递减，默认level为error 关闭错误日志： linux下将存储位置设为空设备，error_log /dev/null; windows下将存储位置设为空设备，error_log nul; 查看正在改变的文件 linux下使用tail -f filename命令查看正在改变的文件，将文件最尾部的内容显示在屏幕上并不断刷新，看到最新的文件内容 反向代理 反向代理指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 !反向代理 反向代理应用场景 负载均衡 为防火墙之后的服务器增加安全保障 将不同web服务器系统的资源存在于同一个域名下 负载均衡 upstream负载均衡 upstream 是 Nginx 的 HTTP Upstream 模块，使用upstream指令指定一个负载均衡器名称及其内部相关服务器，在需要使用的地方直接调用 upstream test.net{ ip_hash; server 192.168.10.13:80; server 192.168.10.14:80 down; server 192.168.10.15:8009 max_fails=3 fail_timeout=20s; server 192.168.10.16:8080; } server { location / { proxy_pass http://test.net; } } upstream负载均衡算法 在upstream中配置 轮训：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响 ip_hash：每个请求按照来访IP的hash结果分配，同一个IP固定访问一个后端服务器，可以解决动态页面session共享问题 fair：依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配 url_hash：按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率 least_conn：最少连接负载均衡算法，单来说就是每次选择的后端都是当前最少连接的一个 server(这个最少连接不是共享的，是每个 worker 都有自己的一个数组进行记录后端 server 的连接数) hash：这个 hash 模块又支持两种模式 hash, 一种是普通的 hash, 另一种是一致性 hash upstream状态参数 weight：权重，权重越高越容易被分配到 down：当前server不参与负载均衡 backup：预留的备份机器。当其他所有的非 backup 机器出现故障或者忙的时候，才会请求 backup 机器，因此这台机器的压力最轻 max_fails：允许请求失败的次数，默认为 1 。当超过最大次数时，返回 proxy_next_upstream 模块定义的错误 fail_timeout：在经历了 max_fails 次失败后，暂停服务的时间。max_fails 可以和 fail_timeout 一起使用 配置负载均衡 在server的外部定义负载均衡名称，定义好之后，再location中使用proxy_pass引用 nginx健康状态检查 使用max_fails与fail_timeout可以控制异常情况 backup配置 backup服务器为预留的备份机，相当于sorry server 常见错误与使用陷阱 root放在location区块内 root指令应该放在server内部，否则每增加一个location就要为其配置相应的root server { server_name www.example.com; root /var/www/Nginx -default/; location / { # [...] } location /foo { # [...] } location /bar { # [...] } } 重复的index指令 index指令应该放置于http区块中，下面的所有server会继承这个配置 http { index index.php index.htm index.html; server { server_name www.example.com; location / { # [...] } } server { server_name example.com; location / { # [...] } location /foo { # [...] } } } 避免使用if 以下操作应该避免： 使用if检查server name：导致所有的请求进来之后都需要执行if，效率低下 应该将不同的servername分开编写，使用多个server区块分别处理，避免if的使用 使用if检查文件是否存在 应该使用try_files进行文件检查，可以一次性测试一个序列 正确使用rewrite 将rewrite与nginx中的全局参数搭配使用，避免使用复杂的正则表达式进行路径匹配或者参数提取 rewrite ^/(.*)$ http://example.com/$1 permanent; rewrite ^ http://example.com$request_uri? permanent; return 301 http://example.com$request_uri; 使用绝对路径的rewrite 使用rewrite时，应该加上协议名称，拼接为绝对路径，避免相对路径的使用 注意缓存问题 浏览器缓存会导致部分配置不会立刻生效 root的使用 root不应该指向服务器根目录，否则会导致服务器安全问题，容易受到攻击 使用ip地址代替主机名 使用ip地址代替主机名，省略nginx的地址解析过程 "},"nginx/modules/":{"url":"nginx/modules/","title":"模块简介","keywords":"","body":"各模块简介 "},"nginx/modules/core_functionality.html":{"url":"nginx/modules/core_functionality.html","title":"核心功能模块","keywords":"","body":"核心模块 accept_mutex on | off 互斥锁，涉及惊群机制，打开后工作进程会轮流接收新的连接，否则每次请求进来后所有的worker都会被唤醒，会造成部分worker负担过重。 默认为off accept_mutex_delay time | 500ms 指定的互斥等待时间，过了等待时间之后，下一个worker进程便取得mutex锁，处理请求 daemon on | off 守护进程，默认为on debug_connection address | CIDR | unix:; 针对特定的IP开启debug模式，其他地址的连接仍然使用error_log模式 debug_points abort | stop; 应用于调试，设置断点 env variable[=value] nginx会移除除TZ之外的所有环境变量，此指令可用于创建新的环境变量 env MALLOC_OPTIONS; env PERL5LIB=/data/site/modules; env OPENSSL_ALLOW_PROXY_CERTS=1; error_log file [level] 指定错误日志文件与错误等级，详见语法简介 event {...} 为影响指定连接处理的准则提供上下文 ？？？？？ include file | mask 包含其他配置文件，减少主配置文件的大小 可以使用全局包含的方法，include vhosts/*.conf; load_module file 用于加载动态模块 lock_file file 为accept_mutex指定锁文件 master_process on | off 默认为on，决定是否开启工作进程，仅在开发阶段使用 multi_accept on | off 默认为off，开启后一个worker同时只能接受一个connection pid file 默认为pid logs/nginx.pid，定义主进程id存储文件 cat logs/nginx.pid\\命令可以对nginx进行配置文件的重新加载 ssl_engine device 指定openssl所用的引擎 thread_pool name threads=number [max_queue=number] name用于命名线程池，threads用于定义线程池中的线程数量，max_queue用于限制等待队列中的任务数量，默认为65536 timer_resolution interval 降低worker进程中的时间分辨率，并由此降低gettimeofday()方法的调用次数 默认情况下gettimeofday()方法在每次内核接收到时间之后都会被调用，使用该指令后，每个interval事件之后调用一次 use method; 取值选项：select、poll、kqueus、epoll、/dev/poll、eventport 设置connection processing的处理方式。一般情况下情况下不需要指定，nginx会自动选择最合适的处理方法 user user [group] 指定nginx的worker进程运行用户，默认为nobody账号 worker_aio_requests number 当使用aio epoll作为连接处理方法，设置单个worker进程的最大异步IO操作数量，默认为32 worker_connections number 设置单个worker进程可以同时建立连接的数量，默认为512 worker_cpu_affinity cpumask ... 将worker进程与CPU进行绑定，与worker_processes搭配使用 worker_proceses 4; worker_cpu_affinity 0001 0010 0100 1000; worker_priority number 定义工作进程的调度优先级，取值从20到-20，默认为0 worker_processes number | auto 定义worker进程数量，一般应该与CPU核数保持一致 worker_rlimit_core size 用于设置worker进程的最大容量，用于扩容 worker_rlimit_nofile number 改变每个worker进程能够打开的最大文件数量 worker_shutdown_timeout time 改变work进程的关闭延迟，当time到期之后，nginx将会茶室关闭当前所有连接以促进worker进程的关闭 working_directory directory 指定一个worker进程的工作目录，此操作仅针对用于内核 "},"nginx/modules/ngx_http_core_module.html":{"url":"nginx/modules/ngx_http_core_module.html","title":"HTTP核心模块","keywords":"","body":"http核心模块 absolute_redirect on | off 默认值为on，如果禁用，nginx发出的重定向将是相对路径 aio on | off | threads[=pool] 默认为off，设置FreeBSD和linux下是否可以使用异步文件I/O 当同时在linux上使用AIO和sendfile时，AIO用于文件大小大于或等于directio指令指定的大小的情况，sendfile用于较小的文件或者directio指令被禁用的情况 location /video/ { sendfile on; aio on; directio 8m; } 文件也可以采用多线程的方式读取和发送，不必局限在一个worker进程中。文件的读取和发送操作在指定的线程池中进行中转，线程池的名字可以被直接指定或者使用变量名称指定，如果没有指定，将会使用默认名称default location /video/ { sendfile on; aio threads; #aio threads=pool$disk; } 目前多线程只有epoll、kqueue和eventport方法兼容，多线程发送文件只支持linux aio_write on | off 默认为off 当aio可用时，指定其是否可用于文件的写操作。目前仅能用于aio threads和从代理服务器获取到数据时临时文件的写操作 alias path 在特定的location下面设置目标文件夹路径，path可以为指定值或者变量，path必须以\\结束，alias只能用于location块中 location /i/ { alias /data/w3/images/; } 当请求/i/top.gif时，会匹配到当前的location中，根据alias配置发送/data/w3/images/top.gif文件 alias在使用正则匹配时，location后uri中捕捉到要匹配的内容后，并在指定的alias规则内容处使用，以组成一个完整的文件路径 location ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ { alias /data/w3/images/$1; } chunked_transfer_encoding on | off 默认为on 允许在HTTP / 1.1中禁用分块传输编码。 尽管有标准要求，但当前使用软件无法支持分块编码时，它可能会派上用场 client相关 client_body_buffer_size size 设置默认的请求body buffer大小，默认值为8k|16k。默认情况下大小为两个memory page。一个memory page大小与操作系统关联，32位为4k，64k为8k 当body大小超出限制时，会将body整体或部分放入一个临时文件中。 client_body_in_file_only on | clean | off 设置请求body是否需要保存到一个文件中，一般用于debug模式，默认为off 取值为on时，请求结束后临时文件不删除 取值为clean时，请求结束后删除临时文件 client_body_in_single_buffer on | off 默认为off，指定是否将请求body放入一个缓冲区中 client_body_temp_path path [level1 [level2 [level3]]] 默认值为client_body_temp，指定存储body的临时文件目录 client_body_timeout time body读取超时设置，默认值60s。只有请求体需要被1次以上读取时，该超时时间才会被设置。且如果这个时间后用户什么都没发，nginx会返回requests time out 408 client_header_buffer_size size header缓冲区大小，默认值1k 当请求头过大超出缓冲区，比如包含大量cookie，将会根据large_client_header_buffers分配更大的buffer区域 client_header_timeout time 读取请求头延迟，默认60s。如果客户端没有在指定的时间内发送完整的请求头，nginx会返回requests time out 408 client_max_body_size size 设置服务端最大允许请求体，默认为1M，在请求头的content-length字段中会标明当次请求的请求体大小。 如果请求体大小超过最大允许值，将会返回413 (Request Entity Too Large)错误，但是浏览器不知道如何正确显示413错误 将size大小设为0后，将禁用请求body大小检查 connection_pool_size size 精准控制每一个connection的内存分配，一般不使用，默认为256或512bytes default_type mime-type 设置response的默认mime-type，默认值为text-plain directio [size|off] 指定sendfile指令可以使用的阈值，当文件体积小于directio指定的大小时，可以使用sendfile指令，默认为off 直接I/O是文件系统的一个功能，其从应用程序到磁盘直接读取和写入，从而绕过所有操作系统缓存。 这使得更好地利用CPU周期和提高缓存效率。这样的数据不需要在任何高速缓存中，并且可以在需要时加载。 它可以用于提供大文件 directio_alignment size 用于设置directio的块大小，默认值为512，在XFS文件系统下，应该增加到4K disable_symlinks 语法： disable_symlinks off; disable_symlinks on | if_not_owner [from=part] 处理文件路径中的符号链接 off：对文件路径中的符号链接不做处理与检查 on：如果文件路径中有符号链接，则拒绝访问 if_not_owner：如果文件路径中任何组成部分中含有符号链接，且符号链接和链接目标的所有者不同，拒绝访问该文件 from=part：当nginx进行符号链接检查时(参数on和参数if_not_owner)，路径中所有部分默认都会被检查。 而使用from=part参数可以避免对路径开始部分进行符号链接检查，而只检查后面的部分路径。 如果某路径不是以指定值开始，整个路径将被检查，就如同没有指定这个参数一样。 如果某路径与指定值完全匹配，将不做检查。 这个参数的值可以包含变量 命令使用：disable_symlinks on from=$document_root; 符号链接即为软连接，其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用，参见符号链接 error_page code ... [=[response]] uri 指定特定错误情况下显式返回的URI，可以使用response参数改变响应状态码。当前上下文中没有error_page时，从父级继承，URI中可以包含变量 error_page 404 =200 /empty.gif; error_page 500 502 503 504 /50x.html; 当URI被发送到另一个server服务上时，即error_page后面不是一个静态内容，使用单独的等号可以将server返回的状态码返回给用户 error_page 404 = /404.php; 可以使用error_page进行重定向 error_page 403 http://example.com/forbidden.html; error_page 404 =301 http://example.com/notfound.html; 如果是在内部进行跳转无需改变URI，可以将错误处理转到一个命名路径，如下式，转到fallback，在fallback中再进行相应处理。此种情况下，如果处理uri产生了错误，那么nginx将最后一次出错的HTTP响应状态码返回给客户端。 location / { error_page 404 = @fallback; } location @fallback { proxy_pass http://backend; } etag on | off 默认为on，作用为设置是否针对静态资源启用HTTP响应头中的etag http {...} 为http服务器提供配置上下文 if_modified_since off | exact | before 默认为exact，指定响应的修改时间与请求头中If-Modified-Since的比较方法 off：忽略if_modified_since请求头 exact：精确匹配 before：响应的修改时间小于等于if_modified_since请求头指定的时间 ignore_invalid_headers on | off 控制是否忽略非法的请求头字段名。 合法的名字是由英文字母、数字和连字符组成，当然也可以包含下划线。默认值为on 可以在server配置层定义一次，对监听在相同地址和端口的所有虚拟主机都生效 internal location中使用，指定一个路径是否只能用于内部访问，外部访问将收到404错误 内部请求包括： 由error_page、index、random_index和try_files指令引起的重定向请求 由后端服务器返回的X-Accel-Redirect响应头引起的重定向请求 由ngx_http_ssi_module模块 和ngx_http_addition_module模块 的include virtual指令产生的子请求 用rewrite指令对请求进行修改 使用示例： error_page 404 /404.html; location /404.html { internal; } nginx限制每个请求最多只能进行10次内部重定向，防止配置错误引起请求出现问题。超过10后，nginx将返回500 (Internal Server Error)错误 keepalive_disable none | browser ... 针对行为异常的浏览器关闭长连接功能，browser参数指定哪些浏览器会受到影响 msie6表示在遇到POST请求时，关闭与老版MSIE浏览器建立长连接 safari表示在遇到Mac OS X和类Mac OS X操作系统下的Safari浏览器和类Safari浏览器时，不与浏览器建立长连接 none表示为所有浏览器开启长连接功能 keepalive_requests number 通过一个长连接可以处理的最大请求数，请求数超过此值，长连接将会关闭 keepalive_timeout timeout [header_timeout] 默认值75s，第一份参数设置客户端的长连接在服务端保持的最长时间，第二份参数可选，设置Keep-Alive: timeout=time响应头的值，可以给两个参数设置不同的值 Keep-Alive: timeout=time响应头可以被火狐和chrome设备与处理，MSIE大约会在60s后关闭长连接 之后不再详细记录 large_client_header_buffers number size：设置读取客户端超大请求的缓冲最大数量和每块缓冲的容量。 当请求行的长度超过一块缓冲容量是，nginx返回414错误 当请求头长度超过一块缓冲容量时，nginx按返回400错误 默认值number为4，size为8k。长连接情况下处理完请求后，也会释放这些缓存 limit_except method ... { ... }：location中使用，限制可以对该路径进行请求的HTTP方法，当指定method为GET时，会自动添加HEAD方法，其他HTTP方法的请求会由ngx_http_access_module模块和ngx_http_auth_basic_module模块的指令来限制访问 使用实例： limit_except GET { allow 192.168.1.0/32; deny all; } limit_rate rate：限制每个连接向客户端传送响应的速率限制，单位为比特每秒，设置为0时取消限速 limit_rate_after size：传输量超过size大小时将，超出部分限速传送 lingering_close off | on | always：控制nginx如何关闭客户端 on：nginx在完成关闭连接前等待和 处理客户端发来的额外数据。但只有在预测客户端可能发送更多数据的情况才会做此处理 always：nginx无条件等待和处理客户端的额外数据 off：nginx立即关闭连接，不等待客户端传送的额外数据。此种处理方式会破坏协议，正常情况不应该使用 lingering_time time：在lingering_close指令生效时，设置nginx处理（读取但忽略）客户端额外数据的最长时间，超过这段时间后，nginx将关闭连接 lingering_timeout time：在lingering_close指令生效时，定义nginx等待客户端数据额外数据最长时间 在这段时间内，如果nginx没有接收到数据，将会关闭连接 如果nginx接收到数据，将会忽略它，然后继续等待 在等待————接收————忽略的循环中重复，但是总时间不会超过lingering_time listen：设置nginx监听地址，用于server上下文中 listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [ssl] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]]; listen port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [ssl] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]]; listen unix:path [default_server] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ssl] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]]; 针对IP协议，监听address和port listen 127.0.0.1:8000; listen 127.0.0.1; listen 8000; listen *:8000; listen localhost:8000; IPv6地址使用方括号表示 listen [::]:8000; listen [fe80::1]; 只定义address情况下，nginx默认使用80端口 针对Unix域套接字协议，监听path，使用unix:前缀 listen unix:/var/run/nginx.sock; default_server：携带default_server参数的server会被指定address:port的默认虚拟主机，如果任何listen都没有指定，则将第一个监听address:port的server作为该地址的虚拟主机 其他参数配置详见listen location location [ = | ~ | ~* | ^~ ] uri { ... } //匹配路径，路径可以嵌套 location @name { ... } // 定义命名路径，不能嵌套 路径匹配在URI规范化后进行，nginx会将URI中的编码字符进行解码，解析其中的相对路径，另外可能会对相邻的两个或多个斜线压缩为一个斜线 location匹配规则 模式 | 含义 --- | --- location = /uri | = 表示精确匹配，只有完全匹配上才能生效 location ^~ /uri | ^~ 开头对URL路径进行前缀匹配，并且在正则之前，前缀匹配不对url进行编码。 location ~ pattern | 开头表示区分大小写的正则匹配 location ~* pattern | 开头表示不区分大小写的正则匹配 location /uri | 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后 location / | 通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default 多个location匹配顺序： 精确匹配 前缀匹配，前缀匹配时进行贪婪匹配，按照最大匹配原则进行 按规则书写顺序正则匹配 匹配不带任何修饰符的前缀匹配 通用匹配 当匹配成功后，停止匹配，按照当前规则进行处理:fu: log_not_found on | off：开启或者关闭error_log中记录文件不存在的错误，默认为on log_subrequest on | off：开启或者关闭access_log中记录子请求的访问日志，默认off max_ranges number：限制HTTP请求头数量，如果数量超过限制，超出部分按照未携带处理，，默认不限制 merge_slashes on | off：开启或者关闭将URI中相邻多个斜线合并成一个的功能，默认开启 压缩URI对于正确的路径匹配十分重要，处于安全方面以及正确使用的考虑，建议不要关闭压缩 msie_padding on | off：在响应状态码大于等于400时，在响应正文中添加一段注释，使响应正文达到512字节。 本指令可以为MSIE客户端开启或关闭这个功能。 msie_refresh on | off：为MSIE客户端开启或者关闭用页面刷新取代页面重定向的功能。默认关闭 open_file_cache：配置文件缓存功能 取值： off：关闭缓存 max：缓存中元素最大数量，超过限制后使用最近最少使用算法删除元素 inactive：设置超时，指定时间内文件未被访问将会从缓存中删除，默认60s 可以缓存以下数据： 打开文件的描述符、大小和修改时间 目录查找结果 文件查找时的错误结果，需要使用open_file_cache_errors指令单独打开 open_file_cache_errors on | off：开启或者关闭缓存文件查找的错误结果，默认off open_file_cache_min_uses number：配合open_file_cache中的inactive参数使用，指定在此段时间内文件应该被访问的最小次数，默认为1次 open_file_cache_valid time：检查open_file_cache中缓存文件的间隔，默认为60s port_in_redirect on | off：nginx发起重定向时是否要指定端口，重定向时主机名使用server_name_in_redirect指定 postpone_output size：向客户端发送数据时会延迟发送，当至少有size字节的数据时才会开始发送。设为0将关闭延迟发送功能 read_ahead size：设置内核参数，控制文件预读数量 recursive_error_pages on | off：允许或者禁止error page指令进行多次重定向。如果禁止，则当重定向的错误页面出现问题，nginx将会直接输出默认错误页面 request_pool_size size：细调每个请求的内存分配，一般不用 reset_timedout_connection：开启或关闭重置超时连接功能 重置连接功能执行流程为，关闭套接字以前，设置SO_LINGER选项的超时值为0， 那么当关闭套接字时，nginx向客户端发送TCP RST，并且释放此套接字占用的所有内存。 这样可以避免某个已关闭的套接字长时间处于FIN_WAIT1状态，并占用内存缓冲区 超时的长连接依然是正常关闭的 resolver address ... [valid=time]：将后端服务器的域名解析成ip地址 resolver 127.0.0.1 [::1]:5353 valid=30s; 不指定端口号nginx将使用53端口，以轮询的方式发送到多台域名服务器 nginx会缓存域名解析结果，默认缓存时间是TTL字段值，可以通过valid参数覆盖 resolver_timeout time：设置域名解析超时，默认30s root path：设置请求根目录 path路径可以包含除$document_root和$realpath_root以外的变量 如果没有指定root，则默认根目录为configure prefix配置路径下的的html子目录，configure prefix配置可以在nginx运行时通过参数指定，默认为nginx的安装目录 satisfy all | any：访问权限控制，默认为all nginx进行访问限制的有ngx_http_access_module模块和 ngx_http_auth_basic_module模块 all：其所有限制条件都授权访问时才允许请求访问 any：任意条件允许访问即可允许请求访问 send系列 send_lowat size： size取值为0时nginx尝试最小化向客户端发送数据次数，指令在linux、windows、Safari上无效 send_timeout time;：设置向客户端传输响应超时时间 超时时间针对两次相邻写操作的时间间隔，如果客户端在这段时间内没有受到数据，将会关闭连接 sendfile on | off：是否开启sendFile()调用 sendfile_max_chunk size：默认为0 设置为非0值时，可以限制在一次sendfile()调用时传输的数据量。 如果不进行限制，一个快速的连接可能会霸占整个worker进程的所有资源 server系列 server {...} 内部包含一个虚拟主机配置，nginx没有明显分隔IP-based和name-baesd两种类型的虚拟主机 listen指令描述虚拟主机接受连接的地址和端口 server_name指令列出虚拟主机的所有主机名，即监听的主机名 server_name name ...：设置虚拟主机名，默认值为\"\"，第一个name是首要主机名 name可以使用通配符*，正则表达式等，使用正则表达式时需要在前面加上~，使用正则匹配组时可以在后面其他指令中继续使用匹配组 nginx允许使用空主机名，使得nginx可以处理没有HOST请求头的请求，而不是使用ip+port的默认虚拟主机进行处理 server_name匹配优先级： 精确匹配，确切的名字 最长的以*起始的通配符名字 最长的以*结束的通配符名字 第一个匹配的正则表达式名字（按在配置文件中出现的顺序） server_name_in_redirect on | off：是否开启将指定的首要主机名用于发起重定向功能，默认关闭 关闭时，nginx将使用Host请求头中的名字，如果没有请求头，使用虚拟主机所在的IP地址 server_names_hash_bucket_size size： 为了快速找到相应的server name的能力，Nginx使用散列表来存储server name。这个设置了桶的大小 参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数 server_names_hash_max_size size：设置主机名哈希表的最大容量，默认值为512 server_tokens on | off：开启或者关闭在错误信息的server响应头中输出nginx版本号 tcp_nodelay on | off：开启或关闭nginx使用TCP_NODELAY选项的功能。 这个选项仅在将连接转变为长连接的时候才被启用 tcp_nopush on | off：开启或者关闭nginx在FreeBSD上使用TCP_NOPUSH套接字选项， 在Linux上使用TCP_CORK套接字选项。 选项仅在使用sendfile的时候才开启 try_files：按照指定顺序检查文件是否存在，并且使用第一个找到的文件处理请求 指令使用 try_files file ... uri; try_files file ... =code; 文件路径根据root指令和alias指令，结合file参数拼接而成。 可以在名字尾部添加斜线以检查目录是否存在，比如“$uri/”。 如果找不到任何文件，将按最后一个参数指定的uri进行内部跳转 location / { try_files $uri $uri/ @drupal; } 最后一个参数可以使用命名路径，也可以是code location / { try_files $uri $uri/index.html $uri.html =404; } types {...}：设置文件扩展名和响应的MIME类型映射表，可以将多个扩展名映射到同一种类型 默认值： types { application/octet-stream bin exe dll; application/octet-stream deb; application/octet-stream dmg; } 指定某条路径下所有请求的MIME类型 location /download/ { types { } default_type application/octet-stream; } types_hash_bucket_size size：设置MIME类型哈希桶大小 types_hash_max_size size：设置MIME类型哈希表大小，默认1024 underscores_in_headers on | off：是否禁止客户端请求头中使用下划线，默认禁止 如果禁止，含有下划线的请求头将被标志为非法请求头并接受ignore_invalid_headers指令的处理。 可以在默认主机的server配置级别定义此命令。这样，指令设置将覆盖监听同一地址和端口的所有虚拟主机 variables_hash_bucket_size size：默认64，变量哈希桶大小 variables_hash_max_size size：默认512，变量哈希表最大容量 nginx内嵌变量 ngx_http_core_module模块支持内嵌变量，变量可以用于表示请求头字段以及其他的一些信息 变量 含义 $arg_name 请求头中的name参数 $args 请求行中的参数字符串 $binary_remote_addr 客户端IP地址的二进制形式，值的长度总是4字节 $body_bytes_sent nginx返回给客户端的字节数，不含响应头 $bytes_sent nginx返回给客户端的字节数，包含响应头 $connection 连接的序列号 $content_length “Content-Length”请求头的值 $content_type “Content-Type”请求头的值 $cookie_name 名为name的cookie $document_root 当前请求的root或者alias的配置值 $document_uri 同$uri $host “Host”请求头的值，如果没有该请求头，则为与请求对应的虚拟主机的首要主机名 $hostname 机器名称 $http_name 任意请求头的值；变量名的后半部为转化为小写并且用下划线替代横线后的请求头名称 $https 如果连接是SSL模块，返回“on”，否则返回空字符串 $is_args 如果请求行带有参数，返回“?”，否则返回空字符串 $limit_rate 允许设置此值来限制连接的传输速率 $msec 当前时间，单位为秒，精度为毫秒 $nginx_version nginx版本号 $pid worker进程PID $query_string 同$args $realpath_root 根据root或者alias指令算出来的当前请求的绝对路径，其中的符号链接都会解析成真实的文件路径 $remote_addr 客户端IP地址 $remote_port 客户端端口 $remote_user 为基本用户认证提供的用户名 $request 完整的原始请求行 $request_body 请求正文 $request_body_file 请求正文的临时文件名 $request_completion 请求完成时返回OK，否则返回空字符串 $request_filename 基于root指令或alias指令，以及请求URI，得到的当前请求的文件路径 $request_method 请求方法 $request_time 请求处理时间，单位为秒，从接收到客户端的第一个字节开始计算 $request_uri 完整的原始请求行，携带参数 $scheme 请求的协议类型，HTTP或者https $sent_http_name 任意的响应头字段的值。 变量名的后半部为转化为小写并且用下划线替代横线后的响应头名称 $server_addr 接收请求的服务器地址 $server_name 接收请求的虚拟主机首要主机名 $server_port 接受请求的虚拟主机的端口。 $server_protocol 请求协议，通常为“HTTP/1.0”或“HTTP/1.1”。 $status 响应状态码。 $tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space 客户端TCP连接的信息，在支持套接字选项TCP_INFO的系统中可用。 $uri 当前请求规范化以后的URI。变量$uri的值可能随请求的处理过程而改变。 比如，当进行内部跳转时，或者使用默认页文件。 "},"nginx/modules/others_http_module.html":{"url":"nginx/modules/others_http_module.html","title":"HTTP功能模块","keywords":"","body":"ngx_http_access_module访问IP限制 访问IP限制通过ngx_http_access_module模块实现，也可以通过密码限制访问，使用satisfy指令进行访问限制条件的控制 allow address | CIDR | all 允许指定的网络地址访问 deny address | CIDR | all 拒绝指定的网络地址访问，返回403错误页 使用示例： location / { deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; } 当有多条该模块指令时，按照书写顺序执行，直到遇到第一条满足条件的指令就不在执行后面的allow和deny指令 ngx_http_addition_module过滤模块 ngx_http_addition_module 是一个过滤模块，它可以在回复正文前后加上内容。例如请求index.html，可以在index.html的内容前插入链接指向的内容 add_before_body uri 在回复正文前插入一段文字，nginx会发起一个子请求获取链接指向的内容 add_after_body uri 在回复正文后插入一段文字，请求方式同上 addition_types mime-type ...; 指定生效的回复MIME类型，默认值为text/html ngx_http_proxy_module请求代理模块 请求转发 proxy_pass URL;：设置后端服务器的协议和地址，主要用于请求转发负载均衡，还可以设置可选的URI用于定义本地路径和后端服务器的映射关系，不影响浏览器地址栏的URL 协议可以使用http或者https，地址可以使用域名、IP地址加端口号或者Unix域套接字路径定义，其中可以使用变量。 如果一个域名被解析到多个地址，将采用轮换的方式使用，或者可以使用服务器组的形式定义地址（upstream负载均衡） 地址替换规则： 如果使用URI，将请求路径与配置路径的匹配部分替换为指令中定义的URI location /name/ { proxy_pass http://127.0.0.1/remote/; } 请求http://127.0.0.1/name/test.html 会被代理到http://example.com/remote/test.html 如果不使用URI，传送到后端服务器的请求URI一般是客户端发起的原始URI，如果nginx改变了请求URI，则传送的URI是nginx改变以后完整的规范化URI location /some/path/ { proxy_pass http://127.0.0.1; } 请求http://127.0.0.1/name/test.html 会被代理到http://127.0.0.1/name/test.html 一些情况下无法确定URI应该被替换的部分： 使用正则表达式定义路径，proxy_pass路径中不应该使用URI 需要代理的路径中，使用rewrite指令改变了URI并使用break参数，之后使用proxy_pass将不会改变URI参数，改变后的URI将被发送给proxy_pass指定的后端服务器 location /name/ { rewrite /name/([^/]+) /users?name=$1 break; proxy_pass http://127.0.0.1; } proxy_redirect：设置后端服务器“Location”响应头和“Refresh”响应头的替换文本 proxy_redirect default; // 默认 proxy_redirect off; proxy_redirect redirect replacement; replacement参数 proxy_redirect http://localhost:8000/two/ http://frontend/one/; proxy_redirect http://localhost:8000/two/ /; 第一项将响应头中location字段的相应路径替换为replacement 第二项省略服务器名，将使用代理服务器的主域名和端口号进行替换，如果端口号是80，可以不加 可以使用正则表达式，在redirect中可以包含命名匹配组和位置匹配组，在replacement中可以进行引用 proxy_redirect ~^(http://[^:]+):\\d+(/.+)$ $1$2; proxy_redirect ~*/user/([^/]+)/(.+)$ http://$1.example.com/$2; 使用proxy_redirect可以为相对地址的重定向添加域名 proxy_redirect / /; default参数 default参数指定的默认替换使用了location和proxy_pass指令参数，当proxy_pass使用变量作为参数时，不允许本指令使用default参数 off参数 off参数可以使所有相同配置级别的proxy_redirect指令失效 可以同时指定多个proxy__redirect指令 proxy_redirect default; proxy_redirect http://localhost:8000/ /; proxy_redirect http://www.example.com/ /; 缓存相关 ngx_http_proxy_module模块进行请求代理 proxy_buffer_size size：设置缓冲区大小为size，默认值为4k或8k nginx从被代理的服务器读取响应时（此时是response的返回阶段），使用该缓冲区保存响应的开始部分。这部分通常包含着一个小小的响应头。该缓冲区大小默认等于proxy_buffers指令设置的一块缓冲区的大小，但它也可以被设置得更小 proxy_buffering on | off：代理的时候开启或关闭缓冲后端服务器的响应，默认开启 开启缓冲，nginx尽可能快的从北大里的服务器接收响应，再存入proxy_buffers和proxy_buffer_size指令设置的缓冲区中 关闭缓冲，收到响应后，nginx立刻将其同步传给客户端，不会尝试从被代理的服务器读取整个请求，而是将proxy_buffer_size指令设定的大小作为一次读取的最大长度 响应头“X-Accel-Buffering”传递“yes”或“no”可以动态地开启或关闭代理的缓冲功能。 这个能力可以通过proxy_ignore_headers指令关闭 proxy_buffers number size：设置每个连接的缓冲区数量为number，默认为8，每块缓冲区大小为size，默认值与平台相关，为一个内存页的大小，4K或者8K proxy_busy_buffers_size size 开启缓冲响应功能之后，在没有读取到全部响应的情况下，当缓冲内容大小打到size后，nginx会向客户端发送响应，直到响应小于此值。默认取值是proxy_buffers和proxy_buffer_size单块缓冲区大小的两倍 同时剩余的缓冲区可以用于接收响应，需要时可以将一部分内容缓冲到临时文件。 proxy_cache zone | off：指定用于页面缓存的共享内存。同一块共享内存可以在多个地方使用，off参数可以屏蔽父级上下文中的参数设置 proxy_cache_bypass string ...：定义nginx不从缓存读取响应的条件 如果至少一个字符串条件非空而且非“0”，nginx就不会从缓存中去取响应，可以搭配proxy_no_cache使用 proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment; proxy_cache_bypass $http_pragma $http_authorization; proxy_no_cache string ...;：定义不将响应写入缓存的条件 如果至少一个字符串条件非空而且非“0”，nginx就不将响应存入缓存 proxy_no_cache $cookie_nocache $arg_nocache$arg_comment; proxy_no_cache $http_pragma $http_authorization; proxy_cache_key string：定义如何生成缓存的key，默认值$scheme$proxy_host$request_uri proxy_cache_lock on | off：请求锁，默认关闭 开启后，多个客户端请求一个缓存中不存在的文件时，只有第一个请求会被允许发送至客户端获取文件，并根据proxy_cache_key在缓存中生成新条目。 其他请求相同条目的请求将会一直等待，直到缓存中出现相对应的内容，或者proxy_cache_lock_timeout指令超时后释放 指令可以使得在增加新的缓存条目时，访问源服务器的次数最少 proxy_cache_lock_timeout：设置请求锁超时时间，超时后其他请求将会被释放，默认5s proxy_cache_min_uses number：设置请求被缓存的最小请求次数，默认为1 proxy_cache_path path [levels=levels] keys_zone=name:size [inactive=time] [max_size=size] [loader_files=number] [loader_sleep=time] [loader_threshold=time] 设置缓存路径和其他参数 proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_404 | off 定义在何种情况下，如果后端服务器出现状况，nginx可以使用过期缓存。这条指令的参数与proxy_next_upstream指令的参数相同，默认为off updating参数允许nginx在正在更新缓存的情况下使用过期的缓存作为响应。这样做可以使更新缓存数据时，访问源服务器的次数最少 proxy_cache_valid [code ...] time：为不同的状态码设置不同的缓存时间 proxy_cache_valid 200 302 10m; proxy_cache_valid 404 1m; proxy_cache_valid 5m; proxy_cache_valid any 1m; 只设置缓存时间时，只有200、300和302的响应会被缓存 code设置为any时，可以缓存任何响应 缓存参数可以直接在响应头中设置，优先级高于本条指令 “X-Accel-Expires”响应头可以以秒为单位设置响应的缓存时间，如果值为0，表示禁止缓存响应，如果值以@开始，表示自1970年1月1日以来的秒数，响应一直会被缓存到这个绝对时间点 如果不含“X-Accel-Expires”响应头，缓存参数仍可能被“Expires”或者“Cache-Control”响应头设置 如果响应头含有“Set-Cookie”，响应将不能被缓存 这些响应头的处理过程可以使用proxy_ignore_headers指令忽略 响应头替换 proxy_cookie_domain：设置“Set-Cookie”响应头中的domain属性的替换文本，默认为off proxy_cookie_domain srcdomain replacement; 如果后端服务器返回的“Set-Cookie”响应头属性中domain指定为指令中的srcdomain，匹配过程大小写不敏感会将其替换为replacement。 指令中可以使用变量或正则表达式，正则表达式使用~开始 可以同时定义多条proxy_cookie_domain指令 off参数可以取消当前配置级别的所有proxy_cookie_domain指令 proxy_cookie_domain www.$host $host; proxy_cookie_domain localhost example.org; proxy_cookie_domain ~\\.([a-z]+\\.[a-z]+)$ $1; proxy_cookie_path：设置“Set-Cookie”响应头中的path属性的替换文本，默认为off proxy_cookie_path path replacement 替换掉后端服务器返回的“Set-Cookie”响应头path属性中的相应字符串，proxy_cookie_path /two/ /将path=/two/some/uri/替换为/some/uri/ path和replacement中可以包含变量和正则表达式，大小写敏感的匹配使用~开始，大小写不敏感的匹配使用~*开始 可以同时定义多条proxy_cookie_path指令 off参数可以取消当前配置级别的所有proxy_cookie_path指令 http请求处理 proxy_set_header field value;：允许重新定义或者添加发往后端服务器的请求头，如果将某一请求头设置为空字符串，则不会将其传递给后端服务器 默认值： proxy_set_header Host $proxy_host; proxy_set_header Connection close; 如果不想改变请求头中host的值，有两种做法 设置为$http_host变量，但是如果客户端请求头中不包含此值，那么传递到后端服务器的请求也不含这个头部 设置为$host变量，如果请求头包含Host则为Host字段的值，如果不包含则为虚拟机的主域名。可以将其与后端服务器的端口一起传送 proxy_set_header Host $host:$proxy_port; proxy_hide_header field：设置隐藏的响应头，不发送给客户端 nginx默认不会将“Date”、“Server”、“X-Pad”，和“X-Accel-...”响应头发送给客户端，proxy_hide_header设置额外的响应头，也不会发送给客户端 如果希望允许向客户端传递某些响应头，可以使用proxy_pass_header指令 proxy_ignore_headers field ...;：不处理后端服务器返回的指定响应头 取值可以为如下响应头 “X-Accel-Expires”，“Expires”，“Cache-Control”，和“Set-Cookie” 设置响应缓存的参数； “X-Accel-Redirect”执行到指定URI的内部跳转； “X-Accel-Limit-Rate”设置响应到客户端的传输速率限制； “X-Accel-Buffering”启动或者关闭响应缓冲； “X-Accel-Charset”设置响应所需的字符集 proxy_pass_header field;：允许将被屏蔽的后端服务器响应头到客户端 proxy_http_version 1.0 | 1.1：设置代理使用的HTTP版本，默认1.0 proxy_ignore_client_abort on | off;：设置当客户端在响应传输完成前关闭连接时，nginx是否关闭后端连接，默认off proxy_intercept_errors on | off：当后端服务器的状态响应码大于400时，是否将响应直接发送给客户端，或者将响应转发给nginx的error_page进行处理 proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_404 | off ... 指定在何种情况下一个失败的请求应该被发送到下一台后端服务器，默认值为error和timeout 只有在没有向客户端发送任何数据之前，请求转发到下一台服务器才可行。如果传输响应到客户端是出错或者超市，此类错误不可能恢复 proxy_read_timeout：从后端服务器读取响应的超时，默认60s 此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。 proxy_send_timeout time：向后端服务器传输请求的超时，默认60s 超时是指相邻两次写操作之间的最长时间间隔，不是整个请求传输完成的最长时间。如果后端服务器在超时时间内没有接收到任何数据，连接将被关闭 proxy_connect_timeout time：设置与后端服务器建立连接的超时时间，一般不可能大于75秒 proxy_ssl_session_reuse on | off;：决定是否重用与后端服务器的SSL会话。如果日志中出现“SSL3_GET_FINISHED:digest check failed”错误，请尝试关闭会话重用。 proxy_store on | off | string;：设置将文件保存到磁盘功能，默认值为off on，nginx会将文件保存到alias或者root指令设置的路径中 off，nginx关闭文件保存功能 string，指定保存的路径和文件名，可以包含变量。如proxy_store /data/www$original_uri; 文件保存相关： 保存文件的修改时间根据请求头中的Last-Modified进行设置 响应均为先写入临时文件，如果存储位置和临时文件位于不同文件系统中，需要进行拷贝操作，如果是同一个文件系统，仅需重命名即可。 故推荐将保存文件的路径与proxy_temp_path设置的临时文件路径位于同一个文件系统中 proxy_store_access users:permissions ...;设置新创建文件的访问权限，默认值user:rw 可以设置user、group和all三种角色的权限，指定了任何group或者all的权限后，可以省略user的访问权限 proxy_store_access group:rw all:r; proxy_temp_path path [level1 [level2 [level3]]];：定义从后端服务器接收的临时文件的存放路径，默认值为proxy_temp proxy_temp_file_write_size size;：设置nginx每次写数据到临时文件的size(大小)限制，默认值为8k或者16k 默认值为proxy_buffer_size和proxy_buffer指定的每块缓冲区大小的两倍，最大值为proxy_max_temp_file_size proxy_max_temp_file_size size：指定临时文件的最大容量，打开相应缓存后，当缓存区不够时，会将部分响应存储在临时文件中。，默认1024M 将取值设为0将禁止响应写入缓存文件 内部变量 模块的内部变量可以用于proxy_set_header中构造请求头 核心模块的变量可以全局访问 $proxy_host：后端服务器的主机名和端口 $proxy_port：后端服务器端口 $proxy_add_x_forwarded_for：取值为将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头对应值的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同 ngx_http_rewrite_module模块 注意此处模块的概念为ngx_http_rewrite_module和ngx_http_proxy_module此类模块 break：停止处理当前这一轮的ngx_http_rewrite_module模块，跳过在他们之后的所有rewrite模块指令。 if (condition) { ... }：if指令会从上一层配置中继承配置 条件可以为下列情况： 变量名：如果变量值为空或者是以“0”开始的字符串，则条件为假 使用“=”和“!=”运算符比较变量和字符串 使用“~”（大小写敏感）和“~*”（大小写不敏感）运算符匹配变量和正则表达式。 正则表达式可以包含匹配组，匹配结果后续可以使用变量$1..$9引用。如果正则表达式中包含字符“}”或者“;”，整个表达式应该被包含在单引号或双引号的引用中 使用“-f”和“!-f”运算符检查文件是否存在 使用“-d”和“!-d”运算符检查目录是否存在 使用“-e”和“!-e”运算符检查文件、目录或软连接是否存在 使用“-x”和“!-x”运算符检查可执行文件 使用示例： if ($http_user_agent ~ MSIE) { rewrite ^(.*)$ /msie/$1 break; } if ($http_cookie ~* \"id=([^;]+)(?:;|$)\") { set $id $1; } if ($request_method = POST) { return 405; } if ($slow) { limit_rate 10k; } return：停止处理并返回指定code给客户端，返回非标准的状态码444可以直接关闭连接而不返回响应头 指令格式： return code URL，指定重定向的URL，状态码为301、302、303和307 return code [text]，指定响应体文本，状态码为其他值 return URL，将使用302临时重定向作为状态码，URL参数应该以“http://”或者“https://”开始 响应体文本或者重定向URL中可以包含变量 作为一种特殊情况，重定向URL可以简化为当前server的本地URI，那么完整的重定向URL将按照请求协议（$scheme）、server_name_in_redirect指令和port_in_redirect指令的配置进行补全 rewrite regex replacement [flag];：用于修改请求URL，如果指定的正则表达式能匹配URI，此URI将被replacement参数定义的字符串改写 rewrite指令按照在配置文件中出现的顺序执行，如果replacement的字符串以“http://”或“https://”开头，nginx将结束执行过程，并返回给客户端一个重定向 flag参数设置后续指令的执行情况 last：停止执行当前rewrite模块，然后查找匹配改变后URI的新location，注意此处直接去匹配改变后的location，如果是在location中使用，会直接跳出当前location break：停止执行当前rewrite模块，但是不影响其他模块的执行，如果是在location中使用，不会直接跳出location redirect：在replacement字符串未以“http://”或“https://”开头时，使用返回状态码为302的临时重定向 perament：返回状态码为301的永久重定向 如果replacement字符串包括新的请求参数，以往的请求参数会添加到新参数后面。如果不希望这样，在replacement字符串末尾加一个问号“？”，就可以避免 注意rewrite与proxy_pass的区别 rewrite_log on | off;：开启或者关闭将ngx_http_rewrite_module模块指令的处理日志以notice级别记录到错误日志中。 set variable value;：为指定变量variable设置变量值value。value可以包含文本、变量或者它们的组合。 uninitialized_variable_warn on | off;：控制是否记录变量未初始化的警告到日志 "},"nginx/others.html":{"url":"nginx/others.html","title":"其他概念","keywords":"","body":"同步与异步 两种消息通信机制，关注调用操作的结果的返回方式 同步：发出一个调用后，在没有得到结果之前，调用不返回 异步：发出一个调用后，直接返回但是不会立刻得到结果。当被调用方执行完成后，主动通知调用方结果 阻塞与非阻塞 两种调用机制，关注程序在等待调用结果时的状态 阻塞：调用结果返回之前，当前线程会被挂起，调用操作只有在得到结果之后才会返回 非阻塞：在不能立刻得到结果之前，调用操作不阻塞当前线程 同步异步与阻塞非阻塞是两套机制，可以互相搭配 同步阻塞 同步非阻塞：不停轮询查看调用状态，若未处理完毕，返回EAGAAN，若处理完毕，则返回结果 异步阻塞 异步非阻塞 socket 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket 虚拟主机名 虚拟主机名使用server_name指令定义，用于决定由某台虚拟主机来处理请求 nginx以名字查找虚拟主机匹配顺序： 确切的名字 最长的以星号起始的通配符名字 最长的以星号结束的通配符名字 第一个匹配的正则表达式名字（按在配置文件中出现的顺序） "},"chrome-devtools/":{"url":"chrome-devtools/","title":"chrome devtools","keywords":"","body":"chrome devtools overview element console network source performance deviceModel audit "},"chrome-devtools/overview.html":{"url":"chrome-devtools/overview.html","title":"overview","keywords":"","body":"chrome开发者工具 打开 菜单 > 更多工具 > 开发者工具 页面右击，选择“检查” 快捷键，windows下F12或Ctrl+Shift+I，Mac下Cmd+Opt+I 面板 设备模式 地理位置模拟 加速度模拟 触摸模拟 元素面板 检查与调整页面 编辑DOM与样式（永久与非永久） 控制台面板 过滤命令行输出 命令行交互 源代码面板 页面文件查看 断点调试使用 override持久化 网络面板 瀑布流 单个请求详细数据 网络模拟 其他设置 性能面板 页面性能分析 页面渲染顺序 深度性能分析tracing，偏内核 内存面板 应用面板 安全面板 指令菜单 Cmd+Shift+P (Mac) or Ctrl+Shift+P (Windows, Linux) "},"chrome-devtools/element.html":{"url":"chrome-devtools/element.html","title":"element","keywords":"","body":"元素面板 查看元素 查看和修改DOM树 被选中的元素在DOM树中蓝色突出显示 选中元素的几种方法： 在元素上右键选择检查 在devtools中点击元素选择器选择鼠标选择视野内的元素 在devtools中的DOM树中选择元素 在console中筛选出元素，在结果上右键选择Reveal in Elements panel 查看和修改元素属性 各个不同的tab中展示不同的元素属性 style（展示适用于元素的所有属性，包括被覆盖的属性、盒模型） filter筛选相关属性、取值 filter后:hov按钮可以设置元素当前伪类 filter后.cls按钮可以为当前元素增加类名 调整属性值时，方向键调整步长为1，alt+方向键步长0.1，shift+方向键步长为10，control+shift+方向键步长为100 Computed（最终适用于元素的属性、盒模型） 默认只显示被设置的属性，可选择显示全部css属性 Event Listener（元素上绑定的事件监听器） DOM断点 属性 为元素增加、删除或修改某些属性 使用内联样式修改元素样式 向特定的样式表中增加元素样式 element面板style面板中长按+，可以选择向某一个样式表中增加新样式 在特定的位置增加元素样式 点击element面板style面板中某一条css规则右下角更多工具栏的加号，会在该条规则后增加新规则，新规则与旧规则在同一个样式表中 chrome颜色面板 chrome中可以为元素的相关属性设置颜色值，颜色值前面的小方块可以预览颜色，点击小方块后，可以在颜色面板中进行调色等操作，其中包含取色笔。 accessibility面板 accessibility面板用于展现与元素可访问性相关的属性，页面可访问性包括能否通过键盘或屏幕阅读器访问与页面元素是否使用正确 选中元素后，在其accessibility面板中，其可看到相关信息 accessibility tree：DOM树的子集，其中仅包含在屏幕阅读器中会用到的元素 ARIA属性：为正确表示页面内容屏幕阅读器所需的所有信息 computed properties：部分元素属性是被动态计算得到的，显示在该栏中 部分视障人士对低对比度图案不敏感，元素在颜色面板中的Contrast Ratio如果是一个对号，则代表满足最低可访问性要求，两个对号表明满足增强的要求 command menu 使用Command+Shift+P (Mac)orControl+Shift+P (Windows, Linux, Chrome OS)可以打开devtools的command面板，或者点击顶部右侧或下面console栏左侧的更多可以打开该面板 rendering paint flashing：高亮页面中需要重绘的区域 layer borders：展示页面的图层边界 FPS meter：展示屏幕的FPS，GPU内存占用与GPU情况 scrolling performance issues：高亮具有与滚动相关的事件监听的元素，包括触摸和滚轮事件处理程序以及其他主线程滚动事件的处理。这些元素可能会损害页面的性能 事件委托的使用会减小内存的占用，但是当chrome判断当前元素没有进行事件绑定时，在滚动等事件发生时绘制会更加流畅。而在过高层级的元素上绑定scroll，会与这种机制相矛盾 emulate CSS media：选择CSS媒体，打印机或者屏幕 coverage 分析页面引入的js与css中使用和未使用的代码比例，选择每一个文件，可以看到其中使用与未使用到的代码 request blocking 阻塞包含特定关键字的请求 "},"chrome-devtools/console.html":{"url":"chrome-devtools/console.html","title":"console","keywords":"","body":"console 主要功能： 查看页面输出，可以定位到相应输出命令代码行 运行JavaScript，可以与页面相关或不相关，注意执行环境选择 展现形式 全屏模式：选择console栏 底部导航栏模式：在其他tab下按ESC 处理控制台输出 消息展示 消息堆叠 控制台中相同的消息会默认堆叠，并在消息旁显示重复次数 可以在setting -> console中选择show timestamps，显示每条消息时还会显示其时间戳，由于时间戳不同，不会出现消息堆叠 filter过滤 可以使用字符串或正则过滤控制台消息 ：仅展示包含该字符串的信息，或者文件名中包含该字符串 -：隐藏可以和匹配的信息 正则表达式：仅展示和正则表达式匹配的信息 也可以在其右侧的level中勾选想要展示的内容 verbose：详细，不勾选会过滤debug信息 Info Warning Error 清空历史记录 控制台右键Clear console 控制台调用clear()函数 JavaScript代码中调用console.clear() Ctrl + L 保留历史记录 console的设置项中preserve log可以跨页面保留log输出，在页面刷新或更改时不会清空控制台 运行JavaScript 选择执行环境 如图示下拉框为Execution Context Selector，可以选择控制台的执行环境，在页面中存在iframe时会有很大作用 此选项默认为top，即为页面的顶部框架。其他的框架和扩展程序在其自身环境中运行，执行环境可以通过下拉菜单进行切换。当在top外的环境进行操作时，选择框会突出显示为红色 当选中其他框架的元素时，devtools会将该选项设为对应的环境 console命令 console语句 console.clear()：清空控制台 console.log()：基本记录 console.group() & console.groupEnd()：分组输出，可以嵌套 console.group()中可以携带参数，作为该组的title console.group()可以替换为console.groupCollapsed()，会自动折叠该分组信息 console.warn()：警告，有堆栈信息 console.error()：报错，有堆栈信息 console.assert()：断言，在第一个参数为false时，输出第二个参数，同时包含堆栈信息 console.table(arr1, arr2): 将arr1中的对象以表格形式展示出来，arr2可选，内容为希望展示的key console.time(str) & console.timeEnd(str)：计时器，同一个计时开始与结束传入的字符串要相同 console.timeStamp(str)：在performance的时间轴上标记一条黄色垂直线，并在event log中添加相应记录 console.count(str)：输出str参数以及使用此参数调用该函数的次数，系统会自动为str进行计数 console.trace()：打印当前的堆栈信息 tips：window.onError参数：错误信息，错误页面网址，出错行号 具体见教程 字符串替代与样式控制 字符串替代：console函数中第一个参数可能包含一个或多个格式说明符，格式说明符由一个%符号与后面紧跟的一个字母组成，字母指示应用到值的格式。字符串后面的参数会按顺序替换占位符，达到字符串替换的效果 console.log(\"Node count: %d, and the time is %f.\", document.childNodes.length, Date.now()); 样式控制：console语句的第二个参数可以用于设置样式 console.log(\"%cThis will be formatted with large, blue text\", \"color: blue; font-size: x-large\"); 命令行函数 在控制台中可以使用与jQuery类似的元素选择器语法，但是其内部实现与jquery无关，可以避免使用document.querySelector()等过长的命令 $0-4：返回最后选中的五个元素，$0是最后访问的元素 $()：返回与指定 CSS 选择器匹配的第一个元素 $$()：返回一个与指定 CSS 选择器匹配的所有元素数组 $x()：返回一个与指定 XPath 匹配的元素数组 $x('html/body/p') $_：返回上一个表达式的输出，不一定是元素，也可以是JavaScript表达式结果 copy(object)：将指定对象的字符串表示形式复制到粘贴板 getEventListeners(object)：返回在指定对象上注册的事件侦听器 monitor(function)：调用指定函数，系统会向控制台记录一条消息，其中指明函数名称及在调用时传递到该函数的参数，停止监听使用unmonitor monitorEvents(object[, events])：监听指定对象上发生的事件，可以监听单独事件、事件数组或事件类型，详见教程，停止监控使用monitorEvents，可以直接停止监控所有事件，亦可以停止监控某一个事件 具体见教程 "},"chrome-devtools/network.html":{"url":"chrome-devtools/network.html","title":"network","keywords":"","body":"network 用于展示页面请求资源情况 工具使用 工具使用文档 底栏统计了请求数、下载资源大小、总耗时、DOMContentLoaded事件用时与load事件用时 network宽行高下每行size属性有两个值，上面的值是下载的资源大小，下面的值是解压后的资源大小，由此可以判断文件是否进行了压缩。 也可以通过http响应头中的content-encoding字段进行判断，如果资源经过压缩，此字段一般为gzip、deflate或者br 常见问题 过多请求排队 原因在于HTTP/1.0和HTTP/1.1下，chrome在每个host下最多只允许同时建立6个TCP连接 解决方法可以有： 必须使用HTTP/1.0和HTTP/1.1时，可以对域名进行分片 使用HTTP/2 将不必要的请求移除或者延后，以保障重要的请求可以较早发出 接受第一字节时间过长（wait时间过长） TTFB：Time To First Byte，原因可能是服务端相应过慢或客户端与服务端之间的连接太慢 解决办法： 如果是连接太慢，可以使用CDN或者改变服务提供者 如果是服务器太慢，考虑优化服务器 内容下载过慢 原因可能是连接不稳定或者需要下载的内容过大 解决办法为使用CDN或者压缩接收的内容 "},"chrome-devtools/source.html":{"url":"chrome-devtools/source.html","title":"source","keywords":"","body":"source page面板 page面板中可以看到当前页面已经加载的所有资源，其中组织结构如下 top级：代表一个HTML页面，每个页面中均可以找到对应的top 第二级：代表一个源 第三级、第四级及以下：代表从相应的源请求到的目录和路径 editor面板 在editor面板中展示和编辑代码 CSS代码不需要保存即可生效 JavaScript代码需要保存才可以生效，但是devtools不会重新执行脚本 snippets面板 可以将一些会在多个页面重复运行的小脚本保存为代码段，代码段会在已打开页面的上下文执行，可以配合断点使用 snippets可以访问全局范围的变量，如window等，但是无法访问对断点处的局部变量 overrides面板 可以直接在source中修改页面的js和css，页面刷新后修改会丢失。 overrides可以对修改进行本地化保存，以后页面针对此文件的请求也会直接使用该文件 断点 设置断点，可以在断点处查看和修改当前作用域下的属性与变量，运行JavaScript代码，或者进行其他操作 断点类型 代码行断点 代码某一行断点，source面板设置或debugger 可以为行断点设置触发条件，右键该断点，edit breakpoint中即可设置 XHR断点 当XHR请求的URL中包含特定的字符串时，devtools将在该请求send()函数调用行进行断点 在XHR/fetch breakpoint中右键可以添加相应断点，输入特殊字符串即可 DOM断点 针对DOM进行某种操作时触发断点 属性改变：Triggered when an attribute is added or removed on the currently-selected node, or when an attribute value changes. 子树改变：当前选中节点的子节点移出、添加，或子节点的内容发生改变时触发，当元素自身或子节点属性发生变化时不会被触发 节点移除：Triggered when the currently-selected node is removed Global listeners 显示绑定在 window 对象上的事件监听 事件监听断点 选择某一种或一类事件进行监听，可以监听全局范围内该事件的发生，事件发生时进行断点 js异常断点 source面板中右上角的Pause on exceptions可以在页面抛出异常是进行断点，下面的可选项Pause on caught exceptions可以在错误被捕获是进行断点（即断点会在try...catch中的try） 函数断点 使用debug(functionName)，作用类似于在该函数第一行设置代码行断点。必须确保该function在当前作用域内，否则会抛出关于ReferenceError 断点操作 F8跳过此断点 F9直接进入下个函数调用 F10单步执行跳过下个函数调用 F11单步执行进入下个函数调用 shift+F11跳出当前函数调用 执行代码到某行：在函数被中断时，可以在某一行代码上右键选择执行到此处，代码会执行到此处进行中断 重新执行堆栈函数：函数被中断时，在堆栈区右键选择Restart frame，堆栈顶部函数将会被重新执行 实际操作过程中发现，选择重新执行后，仍然需要resume此时断点，才会进入重新执行 线程内容 当使用web workers或者service workers时，threads窗口将会展现正在使用的线程，通过配合断点的使用，可以看到相应线程中的数据 watch watch可以监听变量值的变化，避免重复的console.log，其监视对象不仅限于变量，可以将任何有效的JavaScript表达式存储在监视表达式中 但是个人觉得watch需要配合断点使用，可以简化操作，避免重复调用对象，相比console.log优点有限 将预处理代码映射到源代码 chrome devtools可以基于文件的source maps，将预处理压缩过后的代码映射到源代码，从而在原始文件中设置断点和浏览代码。预处理器 devtools中运行source maps时，JavaScript不会编译，实际运行的是编译后的代码，但是此时错误、日志和断点都将映射到开发代码。 devtools -> setting -> source 中可以开启或者关闭JS与CSS的source map功能 BlackBox Script 代码黑盒 当一份js代码设为BlackBox后，将会在debug时进行忽略。 BlackBox的js代码在堆栈中会被置灰，不可选 BlackBox的js代码不可以进行单步调试 此功能适用于信任的第三方代码，在调试时确认与问题无关即可忽略 打开方式： 打开文件，右键选择BlackBox Script 在堆栈栏右键选择BlackBox Script setting -> Blackboxing -> Add pattern -> 输入脚本名称或其名称的正则表达式 devtools中F1可以直接进入setting "},"chrome-devtools/performance.html":{"url":"chrome-devtools/performance.html","title":"performance","keywords":"","body":"performance 展现页面在运行时的性能，找出其中耗时较长的部分进行优化 performance事件参考 window下performance对象可以提供页面加载相关事件耗时统计，时间采用timestamp格式，可以在使用该对象属性进行性能统计 工具使用 概览 FPS线：绿色越深，FPS越高，当看到一条红线FPS过低甚至损害用户体验 CPU栏：CPU栏火焰图颜色与底部summary统计栏中颜色相对应。当CPU栏被占满时，应该寻找方法减少CPU工作量 在火焰图上看到一到三条垂直的虚线，蓝线代表DOMContentLoaded事件，绿线代表首次绘制的时间，红线代表load事件 DOMContentLoaded：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。 但是同步的JavaScript会暂停DOM的解析，而且DOMContentLoaded必须等待其所属的script之前的样式表加载解析完成才会触发 load：浏览器已经加载了所有的资源，包括样式表、同步与异步js、图像与子框架等 堆栈栏 frame栏：鼠标悬停在frame栏顶部浅绿色区域，会展现当前帧的展现时间与当时的FPS，点击后在summary中查看更多 network栏：查看网络请求瀑布流，点击每个请求后在summary中查看更多 不同请求会用颜色作为区分，HTML蓝色，CSS紫色，JS黄色，图片绿色。高优先级请求左上角有深蓝色块，低优先级请求左上角为浅蓝色块，如下图所示 请求前面的细线代表Connection start事件组的所有内容，即为Request Sent前的所有内容 请求的浅色部分代表Request Sent和Waiting (TTFB) 请求的深色区域代表Content Download 请求后面的细线代表等待主线程所花费的事件，这部分在network面板中没有反映出来 main栏：展示主线程的活动。x轴代表时间，每一个bar都代表一个事件，y轴代表回调栈，上层的事件调用了下层的事件 当在事件的右上角看到红色的三角标时，表明当前事件可能存在问题，在summary栏会显示更详细的提示 紫色代表渲染活动，深黄色代表脚本活动，同一个脚本所使用的颜色是相同的 按住shift，可以使用鼠标在main面板中选择一个精确的时间区域，并且底部会显示选中的时间长度 底部综合栏 summary tab：展示事件详细信息 call tree tab：查看当前时间区域内工作量最大的root activities root activities位于每个事件回调栈的底层，在火焰图的最上面，是最高等级的事件 self time：执行事件自身所花费的时间 total time：该事件及其所调用的子事件全部花费的时间 Bottom-Up tab：查看当前时间区域内花费时间最多的活动，相同的活动时间可累加 self time：直接在活动自身中花费的时间总和 total time：该活动及其子活动花费的时间总和 Event log tab：按照录制过程的顺序查看活动 setting 可以在performance中使用Ctrl + F搜索目标词，会在火焰图中进行查找 代码建议 不要编写会强制浏览器重新计算布局的 JavaScript。将读取和写入功能分开，并首先执行读取，避免布局抖动 不要使您的 CSS 过于复杂。减少使用 CSS 并保持 CSS 选择器简洁 尽可能地避免布局。选择根本不会触发布局的 CSS 绘制比任何其他渲染活动花费的时间都要多。请留意绘制瓶颈 JavaScript profiler JavaScript profiler可以提供JavaScript的CPU分析 工具使用 视图模式 chart：火焰图，直观表示一段时间CPU分析 火焰图的高度与调用堆栈的深度相对应，颜色随机，但是函数的颜色在调用过程中始终保持一致 高调用堆栈不一定很重要，只是表示调用了大量的函数。 但宽条表示调用需要很长时间完成。 这些需要优化 Heavy (Bottom Up)：按照函数对性能的影响列出函数，让您可以检查函数的调用路径 Tree (Top Down)：显示调用结构的总体状况，从调用堆栈的顶端开始 "},"chrome-devtools/deviceModel.html":{"url":"chrome-devtools/deviceModel.html","title":"deviceModel","keywords":"","body":"device mode 使用devide mode可以方便的模拟多种设备及功能 模拟不同的屏幕尺寸和分辨率 通过可视化和检查 CSS 媒体查询进行自适应设计 使用网络模拟器在不影响其他标签流量的情况下模拟您网站的性能 针对触摸事件、地理定位和设备方向准确模拟设备输入 设置视口参数 自适应模式 自定义视口大小，可以拖动窗口右下角的箭头，或者在菜单栏中输入相应的值 特定设备模式 以预制设备大小可选择，也可设置自定义设备 设置其他参数 移动设备模式下屏幕右上角可选 device type：选择user agent类型 更改此设置会影响移动设备视口和触摸事件模拟并更改 UA 字符串。 因此，如果您想要为桌面设备创建自适应网站，且想要测试悬停效果，请在 Responsive 模式下切换到“Desktop” 设备像素比DPR：用于模拟Retina屏幕 media query：显示媒体查询标尺，左键点击媒体查询条形，调整视口大小和预览适合目标屏幕大小的样式，右键点击选择可以查看相应代码 rulers：基于像素的标尺 网络配置 模拟传感器 Chrome DevTools 的 more tools -> Sensors 模拟窗格可以模拟常见的移动设备传感器，包括地理定位与加速度计（模拟设备方向） 地理定位 其中geolocation项可以用于设置地理定位数值，替换navigator.geolocation的位置值，达到模拟效果 加速度计 通过加速度计可以模拟设备方向，通过orientation项进行设置 限制 device mode存在一些限制，主要在于以下几个方面 设备硬件 浏览器UI 浏览器功能 Appcache 远程调试安卓设备 此处需要使用Google提供的特定服务，故需要翻墙，采用host翻墙的方法，访问指定服务 172.217.21.20 chrome-devtools-frontend.appspot.com 连接安卓设备 设置安卓设备允许USB调试 此处有两种方法 访问chrome://inspect/?tracing#devices页面显示您的设备上已启用调试的 WebView 列表 在devtools的more tools -> Remote devices 中，选择discover USB devices，查看连接的设备 安卓设备设置端口转发 端口转发Port forwarding可以使安卓设备通过自身特定端口访问在开发计算机上部署的内容。如通过设置可以使得手机使用自身的8080端口通过USB数据线访问与之相连计算机的localhost:5000地址 端口转发通过在映射到开发计算机上 TCP 端口的 Android 设备上创建侦听 TCP 端口的方式工作。端口之间的流量通过 Android 设备与开发计算机之间的 USB 连接传输，所以连接并不取决于您的网络配置。 端口转发配置如下图所示，左侧为设备端口号，右侧为目标网站的IP或主机名，后面紧跟端口号 此部分起到反向代理的作用 完整的转发设置 完整的转发设置包括正向代理 + 反向代理，反向代理设置如上述，正向代理设置需要开发人员在WiFi的设置项中设置转发规则，地址为localhost，端口号为上述设置的devicePort，之后才可以将设置的所有请求由特定端口号转发到目标计算机上 "},"JavaScript_design_patterns/":{"url":"JavaScript_design_patterns/","title":"JavaScript设计模式","keywords":"","body":"JavaScript设计模式 前言 JavaScript简介 单例模式 "},"JavaScript_design_patterns/JavaScript.html":{"url":"JavaScript_design_patterns/JavaScript.html","title":"JavaScript简介","keywords":"","body":"面向对象的JavaScript 动态类型语言 静态类型语言：编译时即可确认变量的类型 优点：编译时即可发现与类型相关的错误，并且可以针对特定的数据类型进行优化，提高代码执行效率 缺点：强制规定类型，增加程序复杂度，增加代码量 动态类型语言：运行时变量被赋值后才能具有某种类型 优点：代码量更少更简洁，专注于逻辑本身 缺点：很可能发生与类型相关的错误 鸭子模型，面向接口编程：如果一个对象提供了其他类型的关键属性与方法，即关键接口，则其就可以被当做该类型进行使用 多态 同一操作作用于不同的对象，可以产生不同的解释和不同的执行结果 多态最重要的作用在于不必关注待操作对象的类型，只需要直接执行操作，其他工作在该对象内部完成，避免对于对象类型的if判断 静态类型语言的多态通过将操作提升为超类进行实现，使得由这个超类派生出的对象均具有相同的方法 JavaScript的多态只需要不同对象本身具有相同方法即可，以对象作为参数，函数内部直接调用该方法 封装 封装数据，JavaScript通过作用域限制对外暴露的对象 封装实现，将对象内部的实现封装起来，使得对象内部对外界透明，其内部变化外界不可见，对象之间的耦合度降低，只通过暴露的API进行通信 封装类型，静态类型语言通过为子类型设置抽象类或者接口实现，将对象真正的类型隐藏在抽象类或者接口之后 封装变化，将代码中稳定不变的部分与经常变动的部分剥离，保证程序的稳定性与可扩展性 原型模式与基于原型继承的JavaScript对象系统 "},"JavaScript_design_patterns/单例模式.html":{"url":"JavaScript_design_patterns/单例模式.html","title":"单例模式","keywords":"","body":"单例模式 单例模式：产生一个类的唯一实例 通俗讲即为该函数只会在第一次调用时被真正执行，后续调用会返回函数之前的执行结果。 该类函数的实现方式有： 全局变量 + 函数，全局变量保存函数执行结果，后续函数调用直接返回全局变量 函数闭包，内部保存状态，将上一方法放入闭包中实现（更好） 单例模式的实现函数： var singleton = function( fn ){ var result; return function(){ return result || ( result = fn .apply( this, arguments ) ); } } "},"novel/":{"url":"novel/","title":"基督山伯爵","keywords":"","body":"基督山伯爵 人物关系图 "}}