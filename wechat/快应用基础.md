# 快应用开发

## 快应用基础

### CSS

1. 仅支持border-box，不支持content-box与box-sizing
2. 长度仅支持px与%，其中px含义与前端不同

相当于在自身项目中配置屏幕宽度，可以在自身项目中借鉴

### 模板

1. 不能在p元素中直接放置文本内容
2. for、if、show、slot与vue相同

    show只能针对原生组件使用，自定义组件可以通过传参控制组件内容展示与否

    block块相当于vue中模板中的template块，只支持 for 和 if/elif/else 属性

3. 引入自定义组件方式不同

### 数据

1. 页面跳转

    1. 使用a标签：跳转链接可以跳转其他页面或应用，链接需手写，跳转其他页面可以使用search传递参数

    2. 使用router操作路由跳转，同时可传参，在protected属性中可接受跳转参数

    **跨页面/组件间双向传参**：在app.ux中增加数据对象，提升数据位置，相当于简化版vuex

2. $on、$off、$emit围绕页面级别自定义事件展开，$emit触发当前实例上监听的事件

    组件上事件绑定与vue相同，onclick缩写为@click

    $emitElement用于事件的动态触发，只能用于原生组件

3. 如果想改变父组件传入参数，可以watch该参数，然后在回调中向本组件数据赋值后改变

**子组件向父组件传参方式**：
1. 直接修改传入的对象（不太友好）
2. 子组件dispatch触发父组件内部$on监听事件，传参
3. 子组件$emit触发父组件在其上onevent1或@event-type1监听的事件，传参

**父组件直接向子组件传参**：
1. props父子组件传参
2. 调用parentVm.$broadcast()触发子组件监听的对应事件，完成向下传递

### 方法

1. 使用async代替callback与promise，需要额外配置

    generator是一种异步编程解决方案，如果其中要使用同步回调代码，需要将同步代码改造为异步方式，如promise（待考证）

2. $app 与$app.$def

    1. 前者会执行onCreate、onDestroy方法，其中this指向$app对象，后者不能执行
    2. 全局方法通过两者都可以调用，但是注意this不同

3. 回调函数被调用时，会自动在参数末尾增加event对象

### 优化

1. 函数共享：通过this.$app.$def共享定义在APP上的全局函数
2. 懒加载
3. 报错处理：快应用建议重新部分函数以避免在每个调用处写try catch，但是可以在最外层加try catch

## 使用疑问

1. 页面的声明周期，组件的生命周期呢？

    基本相同

2. onclick事件行内绑定，如何解绑？

    onclick其实就是元素属性，解绑需要将元素onclick属性置为null

3. 组件中各类数据声明的使用区别

    * data：会被外部数据覆盖，不要在页面级组件中使用
    * public：允许被传入的数据覆盖
    * protected：页面跳转传参使用
    * private：成员变量量，不允许被覆盖，页面级别数据
    * 局部变量：函数内部变量
    * 页面局部变量：定义在外部的变量
    * 自定义组件中使用data和props

## 踩坑

1. flex布局的使用

    全部默认flex布局，使用很不方便

2. 标签使用不灵活

    很多HTML标签没有，标签嵌套有强制规则，标签内容也有规定

3. css属性使用问题
    * font属性不能继承
    * 很多属性不能使用
    * margin不合并
    * 没有元素选择器

4. 调试器存在部分问题，修复中

    如列表渲染问题等，但是在修复中

## 总结

总体来说，快应用相较于小程序更偏向于底层，目前其优势在于
* 更方便的系统交互，相较于小程序会好一些
* 无需安装，这一点与微信小程序相同，依托于手机自身预装平台
* 相较于传统native较轻，但是目前app均为hybrid模式，也在朝着前端方面发展

故快应用最重要优势还是在于无需安装，但是入口较深，打开时需要搜索，更方便的做法是添加到桌面，但这会导致快应用和原生应用争夺市场空间。而微信小程序场景主要在微信内部，打开也很方便，相较快应用会好一点。

但是快应用目前问题在于自身不够成熟，其实现方式与web标准不一致，且快应用框架也需要完善，学习成本和开发成本较高，前景还不是很明确