# React进阶

# 高级指引

## 代码分割

配合懒加载只加载当前用户所需要的内容，避免体积过大导致加载时间过长，不影响实际的整体代码体积

### 动态import

动态import为代码分割最佳方式

```javascript
import('./math').then(math => {
    console.log(math)
})
```

### React.lazy

```javascript
const OtherComponent = React.lazy(() => import('./OtherComponent'));
```

引用`OtherComponent`组件的父组件在第一次渲染时，会自动导入包含`OtherComponent`的包

加载`OtherComponent`的父元素可以指定fallback属性，进行优雅降级

**React.lazy仅支持默认导出**，如果要支持命名导出，需要增加中间模块，将想要导出的模块重新导出为默认模块

## 错误边界

react 16引入错误边界，避免部分JavaScript错误导致整个应用崩溃

错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误，但是其无法以下错误
* 事件处理函数：事件回调不会在渲染期间触发，故当其抛出异常不影响当时的渲染，可以通过try/catch进行内部的错误捕获
* 异步代码
* 服务端渲染
* 错误边界本身跑出的错误

class组件具备以下两个生命周期中任意一个或两个时，即为错误边界
* `static getDerivedStateFromError()`用于渲染备用UI
* `componentDidCatch()`用于打印错误信息

**只有class组件才可以成为错误边界组件**

错误边界使用类似于try...catch，仅可以捕获子组件的错误，无法捕获自身错误。如果当前错误边界无法处理错误信息，则该错误信息会冒泡至最近的上层错误边界

### 未捕获错误行为

**自react 16起，任何未被错误边界捕获的错误将会导致整个组件树被卸载**，这要求
* 页面中所有可能报错的地方都要包含在错误边界中
* 相互独立的功能区域要用不同的错误边界

### 与try/catch区别

* `try/catch`是命令式的
* react组件是声明式的，错误边界保留了声明式的性质

## 高阶组件HOC

高阶组件是基于REACT组合特性形成的一种设计模式，是指参数是组件，返回值为新组件的**函数**

**组价是将props转换为UI，高阶组件是将组件转换为另一个组件**，HOC不会修改传入的组件，也不会使用继承来复制其行为，HOC通过将组件包装在容器组件中来组成新组件

### 约定：

1. 高阶组件应该将不相关的props传递给被包裹的组件
2. 最大化可组合性，即输入参数类型和输出结果类型相同，便于进行串联组合
3. 包装显示名称以便轻松调试

### 注意事项

1. 不要再render方法中调用高阶组件
    如果在render方法中调用高阶组件，会造成每次渲染更新时都会生成一个新的高阶组件，导致组件被重新渲染。这会造成性能问题和重新挂载后组件的状态丢失

    一般在组件之外创建HOC，则组建只会创建一次，如果确实需要动态创建HOC，则在组件生命周期中进行

    **React diff算法使用组件标识来确定一个组件是应该更新现有子树还是将其丢弃并挂载新子树**
    * 如果render返回的组件与前一个渲染中的组件相同(===)，则递归更新子树
    * 如果不相等，则完全卸载前一个子树，挂载新子树
2. 静态方法需单独复制

    高阶组件不会复制传入组件的静态方法，需要手动进行复制，可以使用npm包，或者将静态方法导出后在高阶组件中直接复制

### 使用组合避免修改原始组件

使用高阶组件是应避免修改原始组件，否则将会导致原始组件不能按照HOC增强之前使用

高阶组件与**容器组件模式**类似，容器组件将高层和低层关注点分离，由容器管理订阅和状态，并将 prop 传递给低层组件

## Refs转发

允许某些组件接受ref，并将其向下传递给子组件

* `React.createRef()`创建一个`React ref`，保存为变量ref
* 将创建的ref作为JSX属性，传递给父组件
* 使用`React.forwardRef`定义的父组件获取到第二个ref参数，此处需注意ref不属于props
* 父组件将ref参数传递给子组件
* 挂载完成后，`ref.current`指向子组件

慎用refs转发，应将其视为破坏性更改

### 高阶组件中转发refs

高阶组件中转发refs分为两步，传递ref到容器组件 + 传递ref到输入组件
1. 传递ref到容器组件类似于普通的ref转发，组件定义使用`React.forwardRef`，ref值传入使用`React.createRef()`
2. 传递ref到输入组件类似于普通的props传递，容器组件将ref作为一个特殊的props传入，之后取出，再放入输入组件中

## Fragments

<React.Fragment>可以将内部的子节点分组，但是其自身不会向DOM添加额外节点

```
<React.Fragment>
  <td>Hello</td>
  <td>World</td>
</React.Fragment>
```

* <React.Fragment>可以简写为`<></>`
* Fragment仅支持key属性，但是简写时不能使用
  ```
  <React.Fragment key={item.id}>
    <dt>{item.term}</dt>
    <dd>{item.description}</dd>
  </React.Fragment>
  ```
