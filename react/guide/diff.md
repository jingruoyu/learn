## diff操作

### diff算法

#### diff前提

将一棵树转化为另一棵树的算法复杂度为O(n^3)，代价过高

React做了两点假设，针对算法进行简化，提出时间复杂度为O(n)的算法
1. 两个不同类型的元素会产生出不同的树
2. 开发者可以通过`key`prop 来暗示哪些子元素在不同的渲染下能保持稳定

#### diff对比方法

React首先比较两棵树的根节点，不同类型的根节点元素会有不同的形态

* 比对不同类型的元素：卸载原有的树，销毁DOM，建立新的树，并执行相应的生命周期方法

	`<a>`变成`<img>`，`<Article>`变成`<Comment>`，`<Button>`变成`<div>`均属于此类情况

* 比对同一类型的元素：保留DOM及诶按，仅比对及更新改变的属性

    处理完当前节点后，React继续对子节点进行递归比对

* 比对同类型的组件元素：组件实例保持不变，state在跨域渲染时保持一致

    React会更新组件实例的props，并调用`componentWillReceiveProps()`和`componentWillUpdate()`方法

    调用完render方法后，diff算法会在之前的结果和新的结果之间进行递归

* 对子元素进行递归

    **React会同时遍历两个vDOM，如果产生差异，生成一个mutation**。所以在没有key的情况下，列表的头部添加元素代价高于尾部添加元素

#### **key**

为了解决列表新增元素问题，引入key

子元素拥有key时，React使用key来匹配两棵vDOM上的子元素，使得diff算法变得高效

应该避免使用index作为key，防止因为数据重排引发复杂度与其他不可知问题

### 性能权衡

diff是渲染过程中的一个实现细节，React可以在每个操作后对整个应用进行重新渲染，重新渲染会调用所有组件的render方法，但并不代表会卸载或重新装载组件，只会基于规则判断进行何种差异化的合并

性能优化注意点：
1. 如果两个不同类型的组件输出内容相似，应该改为使用同一类型的元素
2. key莺歌具有稳定、可预测、在列表内唯一的特性