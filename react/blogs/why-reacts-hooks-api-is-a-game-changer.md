## hook

[Why React’s new Hooks API is a game changer](https://itnext.io/why-reacts-hooks-api-is-a-game-changer-8731c2b0a8c)

React的Hooks API允许用户在组件间共享与状态有关的逻辑

React面临最大的挑战是如何在组件间灵活的共享行为以实现复用，或者只是达到关注点分离的目标。目前的每种方案都存在一些相关的问题。不过，React刚刚发布的**Hooks API**可以解决之前的大部分问题

### 之前的解决方案

#### Mixins

当React初次发布时，ES5中还没有可用的类，所以React附带了自己的类创建方法`React.createClass`，该方法将许多方法从一个对象合并到用户自己创建的组件中

但是这在类的继承上会导致一些问题，由mixins导入的方法没有文档，继承之后开发者不知道都继承到了哪些函数，如何使用。所以React在引入基于ES6的新API时，决定完全删除Mixins

#### 高阶组件 Higher Order Components

高阶组件是将高阶函数的功能边城概念应用于React组件的一种尝试。思想是将原组件包裹在提供行为的外部组件中构成最终的组件，并向其传递props。这与高阶函数通过闭包传递数据的做法类似

**优点**：可以通过props清楚看到向组件传递的数据

**缺点**：
* 高阶组件较为复杂
* 无法区分传递给HOC的数据与传递给原始组件的数据
* 组件可能依赖于HOC中的数据，删除HOC后无法工作
* 行为组件包含渲染组件，最终可能得到巨大的渲染树

    行为组件：主要用于管理状态逻辑的组件，比如HOC

#### render props

render props是最新的趋势，为HOC造成的一些问题提供了解决办法。render props通过为函数prop将子组件注入父组件，之后进行渲染，此过程中父组件可以为子组件提供一些操作和数据，此时组件是一个闭包结构

**缺点**：
* 组件嵌套层级过深
* 可能会将子组件用内联函数的形式进行传递，可能造成性能问题，详见render props与PureComponent
* 造成了很多闭包结构，但实际上组件应该是内联结构
* 导致非常冗余的组件JSX

#### class生命周期方法

React中包括了各种生命周期方法，以供开发人员在组件生命周期的特定执行时间来调用代码。React组件模型以类为起点，为这种异步调用模式提供了支持，为行为代码附加到组件提供了直观方法

存在问题：与特定功能相关的代码最终会散布在各个生命周期方法中，一个生命周期中通常包含很多不相关的操作。如事件的绑定位于Didmount，解绑willUnMount

React 14中引入了无状态的函数组件，但是当时没有提供访问生命周期的方式，使得函数组件仅能用于一些简单场景

### hooks API

2018年，React发布了hooks，解决以上问题。hooks允许状态驱动、行为共享，同时
* 提供了一种状态管理工具，并能够轻松地跟踪状态来源
* 支持返回缓存的函数，避免PureComponents导致性能问题
* 避免代码嵌套层级太深，即pyramid of doom 金字塔厄运
* 不改变传递给组件的props
* 不会创建任何额外的多余函数
* JSX更关注组件渲染，而不是组件行为
* 消除组件层层包装导致的性能问题
* 允许自定义hooks行为

**目前缺点：在组件渲染中所有的hooks方法都必须以相同的顺序执行**，这导致了hooks不能被包含在if或循环语句块中

所以目前需要使用linters插件进行语法检查以尽量避免一些不必要的问题

