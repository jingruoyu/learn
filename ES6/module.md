## 模块语法

JavaScript之前没有模块体系，社区实现了commonJS和AMD

* CommonJS：需要时require，**同步加载模块**，一般用于服务器
* AMD：依赖前置，**异步加载模块**，一般用于浏览器，代表为requireJS
* CMD：需要时require，**异步加载模块**，代表为seaJS

ES6在语言层面上实现了模块功能，可以成为浏览器和服务端通用的解决方案

### 核心思想

**ES6模块化核心思想为静态化**，在编译时确定模块的依赖关系，以及模块输入输出的变量

而CommonJS和AMD都是**运行时加载**，即如果需要从外部加载一个模块，则必须整体加载模块，生成对象，再从对象上读取需要的东西。**因为只有在运行时才能得到目标模块的对象，所以无法在编译时进行优化**

ES6的模块不是对象，而是通过export显示指定输出的代码，在通过import命令输入

ES6的模块加载是**编译时加载**，性能更好。此外可以进行代码的静态分析，从而进行更多的操作

优点：
* 不再需要umd模块格式，直接使用ES6模块格式即可

	umd是为了同时适配AMD和commonJS的一种模块格式

* 浏览器的新api可以使用模块格式提供，不必作为全局对象或navigator对象的属性
* 不再需要对象作为命名空间

### 严格模式

ES6的模块自动采用严格模式

严格模式由ES5引入，其主要限制有
* 变量必须声明后再使用
* 禁止this指向全局对象
* 不能使用在函数内部使用caller和arguments，ps.caller返回函数的调用函数，故可以使用caller获取函数的堆栈
* 增加了保留字
* ...

严格模式下，顶层的this执行undefined，即不应该在顶层代码中使用this

### export

export命令用于规定模块的对外接口，必须与模块内部的变量建立一一对应的关系，可以使用as关键字将变量重命名

export语句输出的接口，与其对应的值是**动态绑定关系**，可以通过该接口，获取模块内部实时的值

CommonJS的模块输出的是值的缓存，不存在动态更新

export命令需要位于模块顶层

### import

import命令用于输入其他模块提供的功能，加载export导出的对外接口，可以使用as关键字将变量重命名

**import命令输入的变量只读**，不允许在加载模块的脚本中改写接口。但是如果输入的是一个对象，可以更改其属性，其他模块也可以读取到更改后的值，但是不建议

import命令具有提升效果，会提升到整个模块的头部，首先执行

import是静态执行，故不可以使用表达书、变量等，这些都是动态执行的

注意点：
* import语句会执行所加载的模块，所以可以只加载模块，不指定输入变量
* 多次重复执行import，只会执行一次，即为单例模式