## 模块语法

JavaScript之前没有模块体系，社区实现了commonJS和AMD

* CommonJS：需要时require，**同步加载模块**，一般用于服务器
* AMD：依赖前置，**异步加载模块**，一般用于浏览器，代表为requireJS
* UMD：同时适配AMD和commonJS的一种模块格式
* CMD：需要时require，**异步加载模块**，代表为seaJS

ES6在语言层面上实现了模块功能，可以成为浏览器和服务端通用的解决方案

### 核心思想

**ES6模块化核心思想为静态化**，在编译时确定模块的依赖关系，以及模块输入输出的变量

而CommonJS和AMD都是**运行时加载**，即如果需要从外部加载一个模块，则必须整体加载模块，生成对象，再从对象上读取需要的东西。**因为只有在运行时才能得到目标模块的对象，所以无法在编译时进行优化**

ES6的模块不是对象，而是通过export显示指定输出的代码，在通过import命令输入

ES6的模块加载是**编译时加载**，性能更好。此外可以进行代码的静态分析，从而进行更多的操作

优点：
* 不再需要umd模块格式，直接使用ES6模块格式即可
* 浏览器的新api可以使用模块格式提供，不必作为全局对象或navigator对象的属性
* 不再需要对象作为命名空间

### 严格模式

ES6的模块自动采用严格模式

严格模式由ES5引入，其主要限制有
* 变量必须声明后再使用
* 禁止this指向全局对象
* 不能使用在函数内部使用caller和arguments，ps.caller返回函数的调用函数，故可以使用caller获取函数的堆栈
* 增加了保留字
* ...

严格模式下，顶层的this执行undefined，即不应该在顶层代码中使用this

### 浏览器特定功能

#### 模块脚本总是延迟的

与defer特性对外部脚本和内联脚本影响相同
* 下载外部模块脚本（type=module）不会影响HTML处理，会与其他资源并行加载
* 模块脚本会等到HTML完全准本就绪，才会运行
* **执行时保持脚本在文档中的相对位置顺序**

故模块脚本总是会看到已经加载完成的HTML，包括在他们下方的元素

* 普通脚本，下载完成后，立即加载并执行，从下载开始，暂停HTML解析
* async脚本，并行下载，下载完后立即执行，执行时暂停HTML解析，执行顺序与在页面出现顺序无关
* defer脚本，并行下载，在所有元素解析完成之后，DOMContentLoaded触发前执行，按照在页面中出现的顺序依次执行

#### inline脚本的async执行

对非模块的脚本而言，async属性只能用于外部代码。代码准备好后立刻执行，独立于其他脚本或HTML文档。

对模块脚本，async属性也适用于内联脚本

如果内联脚本具有async属性，则其等待内部的module下载完成之后就会立即执行，不会等待其他的代码或HTML

	可以认为是普通的脚本放在了文档的底部

#### 外部脚本

具有`type="module"`的外部脚本和普通外部脚本区别
* 具有相同src的外部脚本仅运行一次
* 从另一个元获取外部脚本需要CORS header

#### 裸模块

浏览器import必须给出相对或绝对的URL路径，没有任何路径的模块称为裸模块

打包工具可以通过配置支持裸模块，但是浏览器不支持

#### 兼容性

旧的浏览器不支持未知类型的type，故可以为type=modele的脚本提供退化方案

### export

export命令用于规定模块的对外接口，必须与模块内部的变量建立一一对应的关系，可以使用as关键字将变量重命名

export语句输出的接口，与其对应的值是**动态绑定关系**，可以通过该接口，获取模块内部实时的值

CommonJS的模块输出的是值的缓存，不存在动态更新

export命令需要位于模块顶层

#### export default

export default可以指定模块的默认输出

其实质上是将命令后面的值赋值给default变量，故

* 可以针对其使用as命令

    ```javascript
    export {add as default}

    import { default as foo } from 'modules'
    ```

* 不能在export default后定义变量
* 可以在export default后直接跟一个值

#### 重新导出

重新导入是指从其他的module中导入内容并立即将其导出（可能会更换名字）

```javascript
export { sayHi } from './sayHi'
```

重新导入的应用场景为一个大的模块可能希望通过一个单一的入口暴露模块的功能，所以入口文件会引用模块中的其他文件，并将它们的接口暴露出去

针对default，在重新导出是需要注意
* 必须使用`export {default} from './sayHi'`导出目标模块的默认导出
* `export * from './sayHi'`会只导出命名了的导出，针对默认导出必须使用第一点

	当使用`*`时，当前模块会导出目标模块的所有命名导出，可以理解为当前模块继承了目标模块

### import

import命令用于输入其他模块提供的功能，加载export导出的对外接口，可以使用as关键字将变量重命名

**import命令输入的变量只读**，不允许在加载模块的脚本中改写接口。但是如果输入的是一个对象，可以更改其属性，其他模块也可以读取到更改后的值，但是不建议

import命令具有提升效果，会提升到整个模块的头部，首先执行

import是静态执行，故不可以使用表达书、变量等，这些都是动态执行的

注意点：多次重复执行import，模块仅在第一次导入时被解析，即为单例模式。这不仅是指在同一个文件中重复导入，而是指在整个项目中

import的引入方法
* 引入目标模块的特定变量
* 整体加载目标模块

    ```javascript
    import * as circle from './circle'
    ```

    此方法可以将模块整体加载在指定对象上，该对象中途不允许改变

* 执行所加载的模块

    ```javascript
    import 'lodash'
    ```

import可以同时从一个模块中导入默认接口与其他接口

#### 动态import

普通import必须满足的条件
* 路径必须是原始类型字符串，不能是函数调用
* 必须在最顶层，不能位于条件判断或运行时导入

故增加了动态按需导入模块的import方法

`import(module)`表达式加载模块并返回一个promise，resolve为一个包含其所有导出的模块对象。

可以通过该模块对象访问模块所有的导出，其default属性指向默认导出

NOTE：import()是一种特殊语法，不属于函数调用，故不可以将import赋值给一个变量，或者对其使用call、apply等

### ES6模块与commonJS的区别

* CommonJS模块输出的是一个值的**拷贝**，ES6模块输出的是值的引用

	CommonJS输出一个值后，模块内部的变化就影响不到这个值

	ES6中会对import的变量生成**只读引用**，脚本真正执行时，再去被加载模块中取值，且不会缓存值

* CommonJS是运行时加载，ES6是编译时输出接口

	**CommonJS加载模块的是一个对象，即module.exports属性，该对象只有在脚本运行完才会生成**

	ES6模块不是一个对象，其对外接口只是一种静态定义，在代码解析阶段就会生成

* CommonJS是同步加载模块，ES6的import命令是异步加载，有一个独立模块依赖的解析阶段（也是在代码静态解析时完成）

### node中的模块加载

CommonJS本身为nodejs专用，目前node也开始支持ES6模块

* `.mjs`文件使用ES6模块加载
* `.cjs`文件使用CommonJS模块加载
* `.js`文件的加载方式由package.json中的type字段指定，可以为module或commonjs，默认为commonjs

两种加载模式尽量不要混用
* require命令不能加载ES6模块，必须使用import

	import命令可以加载commonjs模块，但是只能整体加载。因为commonjs的输入就是一个对象，不支持静态分析，只能整体加载

* `.mjs`中不能使用require，必须使用import，`.cjs`中也可以使用import()

原因是require()是同步加载，而ES6模块中可以使用顶层await，导致可能无法被同步加载

#### package.json字段简介

* type：指定模块的加载类型
* main：指定模块加载的入口文件
* exports：优先级高于main，用法多种
	* 指定子目录别名
	* 指定main的别名：子目录别名如果为`.`，则代表模块的主入口，优先级高于main字段，且可以直接作为exports的值
	* 条件加载：指定main别名时，可以指定不同加载模式的入口

#### 加载路径

ES6的加载路径必须给出脚本的完整路径，不能省略脚本后缀名

路径也支持URL路径，node会按照url规则进行解读。如果用一个脚本只要参数不同，还是会被加载多次，保存不同的缓存

### 循环依赖

循环依赖中a脚本依赖b脚本，b脚本又依赖a脚本

commonJS与ES6处理循环依赖的方法不同

#### commonJS

CommonJS加载原理：CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象

故**commonJS模块也只在第一次加载时运行一次**，以后再加载，直接从内存中返回第一次运行的结果，除非手动清除系统缓存

**CommonJS模块遇到循环加载时，会返回该模块当前已经执行部分的值，而不是全部代码执行后的值**

这一点在使用过程中需要注意，在require模块时，尽量require整个模块，而不是直接获取模块下面属性。因为该属性可能在后续发生变化

#### ES6模块循环加载

ES6模块时动态引用，会形成一个指向被加载模块的引用，需要开发者自己保证，在真正取值时可以取到值

场景：

```javascript
// a.mjs
import {bar} from './b';
console.log('a.mjs');
console.log(bar);
export let foo = 'foo';

// b.mjs
import {foo} from './a';
console.log('b.mjs');
console.log(foo);
export let bar = 'bar';
```

a中引用了b
* 执行a是发现引用了b，会优先执行b在执行a
* 执行b时发现引用了a，但此时a已经执行过，引擎会认为a这个接口已存在，继续向下执行
* 执行到打印foo变量，发现这个接口未定义，报错

解决方法为利用函数的定义提升特性，将foo定义为函数，则在a中import b之前，foo已定义
