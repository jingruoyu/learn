# 异步编程

事件机制与异步回调时Nodejs最大特点

## 回调机制

回调机制：JS主进程收到其他进程通知后，执行回调函数的操作，如`fs.readFile`等异步API

JS为单线程运行，当收到通知时，也不一定会立刻执行，而是等待当前任务执行完毕之后再执行回调

## 代码设计模式

同步代码与异步代码存在很大不同

### 函数返回值

异步函数返回值要从回调函数中获取，如果存在函数之间关于返回值的依赖关系，会造成函数嵌套

```javascript
fn2('input', function (output2) {
    fn1(output2, function (output1) {
        // Do something.
    });
});
```

### 异常处理

同步函数可以直接使用`try...catch...`捕获错误，但是异步函数由于执行机制不同，导致无法直接使用外部`try...catch...`捕获错误

**异步函数错误捕获的解决方式为使用`try...catch...`包裹异步函数的回调**，此方法在common库中也有使用，如下示

```javascript
window.setTimeout = function(fn, timer) {
    // Code execution path breaks here.
    setTimeout(function ()　{
        try {
            fn();
        } catch (err) {
            throw(err);
        }
    }, timer);
}
```

回调函数增大了异常处理的复杂度

## 域 domain

domain是一个域，即为一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出

domain和全局的异常捕获主要是为了发现和处理未预料到的编码错误，目前逐渐被废弃

## 错误处理

[node错误处理](https://imweb.io/topic/5846d2069be501ba17b10a8d)

错误可以根据维度进行划分：

* 操作错误：代码中函数内部执行错误，如JSON.parse，网络故障500等

	处理方式：
	* 明确的操作错误，可以直接处理
	* 预料之外的操作错误，记录log，然后crash，传递错误信息给客户端，由客户端进行处理

* 代码错误：代码中类型错误、参数传递错误等，真正的bug

	处理方式：直接crash

服务端的错误传递到客户端后会变为一个操作错误

同步异步错误处理：

* 同步函数使用`throw`，`try...catch`捕获
* 异步场景更多使用`callback(err, result)`，执行错误函数
* 更复杂场景使用`EventEmitter`对象事件触发，使用者监听`error`事件，错误时触发

在NodeJS官方文档里都强烈建议处理完异常后**立即重启程序**，即crash，而不是让程序继续运行，以防止内存泄漏或程序表现奇怪

## 小结

* 事件机制与异步回调时Nodejs最大特点
* 异步回调执行时间依赖于主线程任务执行情况
* 异步编程与同步编程存在较大差别，主要在于获取函数返回值
* 异步编程异常函数处理需要根据不同场景进行区分，目前全搜全部使用`try...catch`，也可以专门针对异步错误使用异步回调