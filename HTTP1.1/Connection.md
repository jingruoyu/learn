## 8 连接

### 8.1 长连接（持久连接）

当不使用长连接时，每次请求url都需要建立单独的TCP连接，此举增加了HTTP服务器的开销并且造成网络拥堵。

使用内联图片和其他一些数据资源往往需要客户端在短时间内向同一个服务端进行多次请求，可以针对此类情况建立长连接，多次请求均在一个TCP/IP连接中进行。实际`HTTP/1.1`实现的实施经验和测量结果都显示出良好的结果，同时其他替代方案也在探索中，如`T/TCP`

**HTTP长连接优点**：
* 减少建立的TCP连接数目，节省路由器和主机的CPU占用，节省主机关于TCP协议控制的内存占用
* 提高单个TCP连接的效率，减少其空闲时间。在一个连接中，HTTP请求和响应可以被流水线操作，允许客户端同时发起多个请求而不必等待每一个的响应。
* 减少网络拥塞。通过减少TCP连接与断开减少网络上的数据包从而减少网络拥塞，同时给与TCP连接足够的时间确定网络拥塞状况
* 后续请求中没有TCP的建立与三次握手，减少请求延迟
* HTTP可以更优雅，当发生错误时可以回传错误信息，而不是直接关闭TCP连接。

**HTTP长连接缺点**
* 即使是空闲状态，也会消耗服务器资源
* 重负载时，可能会遭受DoS attacks攻击。故应该尽早释放空闲连接，减轻对性能的影响

总之HTTP协议的实现应该包含长连接

#### 8.1.2 整体操作

HTTP/1.1中长连接是任何HTTP连接的**默认**行为，这是其与更早版本的HTTP协议之间一个标志性的不同。这意味着除非具有特殊声明，客户端应该申请和服务端之间建立长连接，即使服务端返回了一个错误的响应

长连接机制提供了一种机制，客户端和服务端可以通过信号控制TCP连接的关闭，其使用**`Connection`**头字段作为信号。一旦信号发出，客户端在当前连接中禁止再发送任何请求

**传输**

当`Connection`头字段值位close时，长连接将被断开。

* 如果HTTP/1.1服务器希望在返回响应后立即断开长连接，其应该将响应头中`Connection`置为close
* 如果HTTP/1.1客户端希望在本次请求后断开长连接，其应该将请求头中`Connection`置为close

长连接是否保持基于请求与响应中的`Connection`头字段，如果请求或响应任意一方的`Connection`字段为close，则该请求是当前连接中的最后一个请求

除非有特殊声明，否则当HTTP版本低于1.1时，客户端与服务端不应该采用长连接

为了保持长连接，**连接中的所有消息都必须包含一个自定义的消息长度**，如4.4中所述，当有一条消息未携带此字段，连接会被关闭。注意`Content-Length`与`Transfer-Encoding`之间联系

**流式处理（流水线技术）**

支持长连接的客户端也许会对其请求做流式处理，即可以连续发送多个请求不用等待其响应，**服务器必须按照收到请求的顺序发送其对应的响应**

* 支持长连接和流式处理的客户端，在连接建立后，如果第一次流处理失败，应该立刻重试连接
* 如果客户端进行了这样的重试，其必须知道当前连接是长连接后才会进行流式处理
* 如果服务端在发送完所有响应前关闭了连接，客户端必须重发这些请求

客户端不应该使用流式处理发送使用*非幂等*的请求方法或*非幂等性序列*的请求方法，否则过早的终止连接将会带来不可知的结果。如果客户端想要发送一个非幂等请求，应该等之前请求响应都接收到之后再发送

幂等请求方法：一种HTTP方法，多次调用不会产生不同的结果

并不是所有类型的 HTTP 请求都能用到流水线：只有idempotent 方式，比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试

#### 8.1.3 代理服务器

代理服务器必须与其连接到的客户端和源服务器（或者其他代理服务器）分别维持长连接，每个长连接都会单独占用一个传输链路

代理服务器禁止与一个HTTP/1.0的客户端建立HTTP/1.1的长连接（不过很多HTTP/1.0客户端使用`Keep-Alive`头字段，这也带来了一些问题[RFC 2068](https://tools.ietf.org/html/rfc2068)）

HTTP/1.0中视图使用`Keep-Alive`实现长连接，但是其中存在问题，部分客户端会盲目向代理服务器发送该请求头导致连接被挂起不能释放，故被废弃，目前HTTP/1.0中使用`Connection`头标志是否进行长连接

	Connection: Keep-Alive

#### 8.1.4 实践中的注意事项

当服务器通常会有一些timeout超时值，超过这个值服务器将不在保持不活动的连接。由于客户端和同一个服务端之间可能会同时存在多个连接，所以代理服务器可能会将这个值变得更大。**使用长连接的地方无需使用timeout，无论是对客户端或服务器**

当客户端或服务端希望将连接超时中断时，其应该被优雅的关闭，客户端与服务端应该不断监听另一侧的连接状况，并且做出适当响应。如果不及时检测另一端的连接状态，可能会造成网络上不必要的资源浪费

请求链中的任意一方都可能在任何时刻关闭连接，如一方在关闭的同时另一方正好在发送，因此需要各方必须能够从异步的关闭事件中恢复过来。

在客户端中
* 如果请求序列是幂等的，应该重新开启传输连接，并重新发送被中断的请求，无需用户干预
* 如果请求方法或请求序列是非幂等的，禁止自动重发

如果第二次重发仍失败，不应该继续重发请求序列

服务端中，如果可能的话，在每个连接中服务端应该至少响应一个请求。除非怀疑网络或客户端报错，服务端不应该在发送响应途中关闭连接

使用长连接时，客户端应该限制与给定服务器的并行连接数。（以下两规则紧密相连）
* 单用户客户端与任何服务器或代理的连接不应该超过两个
* 一个代理与其他另一个服务器或代理间应该最多使用`2*N`个连接，N为同时活动的用户数

这些注意事项都是为了提高HTTP的响应时间，避免网络拥塞。

### 8.2 信息传递要求

#### 8.2.1 长连接和流控制

HTTP/1.1中服务端应该维持长连接并且**使用TCP的流控制解决临时负载过重问题**，而不是关闭连接等待客户端重连，否则会恶化网络拥塞情况

#### 8.2.2 监控错误状态的连接

使用HTTP/1.1与更高协议的客户端，在传送请求发送消息体时，应该监控网络连接，以防出现错误状态。**当客户端监听到错误状态时，应该立刻停止发送消息体**。

如果正在使用`chunk`分块编码发送消息正文，则可以使用零长度块和空`trailer`来标记消息的提前结束。如果正文前面有`Content-Length`消息头，客户端必须关闭连接

#### 8.2.3 100状态(Continue)的使用

`100(continue)`状态的目的是在客户端发送请求正文前，远程服务器将基于请求头决定是否接受该请求，如果接受，返回100响应，客户端发送一个携带请求正文的请求

部分情况下，当服务端拒绝接受请求时，该状态的使用将会变得十分低效

对HTTP/1.1客户端的要求：
* 如果客户端在发送请求正文前，需要等待100响应，则必须在请求头中加入`Expect: 100-continue`项
* 当客户端不需要发送请求正文时，禁止发送`Expect: 100-continue`请求头

但是由于旧版本协议的存在，协议允许客户端发送`Expect: 100-continue`请求头后不再等待417`Expectation Failed`或100`Continue`响应。故当客户端向服务端或代理发送该请求头后，在发送请求body前不必无限等待响应的返回

对HTTP/1.1服务端的要求：
* 当收到包含`Expect: 100-continue`的请求后，服务端必须在响应100状态码，继续读取输入流和响应一个最终的状态码中二选一。源服务器禁止在发送100响应之前等待请求body的到来。如果响应了最终的状态码，则可能关闭传输连接或者继续读取但丢弃剩余的请求。如果返回最终的状态码后，将不能执行所请求的方法
* 当请求头中不包含`Expect: 100-continue`时，远程服务器不应该返回`100(continue)`响应，并且，如果该请求来自于HTTP/1.0客户端，**绝对禁止**返回该响应

	例外：服务器可能会对HTTP/1.1中PUT和POST请求返回100状态码，即使其没有该请求头。此做法目的在于最大程度上减小客户端中与100状态相关的未声明等待所造成的处理延迟，此例外仅对HTTP/1.1生效，对其他版本无效

* 在一串连贯的请求中，当服务器已经接收到一部分或者所有的请求正文时，其可能会不在发送100响应
* 远程服务器发送100状态码后，一旦开始接收和处理请求正文，就必须在整个过程完毕后返回一个最终状态码，除非服务器提起终止了连接
* 如果远程服务器接收到的请求中不包含`Expect: 100-continue`请求头，而包含请求正文，服务器将在读取全部的请求正文前响应最终状态码。在读取到全部请求正文或客户端关闭连接前，服务器不应该关闭连接，否则客户端也许并没有接收到响应消息

对HTTP/1.1代理服务器要求：

代理收到包含`Expect: 100-continue`的请求后，
* 如果其知道下一跳服务器支持HTTP/1.1或更高版本，或者不知道下一跳服务器的HTTP版本，则必须如实转发请求
* 如果其知道下一跳服务器版本是HTTP/1.0或更低，则禁止转发请求，直接响应417状态码
* 代理应该维持一份缓存，记录最近使用过的下一跳HTTP版本
* 当发出请求的客户端版本低于HTTP/1.1或其请求头中不存在`Expect: 100-continue`时，代理禁止向其转发100状态码

#### 8.2.4 服务器提前终止连接时客户端行为

如下情况客户端应该重发请求
* 客户端发送一个携带了请求正文的请求，但是请求头中没有`Expect: 100-continue`
* 客户端未能连接到一个HTTP/1.1源服务器
* 客户端在收到服务器响应前发现连接断开

客户端重发规则：
1. 和服务器之间创建一个新连接
2. 传输请求头
3. 初始化一个变量R，用于估算来回服务器双程所花时间（基于建立连接所花时间），如果双层时间不可估算，则取定值5秒
4. 计算`T = R * (2**N)`,N为重发次数
5. 等待服务器的错误响应或时间T
6. 如果未收到错误响应，则时间T后再次重发请求body
7. 如果客户端发现连接被提前关闭，则重复步骤1知道请求被接收，收到错误响应，或者用户不再等待主动关闭重发过程

当任何时刻收到错误响应时，客户端应该立刻
* 停止重发过程
* 如果请求消息未发送完，则关闭连接

## 9 请求方法 (#Method_Definitions)

**所有的请求中都必须包含Host请求头**

### 9.1 安全与幂等的方法

#### 9.1.1 安全的方法

开发者应该认识到软件代表用户在互联网上进行交互，同时应该注意让用户清楚其任何操作都将对他们自己或他人带来未知的影响

特别的，规则约定了GET和HEAD请求除了检索外，不应该具有采取其他操作的含义，即规则认为**GET和HEAD方法是安全的**。不过不能保证服务端在处理GET请求时是否会造成其他的影响，但这与请求本身没有任何关系

其允许用户代理在特殊情况下用这两种方式标识其他请求方法，如POST、PUT和DELETE，以便用户意识到正在进行的请求可能是不安全的操作

#### 9.1.2 幂等方法

幂等性：请求方法的一种属性，代表N>0次的请求造成的影响与单次请求影响（除去错误与请求过期问题）相同

* GET、HEAD、PUT与DELETE方法都具有此属性
* OPTIONS与TRACE方法不会造成影响，本身即具有幂等性

但是可能一些请求序列不是幂等的，即使其中每一个请求方法都是幂等的。幂等序列要求整个序列重新执行结果不变，或者其部分序列重新执行结果不变。同样，如果序列执行不会造成影响，则其即为幂等的

### 9.2 OPTIONS请求

OPTIONS方法表示请求`使用Request-URI标识的请求/响应链上可用的`通信设置信息，该请求方法可以使客户端确定与资源相关的一些选项或服务器的处理信息，而不用真正进行资源的请求。

**OPTIONS请求的响应无需缓存**

* 如果OPTIONS请求包含实体body，其媒体类型必须在`Content-Type`字段中说明（请求body的存在会由`Content-Length or Transfer-Encoding`说明）。

	不过HTTP/1.1协议中暂时还未定义OPTIONS请求中body的使用，将来可能会在扩展中使用body

* 如果OPTIONS请求的Request-URI是`*`，则该请求一般是针对服务器的请求，而不是针对特定资源的请求

	通常一个服务器的通信设置是因资源而异的，这种Request-URI是`*`的请求一般用于`ping`或一些空操作的方法，其仅用于客户端测试服务端的可用性。如，其可以用于测试代理是否支持HTTP/1.1

* 如果OPTIONS请求的Request-URI不是`*`，则OPTIONS请求仅针对其给定的资源，请求其对应的设置信息