## 8 连接

### 8.1 长连接（持久连接）

**注意长连接、短连接、长轮询、短轮询**

![HTTP/1.1长连接与HTTP/2.0多路复用不同](../img/HTTP1.1/http1.x_vs_2.0.jpg)

当不使用长连接时，每次请求url都需要建立单独的TCP连接，此举增加了HTTP服务器的开销并且造成网络拥堵。

使用内联图片和其他一些数据资源往往需要客户端在短时间内向同一个服务端进行多次请求，可以针对此类情况建立长连接，多次请求均在一个TCP/IP连接中进行。实际`HTTP/1.1`实现的实施经验和测量结果都显示出良好的结果，同时其他替代方案也在探索中，如`T/TCP`

**HTTP长连接优点**：
* 减少建立的TCP连接数目，节省路由器和主机的CPU占用，节省主机关于TCP协议控制的内存占用
* 提高单个TCP连接的效率，减少其空闲时间。在一个连接中，HTTP请求和响应可以被**流水线操作**，允许客户端同时发起多个请求而不必等待每一个的响应。

    HTTP/1.1与HTTP/2请求过程的不同

    * HTTP/1.0同域名下单个请求单个TCP连接，通过keep alive可以进行请求的串行发送与接收
    * HTTP/1.1同域名下多个请求单个TCP连接可以并行发送，但是响应只能**串行接收处理**，FIFO，即head of line问题，队首阻塞
    * HTTP/2同域名下多个请求单个TCP连接，并行执行，在HTTP层解决了HOL问题。不过严格讲在TCP层仍然存在HOL问题，即滑动窗口内如果有一个包未收到不会处理之后的包
    * HTTP/1.x中，同域名下浏览器同一时间进行的请求数受限，通常为6个，但是在HTTP/2中，浏览器可以立即请求所有资源

* 减少网络拥塞。通过减少TCP连接与断开减少网络上的数据包从而减少网络拥塞，同时给与TCP连接足够的时间确定网络拥塞状况
* 后续请求中没有TCP的建立与三次握手，减少请求延迟
* HTTP可以更优雅，当发生错误时可以回传错误信息，而不是直接关闭TCP连接。

**HTTP长连接缺点**
* 即使是空闲状态，也会消耗服务器资源
* 重负载时，可能会遭受DoS attacks攻击。故应该尽早释放空闲连接，减轻对性能的影响

总之HTTP协议的实现应该包含长连接

#### 8.1.2 整体操作

**HTTP/1.1中长连接是任何HTTP连接的默认行为**，这是其与更早版本的HTTP协议之间一个标志性的不同。这意味着除非具有特殊声明，客户端应该申请和服务端之间建立长连接，即使服务端返回了一个错误的响应

长连接机制提供了一种机制，客户端和服务端可以通过信号控制TCP连接的关闭，其使用**`Connection`**头字段作为信号。一旦信号发出，客户端在当前连接中禁止再发送任何请求

**传输**

当`Connection`头字段值位close时，长连接将被断开。

* 如果HTTP/1.1服务器希望在返回响应后立即断开长连接，其应该将响应头中`Connection`置为close
* 如果HTTP/1.1客户端希望在本次请求后断开长连接，其应该将请求头中`Connection`置为close

长连接是否保持基于请求与响应中的`Connection`头字段，如果请求或响应任意一方的`Connection`字段为close，则该请求是当前连接中的最后一个请求

除非有特殊声明，否则当HTTP版本低于1.1时，客户端与服务端不应该采用长连接

为了保持长连接，**连接中的所有消息都必须包含一个自定义的消息长度**，如4.4中所述，当有一条消息未携带此字段，连接会被关闭。注意`Content-Length`与`Transfer-Encoding`之间联系

**流式处理（流水线技术）**

支持长连接的客户端也许会对其请求做流式处理，即可以连续发送多个请求不用等待其响应，**服务器必须按照收到请求的顺序发送其对应的响应**

* 支持长连接和流式处理的客户端，在连接建立后，如果第一次流处理失败，应该立刻重试连接
* 如果客户端进行了这样的重试，其必须知道当前连接是长连接后才会进行流式处理
* 如果服务端在发送完所有响应前关闭了连接，客户端必须重发这些请求

客户端不应该使用流式处理发送使用*非幂等*的请求方法或*非幂等性序列*的请求方法，否则过早的终止连接将会带来不可知的结果。如果客户端想要发送一个非幂等请求，应该等之前请求响应都接收到之后再发送

幂等请求方法：一种HTTP方法，多次调用不会产生不同的结果

并不是所有类型的 HTTP 请求都能用到流水线：只有idempotent 方式，比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试

#### 8.1.3 代理服务器

代理服务器必须与其连接到的客户端和源服务器（或者其他代理服务器）分别维持长连接，每个长连接都会单独占用一个传输链路

代理服务器禁止与一个HTTP/1.0的客户端建立HTTP/1.1的长连接（不过很多HTTP/1.0客户端使用`Keep-Alive`头字段，这也带来了一些问题[RFC 2068](https://tools.ietf.org/html/rfc2068)）

HTTP/1.0中试图使用`Keep-Alive`实现长连接，但是其中存在问题，部分客户端会盲目向代理服务器发送该请求头导致连接被挂起不能释放，故被废弃，目前HTTP/1.0中使用`Connection`头标志是否进行长连接

    Connection: Keep-Alive

#### 8.1.4 实践中的注意事项

当服务器通常会有一些timeout超时值，超过这个值服务器将不在保持不活动的连接。由于客户端和同一个服务端之间可能会同时存在多个连接，所以代理服务器可能会将这个值变得更大。**使用长连接的地方无需使用timeout，无论是对客户端或服务器**

当客户端或服务端希望将连接超时中断时，其应该被优雅的关闭，客户端与服务端应该不断监听另一侧的连接状况，并且做出适当响应。如果不及时检测另一端的连接状态，可能会造成网络上不必要的资源浪费

请求链中的任意一方都可能在任何时刻关闭连接，如一方在关闭的同时另一方正好在发送，因此需要各方必须能够从异步的关闭事件中恢复过来。

在客户端中
* 如果请求序列是幂等的，应该重新开启传输连接，并重新发送被中断的请求，无需用户干预
* 如果请求方法或请求序列是非幂等的，禁止自动重发

如果第二次重发仍失败，不应该继续重发请求序列

服务端中，如果可能的话，在每个连接中服务端应该至少响应一个请求。除非怀疑网络或客户端报错，服务端不应该在发送响应途中关闭连接

使用长连接时，客户端应该限制与给定服务器的并行连接数。（以下两规则紧密相连）
* 单用户客户端与任何服务器或代理的连接不应该超过两个
* 一个代理与其他另一个服务器或代理间应该最多使用`2*N`个连接，N为同时活动的用户数

这些注意事项都是为了提高HTTP的响应时间，避免网络拥塞。

### 8.2 信息传递要求

#### 8.2.1 长连接和流控制

HTTP/1.1中服务端应该维持长连接并且**使用TCP的流控制解决临时负载过重问题**，而不是关闭连接等待客户端重连，否则会恶化网络拥塞情况

#### 8.2.2 监控错误状态的连接

使用HTTP/1.1与更高协议的客户端，在传送请求发送消息体时，应该监控网络连接，以防出现错误状态。**当客户端监听到错误状态时，应该立刻停止发送消息体**。

如果正在使用`chunk`分块编码发送消息正文，则可以使用零长度块和空`trailer`来标记消息的提前结束。如果正文前面有`Content-Length`消息头，客户端必须关闭连接

#### 8.2.3 100状态(Continue)的使用

`100(continue)`状态的目的是在客户端发送请求正文前，远程服务器将基于请求头决定是否接受该请求，如果接受，返回100响应，客户端发送一个携带请求正文的请求

部分情况下，当服务端拒绝接受请求时，该状态的使用将会变得十分低效

对HTTP/1.1客户端的要求：
* 如果客户端在发送请求正文前，需要等待100响应，则必须在请求头中加入`Expect: 100-continue`项
* 当客户端不需要发送请求正文时，禁止发送`Expect: 100-continue`请求头

但是由于旧版本协议的存在，协议允许客户端发送`Expect: 100-continue`请求头后不再等待417`Expectation Failed`或100`Continue`响应。故当客户端向服务端或代理发送该请求头后，在发送请求body前不必无限等待响应的返回

对HTTP/1.1服务端的要求：
* 当收到包含`Expect: 100-continue`的请求后，服务端必须在响应100状态码，继续读取输入流和响应一个最终的状态码中二选一。源服务器禁止在发送100响应之前等待请求body的到来。如果响应了最终的状态码，则可能关闭传输连接或者继续读取但丢弃剩余的请求。如果返回最终的状态码后，将不能执行所请求的方法
* 当请求头中不包含`Expect: 100-continue`时，远程服务器不应该返回`100(continue)`响应，并且，如果该请求来自于HTTP/1.0客户端，**绝对禁止**返回该响应

    例外：服务器可能会对HTTP/1.1中PUT和POST请求返回100状态码，即使其没有该请求头。此做法目的在于最大程度上减小客户端中与100状态相关的未声明等待所造成的处理延迟，此例外仅对HTTP/1.1生效，对其他版本无效

* 在一串连贯的请求中，当服务器已经接收到一部分或者所有的请求正文时，其可能会不在发送100响应
* 远程服务器发送100状态码后，一旦开始接收和处理请求正文，就必须在整个过程完毕后返回一个最终状态码，除非服务器提起终止了连接
* 如果远程服务器接收到的请求中不包含`Expect: 100-continue`请求头，而包含请求正文，服务器将在读取全部的请求正文前响应最终状态码。在读取到全部请求正文或客户端关闭连接前，服务器不应该关闭连接，否则客户端也许并没有接收到响应消息

对HTTP/1.1代理服务器要求：

代理收到包含`Expect: 100-continue`的请求后，
* 如果其知道下一跳服务器支持HTTP/1.1或更高版本，或者不知道下一跳服务器的HTTP版本，则必须如实转发请求
* 如果其知道下一跳服务器版本是HTTP/1.0或更低，则禁止转发请求，直接响应417状态码
* 代理应该维持一份缓存，记录最近使用过的下一跳HTTP版本
* 当发出请求的客户端版本低于HTTP/1.1或其请求头中不存在`Expect: 100-continue`时，代理禁止向其转发100状态码

#### 8.2.4 服务器提前终止连接时客户端行为

如下情况客户端应该重发请求
* 客户端发送一个携带了请求正文的请求，但是请求头中没有`Expect: 100-continue`
* 客户端未能连接到一个HTTP/1.1源服务器
* 客户端在收到服务器响应前发现连接断开

客户端重发规则：
1. 和服务器之间创建一个新连接
2. 传输请求头
3. 初始化一个变量R，用于估算来回服务器双程所花时间（基于建立连接所花时间），如果双层时间不可估算，则取定值5秒
4. 计算`T = R * (2**N)`,N为重发次数
5. 等待服务器的错误响应或时间T
6. 如果未收到错误响应，则时间T后再次重发请求body
7. 如果客户端发现连接被提前关闭，则重复步骤1知道请求被接收，收到错误响应，或者用户不再等待主动关闭重发过程

当任何时刻收到错误响应时，客户端应该立刻
* 停止重发过程
* 如果请求消息未发送完，则关闭连接

## 9 请求方法 (#Method_Definitions)

**所有的请求中都必须包含Host请求头**

### 9.1 安全与幂等的方法

#### 9.1.1 安全的方法

开发者应该认识到软件代表用户在互联网上进行交互，同时应该注意让用户清楚其任何操作都将对他们自己或他人带来未知的影响

特别的，规则约定了GET和HEAD请求除了**检索**外，不应该具有采取其他操作的含义，即规则认为**GET和HEAD方法是安全的**。不过不能保证服务端在处理GET请求时是否会造成其他的影响，但这与请求本身没有任何关系

其允许用户代理在特殊情况下用这两种方式标识其他请求方法，如POST、PUT和DELETE，以便用户意识到正在进行的请求可能是不安全的操作

#### 9.1.2 幂等方法

幂等性：请求方法的一种属性，代表N>0次的请求造成的影响与单次请求影响（除去错误与请求过期问题）相同

* GET、HEAD、PUT与DELETE方法都具有此属性
* OPTIONS与TRACE方法不会造成影响，本身即具有幂等性

但是可能一些请求序列不是幂等的，即使其中每一个请求方法都是幂等的。幂等序列要求整个序列重新执行结果不变，或者其部分序列重新执行结果不变。同样，如果序列执行不会造成影响，则其即为幂等的

### 9.2 OPTIONS请求

OPTIONS方法表示请求`使用Request-URI标识的请求/响应链上可用的`通信设置信息，该请求方法可以使客户端确定与资源相关的一些选项或服务器的处理信息，而不用真正进行资源的请求。

**OPTIONS请求的响应无需缓存**

* 如果OPTIONS请求包含实体body，其媒体类型必须在`Content-Type`字段中说明（请求body的存在会由`Content-Length or Transfer-Encoding`说明）。

    不过HTTP/1.1协议中暂时还未定义OPTIONS请求中body的使用，将来可能会在扩展中使用body

* 如果OPTIONS请求的Request-URI是`*`，则该请求一般是针对服务器的请求，而不是针对特定资源的请求

    通常一个服务器的通信设置是因资源而异的，这种Request-URI是`*`的请求一般用于`ping`或一些空操作的方法，其仅用于客户端测试服务端的可用性。如，其可以用于测试代理是否支持HTTP/1.1

* 如果OPTIONS请求的Request-URI不是`*`，则OPTIONS请求仅针对其给定的资源，请求其对应的设置信息

OPTIONS请求的200响应
* 头字段中应该包含服务器实现并适用于该资源的可选功能，可能还会包含一些其他的扩展项
* 响应正文中应该包含通信设置项信息。

如果不包含响应正文，则响应必须包含`Content-Length`头字段且取值为0

`Max-Forwards`头字段也许会在请求中使用。当代理收到一个可以转发的绝对路径OPTIONS请求时，需要检查该属性值
* 若属性值为0，则禁止转发该信息，并且应该响应自己的通信设置信息
* 若属性值为大于0整数，则当转发该信息时需要将此值递减
* 如果请求中没有这个头字段，则转发后也不能有这个头字段

### 9.3 GET请求

**GET请求表示请求由`Request-URI`标识的任何数据**

如果`Request-URI`指向了一个数据处理过程，则应该将处理完的数据放入响应实体返回，而非返回处理前的原数据

* [条件式GET请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Conditional_requests)

    当GET请求包含`If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range`头字段时，其语义会变为**条件GET请求**，请求结果依特定首部取值而定。条件GET请求的目的在于通过允许缓存实体，减少请求数量，从而减少不必要的网络传输

* [局部式请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206)

    当请求头中包含`Range`头时，GET请求会变为局部式请求。局部请求只会传输实体的一部分，不用传输客户端已经缓存的数据，节省网络流量

**GET请求可以按需进行缓存**

### 9.4 HEAD请求

除了服务端不会在响应中返回消息正文外，HEAD请求与GET请求相同，如响应头中的元信息

HEAD请求可以在避免传递消息实体的情况下获取元信息，该方法常用于测试超链接的有效性、可访问性和最近的修改

**HEAD请求的响应可以被缓存**，因为响应中包含的信息可以用于更新之前缓存的资源。如果响应中新的头字段通过`Content-Length`,`Content-MD5`,`ETag`或`Last-Modified`表明已缓存的实体与最新的实体不同，则缓存需要将目前的缓存进行过期处理

### 9.5 POST请求（非幂等）

POST方法用于向远程服务器发送请求实体，其作为由`Request-URI`标识资源的从属

POST方法被设计用于以下功能：
* 向现有资源添加注解
* 将消息发布到公告板，新闻组，邮件列表或类似的文章组
* 向数据处理过程提供数据块，如提交表单的结果
* 通过附加操作扩展数据库

实际功能由服务器决定，通常依赖于`Request-URI`

执行结果：
* POST方法的执行结果可能不会生成可以使用URI标识的结果，此时可以适当返回200(OK)或204(No Content)，具体取决于响应中是否包含描述结果的实体
* 如果远程服务器生成了新的资源，则返回201(Created)，响应实体中描述请求状态并指向新的资源，响应头中包含Location

**POST方法的响应不可缓存，除非响应中包含适当的`Cache-Control`或`Expires`头**。但是303(See Other)响应可以指示用户代理检索可缓存的资源

POST方法需要遵循安全策略与传输要求

### 9.6 PUT请求（幂等）

PUT方法将请求所包含的实体存储在提供的Request-URI下，通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容
* 如果`Request-URI`指向已存在的资源，则源服务器应该使用请求实体进行更新，此时应该返回200(OK)或204(No Content)
* 如果对应的`Request-URI`不存在，则源服务器可以为该URI创建资源，此时必须返回201(Created)

如果`Request-URI`对应的资源不能被创建或更新，应该返回响应告知原因。服务器严禁忽略`Content-*`类的请求头，如果其不能理解或实现，必须返回501(Not Implemented)响应

**PUT方法响应不可缓存**

POST与PUT方法基本差异在于请求URI的含义
* POST请求的URI标识处理请求实体的资源，其形式可能多种多样
* PUT请求的URI标识请求附带的实体，服务器不得尝试将请求应用于其他资源。如果服务器需要将其应用到其他的URI，必须返回301永久重定向，由UA决定是否进行请求的重定向

一个资源可能对应着多个不同的URI，如多个URI对应不同的版本。如果PUT方法使用一个通用URI，则可能导致其他URI对应的资源也被改变

HTTP/1.1中未定义PUT方法该如何改变服务端的状态

### 9.7 DELETE请求

DELETE方法用于请求远程服务器删除Request-URI所标识的资源。

DELETE方法在服务器上可能会因为人工干预或其他原因被拒绝
* 客户端不能保证操作已执行,即使从源服务器返回的状态码表示请求已经成功完成。
* 服务端在返回响应时，除了计划删除资源或将其移动到不可访问的位置外，其他情况不应该返回成功

当返回成功时，可以选择以下几种状态码：
* 200(OK)：响应中包含实体
* 202(Accepted)：操作尚未执行
* 204(No Content)：操作已执行，但响应中不包含实体

### 9.8 TRACE请求

TRACE方法沿着到目标资源的路径执行一个消息环回测试，请求的最终接收者应当将其接收到的消息作为200响应的实体返回。最终接收者是指远程服务器或者到达最大跳数的网关或代理

**TRACE请求不能包含请求实体**

TRACE方法允许客户端查看请求链的另一端接收到的内容
* `Via`头字段的值跟踪记录了请求链的路径
* `Max-Forwards`头字段允许客户端限制请求链的长度

如果请求是有效的，则响应的实体中应当包含请求信息，其`Content-Type`为`message/http`

TRACE请求的响应不能被缓存

### CONNECT

规范保留方法，用于代理切换到隧道连接

## 10 响应状态码

### 10.1 1xx 信息类响应

这类状态码表明一个临时的响应，该响应仅包含一个起始行和可选的响应头，并且以空行结束，对此类响应没有响应头的要求

由于HTTP/1.0没有定义1xx类的状态码，所以服务端禁止向HTTP/1.0返回1xx类响应

客户端必须做好在常规响应之前接收一个或多个1xx类响应的准备，意料之外的1xx类响应可能会被UA忽略

代理必须转发1xx响应，除非代理与客户端之间连接被关闭，或者是代理自己向服务端请求的1xx类响应

* 100 continue：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它
* 101 Switching Protocol：该状态为响应客户端的 Upgrade 标头发送的，服务器将在终止101响应的空行之后立即将协议切换到响应的Upgrade头字段定义的协议。只有当对双方有利时才会使用
* 102 Processing：服务器已经收到并正在处理请求，但没有响应可以使用
* 103 Early Hints：允许UA启动预加载资源

### 10.2 2xx 成功类响应

* 200 OK：请求成功，成功的含义取决于请求方法

	* GET：请求的资源已经在响应中发送
	* HEAD：请求的实体头已经在响应中发送，且不包含消息体
	* POST：描述操作结果的资源在消息体中传输
	* TRACE：最终服务器收到了请求

* 201 Created：该请求已成功，并因此创建了一个新的资源
* 202 Accepted：请求已经接收到，但还未响应，没有结果
* 203 Non-Authoritative Information：服务器已成功处理了请求，但返回的实体头部元信息不是来自于原始服务器，而是本地或者第三方的拷贝，可能经过代理服务器的修改
* 204 No Content：服务器成功处理响应，但不需要返回任何实体body，有时会返回更新了的元信息。

    * 204响应将**不会造成用户页面上的任何更改**
    * 204响应禁止包含响应实体，所以总是以header后的第一个空行结尾

* 205 Reset Content：重置文档视图

    服务器已经成功处理请求，UA应该重置发送请求的文档页面，便于用户的下一次输入。

    与204响应相同，禁止包含响应实体

* 206 Partial Content:服务器已经成功处理了部分GET请求，此类响应可以实现**断点续传**或者一个大文件分解为多个下载段同时下载

    **请求必须包含Range头指明请求区间**，也可以包含If-Range头作为请求条件

    对应的响应必须使用如下头字段：
    * Content-Range与Content-Length
    * Date
    * ETag and/or Content-Location
    * Expires, Cache-Control, and/or Vary

    缓存相关

    当请求使用If-Range头，响应返回206时需要避免返回其他实体头，其意义在于避免缓存实体正文与更新请求头之间的冲突。否则该响应返回的实体头与200响应相同
    * 如果使用强缓存校验，响应中不应该包含其他的实体头
    * 如果使用弱缓存校验，响应中禁止包含其他的实体头
    * 如果`ETag`或`Last-Modified`头不能被匹配，则响应不能使用缓存
    * 如果缓存不支持`Range`和`Content-Range`，则不能缓存206响应

### 10.3 3xx 重定向类

此类状态码需要UA进一步操作才能完成请求，第二个请求只能使用GET或者POST。

客户端应当检测无限重定向循环，避免网络流量浪费。在之前的版本中，会被最大重定向次数为5次

* 300 Multiple Choices

    被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向

* 301 Moved Permanently：永久重定向，**该响应可缓存**

    请求的资源已经被转移到了新的URI，将来任何针对此资源的请求都应当使用本次返回的URI。功能支持时，客户端应该讲请求地址替换为服务端返回的地址

    新的重定向地址在响应的`Location`字段中给出，除`HEAD`请求外，响应的实体还会包含简短的指向新URI的超链接

    当收到GET或HEAD请求之外的301响应时，UA禁止自动重定向请求，除非得到用户批准，因为这可能会改变发出请求的条件，如在HTTP/1.0下，301转发POST请求可能会变为GET请求

* 302 Found：临时重定向

    请求的资源暂时从其他URI响应。由于这样的重定向是暂时的的，所以客户端应当继续使用原有请求地址

    **只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。**

    重定向响应字段与响应实体与301相同，禁止自动重定向规则也和301相同

    **NOTE**：目前规则禁止客户端修改请求方法，但是大部分UA将302与303处理规则相同，无论之前请求方法是什么全部使用GET请求获取新资源。故在303和307状态码中明确服务端希望得到哪种反应

* 303 See Other

    对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用**GET**的方式访问那个资源，该方法主要用于将POST请求转化为GET请求

    303响应本身禁止被缓存，但是第二个GET请求可以被缓存

    很多HTTP/1.1之前的版本不能正确识别303响应，此时可以使用302响应代替

* 304 Not Modified

    客户端执行条件GET请求（即携带If-none-match等）且请求已被允许，而文档的内容自上次访问以来或根据请求的条件未发生改变

    304请求禁止包含请求正文，故请求始终以消息头后的第一个空行结尾

    * 如果一个304响应表明一个实体没有被缓存，则缓存必须忽略该响应然后重新发起请求，此时不携带缓存条件
    * 如果缓存使用接收到的304响应更新缓存项，则缓存必须更新该项以反映响应中给定的新字段值

* 305 Use Proxy：被请求的资源必须通过指定的代理才能被访问，废弃
* 307 Temporary Redirect

    307状态码大部分与302、303相同，不同之处在于307不会改变请求方法，POST请求重定向时，在获得用户允许后，会再次发起一个新的POST请求

### 10.4 4xx 客户端错误

4xx状态码适用于客户端出错的情况

* 400 Bad Request：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求
* 401 Unauthorized：当前请求需要用户验证
* 402 Payment Required：用于数字支付系统，未使用
* 403 Forbidden：服务器已经理解请求，但是拒绝执行它

    身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交

    * 如果请求是一个非HEAD请求，并且服务器希望公布请求为何被拒绝，则应该在实体中描述对应原因
    * 如果服务端不希望客户端知道拒绝原因，也可以返回404

* 404 Not Found：对应Request-URI资源未找到

    404状态码不能够表明此情况是永久的还是暂时的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址

    404状态码广泛用于
    * 服务器不想揭示到底为何请求被拒绝
    * 没有其他适合的响应可用

* 405 Method Not Allowed：请求行中指定的请求方法不能被用于请求Request-URI资源

    响应必须返回一个Allow头，其中列出Request-URI允许的请求方法

    PUT、DELETE方法会对服务器资源进行写操作，大部分网页服务器都不支持，均会返回405错误

* 406 Not Acceptable：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体
* 407 Proxy Authentication Required

    与401类似，但是是代理服务器需要验证，与代理服务器有关

* 408 Request Timeout：请求超时

    客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改

* 409 Conflict：由于和被请求资源的当前状态之间存在冲突，请求无法完成

    只在服务器认为用户能够解决冲突的情况下使用，且会提交新的请求。响应中包含足够信息以便用户发现冲突的源头

* 410 GONE：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址
* 411 Length Required：服务器拒绝接受未定义`Content-Length`的请求

    在增加了有效地`Content-Length`头之后，客户端可以重发请求

* 412 Precondition Failed：先决条件验证失败

    服务器验证请求头字段中给出的先决条件时，验证失败

    该状态码允许客户端在请求头中增加元数据，作为先决条件在服务器上进行判断，避免请求方法用在期望的内容之外

* 413 Request Entity Too Large：请求体过大

    请求实体过大，超出服务端接受范围，导致服务端将关闭与客户端之间的连接

    这种情况是暂时的，服务端将返回`Retry-After`头字段告知客户端多久之后重试

* 414 Request-URI Too Long

    请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。一般出现在POST请求误用GET请求发送导致参数过多

* 415 Unsupported Media Type：请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝
* 416 Requested Range Not Satisfiable：数据范围不重合

    如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码

* 417 Expectation Failed：服务器无法满足 Expect 请求标头字段指示的期望值

### 10.5 5xx 服务器错误

当服务器出错或不能执行请求时使用，响应应当包含错误情况解释，是临时错误还是永久错误，UA应该向用户进行展示

* 500 Internal Server Error：服务器遭遇未知情况
* 501 Not Implemented：请求方法不被服务器支持且无法被处理

    只有GET和HEAD是要求服务器支持的，这两种方法必定不会返回此错误代码

* 502 Bad Gateway：网关或代理处理请求时，从上游的服务器得到一个错误的响应
* 503 Service Unavailable：服务不可用

    由于暂时过载或服务器维护导致目前服务器无法处理请求，这种情况应该是短暂的，在一定延时之后会被减轻，故通常不会被缓存。

    如果延时可知，应该在响应的`Retry-After`头中告知等待时间，如果未给出等待时间，将响应当做500处理

    **NOTE：**503状态码并不是服务器过载时必须使用，一些服务器也许希望使用较为简单的状态码拒绝连接

* 504 Gateway Timeout：服务器作为网关不能及时得到响应时返回次错误
* 505 HTTP Version Not Supported：服务器不支持或拒绝支持请求中使用的HTTP协议版本

    服务器表示它无法或不愿意使用与客户机相同的主版本完成请求，响应中应该说明不支持此版本的原因与服务器支持的协议

## 11 权限鉴定

HTTP提供了几种可选的质询 - 响应认证机制，服务器可以使用它来质询客户端请求，并由客户端提供认证信息

## 12 内容协商机制

HTTP响应中包含的实体传递大量信息，但是由于用户需求、UA能力等不同，并非所有用户需要相同实体。

HTTP提供**内容协商**机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配。两种协商机制：服务端驱动型（主动型，更常见）与代理驱动型（被动型）

任何包含实体正文的响应，可能都遵循内容协商，包括错误响应

### 12.1 服务端驱动型内容协商机制

如果内容协商机制算法位于服务器端，则被称为服务端驱动型内容协商机制，协商机制基于响应的可用表示（如language、content-coding等），和请求中携带的请求头和其他详细信息（如网络地址），通过内部算法来选择最佳方案提供给客户端

服务器会使用`Vary`消息头来说明实际上哪些消息头被用作内容协商的参考依据（确切来说是与之相关的响应消息头），这样可以使缓存的运作更有效

此方法缺点：
* 无法真正得出最佳结果，应该这需要获取完整的客户端与响应信息
* 请求低效的和潜在的隐私风险
* 使得服务端实现变得复杂，规模化存在问题
* 共享缓存的效率会降低

HTTP/1.1规定描述UA能力的请求头：`Accept`、`Accept-Charset`、`Accept-Encoding`、`Accept-Language`、`User-Agent`。但是服务端也可以使用请求头之外的数据或扩展头字段

### 12.2 代理驱动型内容协商机制

在从源服务器接收到响应之后，UA从响应列表中选择出响应的最佳表示

代理驱动协商的优缺点：
* 优点是无需从请求中获知客户端能力，减轻服务端负载
* 缺点是需要第二个请求来获得最佳替代表示，第二个请求仅在使用缓存时才有效

当服务器不愿或无法使用服务器驱动协商时，可以通过300或400状态码，使用代理驱动的内容协商机制

### 12.3 透明协商机制

即为两种协商机制联合使用。

优点为分配协商工作，否则需要增大服务器负载或增加延迟