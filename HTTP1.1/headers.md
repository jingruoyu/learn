## 14 HTTP首部字段

* 通用头
* 请求头
* 响应头
* 实体头

### Cache-Control

Cache-Control中指明了必须被缓存机制执行的指令，其会覆盖缓存机制的默认算法，同一个请求与响应对的Cache-Control指令不一定相同

所有的网关或代理都必须转发Cache-Control指令，这条指令可能对整条请求响应链生效，无法为某一处特定缓存指定对应的指令

Cache-Control可以用于重写缓存指令

#### 能否缓存

* "public"：该响应可以在任何情况下被缓存，即使其一般不能被缓存或只能在非共享缓存中使用
* "private"：该响应的全部或部分仅供单个用户使用，不能用共享缓存进行存储，其他用户请求时无法使用

	private仅用于控制在何处缓存响应，不确保消息的私密性

* "no-cache"：简言之，**一般no-cache会缓存但不会使用**，不过此处存在两种用法

	1. 直接使用`no-cache`，则不得使用缓存满足后续请求
	2. 使用`no-cache=<headers>`，headers为一个或多个字段名，则可以使用缓存满足后续响应，但不得发送指定的headers

	HTTP/1.0可能不会遵循这些规则 

#### 缓存能否存储

* "no-store"：**禁止缓存**，防止敏感消息外泄或保留，保证在尽最大努力转发后尽快从易失性存储中删除信息

	* 如果在请求中发送，则缓存不得存储该请求或其任何响应的任何部分
	* 如果在响应中发送，则缓存不得存储该响应或已发它的请求的任何部分

	该属性可以改善隐私，但并不能完全去报隐私安全

#### 缓存过期机制

缓存到期机制依赖于两个首部字段
* Expires：指定缓存过期的绝对时间（HTTP/1.0）

	HTTP/1.0中Expires值如果小于或等于Date，会被视为no-cache，HTTP/1.1中作相同处理，以保持兼容性。此特性可以用于在使用缓存新特性时的兜底策略

* max-age：**优先级高于Expires，指定缓存过期的相对时间**，当使用max-age时，代表响应是可缓存的（HTTP/1.1）

	使用max-age的过期策略与本地时间无关，不受时钟不同步的影响

* s-maxage：针对共享缓存使用，优先级高于maxage与expires，会被专用缓存忽略

* min-fresh：缓存可用时间不小于当前时间 + min-fresh
* max-stale
	* 如果指定一个值，则过期时间不超过此值的响应，均可使用
	* 如果不指定值，则无论响应过期多久，都可以使用

如果缓存返回一个过期的响应，则要么是使用了max-stale，要么是响应的过期时间被覆盖

**当请求与响应均具有max-age时，会使用较小的值作为缓存的过期时间**

#### 缓存的重新生效与重新加载

* 如果源服务器错误估计了缓存过期时间，则需要缓存重新生效

	此处分两种情况，客户端有本地缓存副本的称为特定的端到端重新生效，没有本地副本的称为非特定的端到端重新生效

* 如果缓存发生了损坏，则需要缓存的重新加载

三种情况的不同处理

* 重新加载：使用no-cache，服务端禁止使用缓存响应此类请求
* 特定的端到端重新生效：使用max-age=0，迫使请求链路中的每个缓存都重新进行验证。初识请求中包含客户端现有缓存的验证条件
* 非特定的端到端重新生效：使用max-age=0，初识请求中不包含客户端现有缓存的验证条件，但之后会携带请求链路中第一份缓存的验证条件

### 通用首部字段

#### Connection

Connection首部字段用于发送方指定一些特定的连接信息，不能被代理用于其他链接

	`Connection : (connection-token)`

HTTP/1.1代理必须在转发消息前，删除与connection-token同名的任何头字段。Connection通过connection-token进行信息的传递，不使用任何附加头

* Connection头中禁止包含任何端到端的头部，例如Cache-Control
* `Connection: close`，标志着处理完当前响应后连接将会关闭

	不支持HTTP/1.1长连接的应用程序每个消息中都必须包含close

![HTTP/1.1长连接与HTTP/2.0多路复用不同](../img/HTTP1.1/http1.x_vs_2.0.jpg)

#### Date

标识该消息的发出时间，与orig-date相同予以，HTTP日期格式

除特殊情况外，源服务器必须返回Date字段：
* 响应时100或101，具体关乎服务器配置
* 服务器出错，可能不能返回可用的时间
* 服务器没有时钟，此时返回近似时间，且响应中不能使用Date等字段

**客户端应该只在包含实体主体的消息中发送Date头字段**，没有时钟的客户端不得在请求中发送Date

理论上，Date应该代表实体生成前的时刻，但实际上可以在消息发起期间的任何时间生成日期，而不会影响其语义值

#### Transfer-Encoding

Transfer-Encoding标识已将何种传输编码应用于message body，以便于在发送方与接收方之间进行安全的转换，常用的取值有chunked

与Content-Encoding区别：
* Transfer-Encoding是消息属性，应用于body，范围更大
* Content-Encoding是实体属性，应用于entity，范围更小

如果一个消息体应用了多种编码，则按照应用的顺序列出来编码格式，附加信息可由其他头字段给出

很多较旧的HTTP/1.0程序不了解Transfer-Encoding

#### Via

网关和代理必须使用via字段指示请求与响应链中的中间协议与接收者，避免请求循环以及识别请求/响应链上所有发送者的协议

### 请求首部字段

用于补充请求的附加信息、客户端信息、对响应内容的优先级等相关信息

以下挑一些看

#### Accept

指定UA能够处理的媒体类型及其相对优先级q，取值范围0-1，可缺省，默认为1.0，格式如下

	text/html;q=0.9,

服务器将优先返回权重最高的内容

#### Host

Host首部表明请求资源所在的互联网主机名与端口号，在HTTP/1.1中要求必须携带

Host存在意义在于可能在单台服务器上存在多个域名的虚拟主机，此时IP地址相同，需要使用Host进行区分

#### If-Match

条件请求使用，携带ETag值请求服务端，用于更新缓存信息，防止缓存的错误更新

* 如果任何ETag值与类似GET请求得到资源的ETag匹配，或If-match值为`*`可以匹配到所有资源，则服务器执行该请求
* 否则，服务器会响应412（条件验证失败）

**这种情况下只能使用强ETag**

当If-match的值与服务端资源不匹配时，请求不会被执行，可以避免在用户不知道远程资源更新的情况下请求成功

#### If-none-match

条件请求使用，和If-Match语义相反，用于以最小开销更新缓存信息

1. 如果任何ETag值与类似GET请求得到资源的ETag匹配，或If-none-match值为`*`可以匹配到任意资源，则继续比较步骤3Last-Modified-Since
2. 如果步骤1中比较发现不匹配，则忽略Last-Modified-Since，直接执行该请求
3. **如果资源的修改时间与`Last-Modified-Since`不匹配时，请求仍需执行**，否则请求无需执行

此处表明ETag优先级比Last-Modified-Since高，且HTTP/1.1中先比较ETag，后比较Last-Modified-Since，如果前者比较失败，则直接执行请求

返回的响应
* 对GET或HEAD请求，如果匹配一个缓存相关的header，则应该返回304
* 对其他所有的请求方法，服务器必须返回412（条件验证失败）。其他方法为非幂等，可能造成消息不对等

#### If-Modified-Since

条件请求使用，以最小的代价更新缓存信息

	If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

If-Modified-Since的使用遵循以下规则
* 如果该请求返回200之外的内容或If-Modified-Since无效时，则该请求的响应与普通GET请求相同

	当该字段值晚于服务器当前时间时，会被判定无效

* 如果请求的资源从该字段指定时间后发生变化，则请求的响应与普通GET请求相同
* 如果请求的资源从该字段指定时间后发生没有变化，则服务端应该返回304(Not Modified)响应，且不包含响应体

If-Modified-Since中的值为之前响应中服务端给定的Last-Modified，不受客户端时钟影响

请求中同时拥有`If-Modified-Since`和`If-Match`或`If-Unmodified-Since`的情况未定义，这几种header意义相反

**但是牢记，ETag优先级高于Last-Modified，服务器先比较ETag，如果成功，在比较Last-Modified，如果再成功，则返回304**

#### Referer

Referer头用于标识获取资源的地址，服务器可以根据Referer头进行请求来源的过滤、日志记录、缓存优化等操作

目前较为常见的应用为使用referer过滤请求，防止非法请求源的访问，反爬虫等

如果Request-URI是从没有自己URI的源发起的，如用户直接在地址栏输入，则不得发送Referer头字段

#### User-Agent

User-Agent头用于标识有关发起请求的用户代理信息，该字段可以包含多个产品领跑和标识代理以及构成用户代理重要组成部分的任何子产品的注释

User-Agent可以被用于如下场景
* 防盗链，即在一个app中可以打开的url在另一个app中无法打开，或进行其他提示
* 针对不同的用户代理直接展示不同的页面，如淘宝或微信中展示页面不同可能根据此原理（猜想）

#### Max-Forwards

Max-Forwards标识本条消息可以被转发的剩余次数

在`TRACE`和`OPTIONS`请求中用于限制与目标服务器之间的网关数量，可以用于客户端尝试追踪失败或循环的请求链路

每个代理或网关在接受到包含Max-Forwards标头字段的TRACE或OPTIONS请求后，都必须在转发请求之前检查并更新其值。如果接收到的值为0，则接收者不得转发请求，且必须作为最终收件人进行响应。 如果收到的Max-Forwards值大于零，则转发的消息必须包含一个更新的Max-Forwards字段，其值减1。

**对于其他请求方法，可以忽略Max-Forwards头部**

### 响应首部字段

#### Age

标识自源服务器生成响应以来经过的时间，常用于缓存服务器，十进制，以秒为单位

如果响应是由缓存生成的，则其中必须包含Age首部，Age最大为2^31，溢出后也是这个值

#### ETag

强弱ETag，见cache章节

#### Location

Location字段用于将接收方重定向到Request-URI之外的其他位置，以完成请求或标识新资源，字段值为单个绝对URI
* 对于201，指向请求创建的新资源的位置
* 对于3xx，指向服务器的首选URI，用于自动重定向到资源

### 实体首部字段

#### Content-Encoding

一般用作媒体类型的标识，用于指示已将哪种内容编码机制应用于实体，如所以需要用对应的解码机制才能获取Content-Type所标识的媒体类型

Content-Encoding主要用于允许压缩文档而不会丢失基础媒体类型的标识，**如gzip等**

如果request中的Content-Encoding不被服务器接受，则会返回415（不支持的媒体类型）

如果一个实体应用了多种编码，则应该逐一列出

#### Content-Type

指示发送给接收方的媒体类型，如果是HEAD请求，则表示当此请求时GET时的媒体类型

#### Content-Language
#### Content-Length

指示发送给接收方的实体大小，十进制，如果是HEAD请求，则表示当此请求时GET时的实体大小

注意`Content-Length`与`Transfer-Encoding`的冲突：
* 如果接收方收到的消息头中同时包含`Transfer-Encoding`和`Content-Length`，后者必须被忽略
* 消息中不能同时包含`Content-Length`头与非`identity`的`Transfer-Encoding`头，如果包含，前者将被忽略

在HTTP中，只要在传输之前可以确定消息的长度，就应该发送该消息，除非与其他规则相冲突

#### Content-Location

当可以从与请求资源的URI不同的位置访问该实体时，可以使用Content-Location字段提供资源位置

主要用于是指定要访问的资源经过内容协商后的结果URL，无需进一步的内容协商

**NOTE**

缓存不能假定当前的请求实体可以直接用于响应之后Content-Location中URI的请求，但是可以用Content-Location区分不同实体

Location与Content-Location区别：
* Location对应响应，一般用于指定重定向地址
* Content-Location对应内容，与返回的数据关联，提供可访问资源的直接地址