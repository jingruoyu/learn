## 13 HTTP缓存 重要哦

HTTP是通常用于分布式信息系统,可以对响应进行缓存提高性能

缓存的目标
* 减少发送请求：减少网络请求往返
* 减少发送完整响应：减少所需网络带宽

### 13.1 缓存存储机制

#### 13.1.1 正确的缓存

正确的缓存必须是一个使用缓存持有的最新一次的respond响应request，并且符合以下条件之一
* 通过与源服务器重新验证响应，已检查它是否与源服务器返回的内容等效。
* 缓存未超时
* 响应消息是304、305或请求错误（4xx或5xx）

当缓存无法与远程服务器通信时，如果缓存能够满足响应则应该直接使用，否则应该返回错误或警告出现通信错误

当缓存接收到响应时，应该直接转发给发出请求的客户端，即使响应已经超时也不应该添加任何或移除任何`Warning`头。响应可能在传输过程中超时，所以为了避免无穷循环，不应该由缓存在此处进行校验。当UA收到没有`Warning`的超时响应时，可能需要向用户展示一个警告信息

#### 13.1.2 告警信息

当缓存返回一个被转发来的或已经超时的响应时，HTTP/1.1应该在响应上添加`Warning`头，允许客户端进行适当的操作

`Warning`头可能被用于缓存或其他功能，使用`Warning`的目的在于区分其与真正的请求错误

`Warning`头取值有三位，第一位用于判断是否必须从存储的缓存项中删除警告，1为删除，2为不删除

#### 13.1.3 缓存控制机制

HTTP/1.1中基本的缓存控制使用`Cache-Control`头，可以在其中发送各种指令，通常这些指令会覆盖默认的缓存算法

但是部分情况下，`Cache-Control`的语义性被弱化

#### 13.1.4 UA显示缓存相关警告

UA可以覆盖基本的缓存机制，但是应该提前通过用户的显式操作进行明确配置

当用户使用十分降低缓存效率的方式覆盖缓存机制时，UA应该不断向用户提示此状态

#### 13.1.6 客户端控制缓存

缓存信息的主要来源时原始服务器，但是客户端也可以通过`Cache-Control`字段控制缓存

* 指定响应缓存的最长可使用时间，类似于max-age
* 指定响应到期前剩余的最短时间，类似于expires

### 13.2 **缓存过期模型**

#### 13.2.1 服务器指定过期时间

当缓存完全避免向源服务器发出请求时，HTTP缓存效果最佳。

避免请求的主要机制是原始服务器在将来提供明确的到期时间，表明可以使用响应来满足后续请求，缓存可以在不首先联系服务器的情况下返回新响应

源服务器可以为每一个响应分配一个过期时间，响应的缓存在用于后续请求之前进行有效性验证。即服务器使用`Expires`或`Cache-Control`中的`max-age`指令显示指定过期时间

到期时间不能用于强制用户代理刷新其显示或重新加载资源，其语义仅适用于缓存机制，并且此类机制仅需在启动对该资源的新请求时检查资源的到期状态

#### 13.2.2 启发式过期时间

源服务器不一定总会提供明确的过期时间，故HTTP缓存也会通过使用`Last-Modified`等头部字段，分配启发式的过期时间

启发式过期时间影响语义透明度，应当谨慎使用

#### 13.2.3 缓存年龄计算

缓存是否可用取决于两点：
* 缓存的当前年龄
* 缓存可用的最终时间点

本节着重于第一点

* `Date`头字段：HTTP/1.1中需要源服务器针对每个响应发送，用以标识响应生成时间
* `Age`头字段：age字段的值是指从原始服务器获取响应以来，该响应被缓存的时间长度，单位为秒

    即age字段是指源服务器在多久前创建了响应

则缓存的当前年龄 = max(当前系统时间 - Date, Age) + (now - request_time)

后面为对往返网络延迟时间的修正，此计算方法较为保守

**HTTP/1.1规定代理使用缓存创建响应时必须添加`Age`字段**，即在HTTP/1.1协议下如果发现响应中有`Age`字段，则响应不是第一手的。但是反之不可以，因为可能存在比较低的协议

#### 13.2.4 缓存过期时间计算

本节计算缓存可用时间

`Max-age`优先级高于`Expires`
* 如果响应中指定max-age，则缓存可用时间 = max-age
* 否则，如果响应指定expire，则缓存可用时间 = Expires - Date

这两种计算方法所用信息均来自源服务器，故不受客户端时钟偏差影响

当响应中没有max-age、expires，并且响应不包含其他对缓存的限制时，可以使用启发式的计算缓存可用时间

如果响应中指定`Last-Modified`，则启发式的到期时间不应该超过自该时间以来的某个时间间隔，典型设置为10%，即**取响应头中的`Date`与`Last-Modified`之间的差值的10%作为缓存有效时间**

缓存是否可用：缓存可用时间 > 已缓存时间

#### 13.2.5 边界情况

* 由于计算机制原因，可能出现同一个资源在两个缓存中过期时间不同的情况
* 如果客户端发现自身缓存的Date字段收到的非第一手响应还要新，则会忽略该响应，并使用`Cache-Control：max-age = 0`指令重试请求，以强制检查源服务器
* 如果缓存中针对同一个响应有两个条目，则应该使用Date字段更新的一个，如果相等，可以使用任意一个，更谨慎的情况下可以向服务器发起新请求

第二条中的cache-control字段即为客户端强制检查缓存，此处有两个选择
* `Cache-Control: max-age=0`：强制所有中间缓存向源服务器进行验证
* `Cache-Control: no-cache`：强制所有中间缓存从源服务器获取新副本

### 13.3 缓存对比机制

条件缓存：当缓存过期后，客户端需要向源服务器或代理验证缓存的可用情况
* 缓存良好时无需重新传输完整响应
* 缓存无效时，不用支付额外往返开销

原始服务器生成完整响应时，会附加某种验证器，缓存条目中也会保持一致。客户端发出**条件请求**时，会携带这些验证器，服务器会对验证器进行检查
* 如果匹配，返回304未修改，不携带实体主体
* 如果不匹配，返回完整响应，包含响应实体

条件请求除了携带验证器外，其他与普通请求相同

**如果响应没有携带验证器，其依然可以被缓存与使用，但是过期之后无法被刷新**

验证器字段
* `Last-Modified`：实体上次修改时间，如果自`Last-Modified`值以来未修改实体，则响应有效，单位为秒
* `ETag`：资源的唯一性标识符，弥补`Last-Modified`单位为秒的不足。分为强`ETag`和弱`ETag`

#### 13.3.3 强验证与弱验证

* 强验证：当实体发生任何变化时，验证器也会变化。可用于任意上下文
* 弱验证：仅当实体在语义上发生重大变化时，验证器才会变化，**资源更改并不总会修改弱验证器**。仅在不要求两次请求实体完全相同时可用

客户端只能使用弱验证器发出简单GET请求，不能在其他请求方式中使用

`Etag`标签通常为强验证器，但是也提供了弱验证的机制，其中弱值会随着实体含义的变化而变化

* 强ETag值：不论实体发生多么细微的变化都会改变其值
* 弱ETag值：弱ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生语义性差异时才会改变ETag 值。这时，会在字段值最开始处附加`W/`

`Last-Modified`通常被默认为弱验证器

#### 13.3.4 `Etag`与`Last-Modified`联合使用的规则

针对源服务器：
* 除非源服务器不能产生`Etag`，否则应该发送`ETag`头
* 当考虑性能因素或强`ETag`可不用时，可以使用弱`ETag`
* 源服务器应该发送`Last-Modified`

一般情况下，**HTTP/1.1源服务器更倾向于发送强`ETag`和`Last-Modified`**

针对客户端：
* 如果源服务器应提供了`ETag`，则在条件请求中`If-None-Match`或`If-Match`头必须使用该ETag
* 如果源服务器仅提供了`Last-Modified`，则条件请求中应该在`If-Modified-Since`中使用该值
* 如果源服务器提供了`ETag`和`Last-Modified`，则缓存的条件请求中两个验证器都应该使用，HTTP/1.0和1.1中均是

304响应的返回条件：
* HTTP/1.1的源服务器，在接受到包含`Last-Modified`日期或`ETag`的条件请求后，只有所有的条件请求头是符合要求时，才可以返回304
* HTTP/1.1的缓存代理，除非缓存的响应与请求中的**所有条件头字段一致**，才可以向客户端返回本地缓存的响应

	此处为所有的条件头字段，即必须ETag与Last-Modify-Since都验证通过才可以返回304，具体顺序是先ETag后Last-Modified

HTTP/1.0中ETag值会被忽略，但是部分情况下使用`Last-Modified`会导致严重问题，故
* `ETag`：HTTP/1.1提出，更精确，强ETag与弱ETag
* `Last-Modified`：兼容HTTP/1.0版本

在此之外，不会使用其他头部进行缓存验证比较

### 13.4 响应的可缓存性

当响应既没有验证器，也没有相关的显示到期时间时，期望响应不应该被缓存

客户端可以通过响应的`Date`时间戳与当前时间进行对比，判断此响应是否使用了缓存

一些情况下处于语义或安全性考虑，响应不应该被缓存：
* 包含`Authorization`头的响应，用于告知服务器用户代理的认证信息
* 当缓存不支持`Range`和`Content-Range`头时，不能缓存206（部分内容）响应

如果响应是其他的状态码，如302或307，其中没有显式的缓存控制指令(`cache-control`或`expires`)，否则不能对后续的请求返回此响应

### 13.5 从缓存中构造响应

条件缓存下，当本地缓存可用时，缓存将把条件请求的一部分与缓存的一部分组合起来返回给用户，即将新响应的部分内容与已缓存的内容组合在一起

#### 13.5.1 根据缓存分类请求头

* 端到端：传输给请求或响应的最终接收者

    响应中的端到端头必须存储为缓存条目的一部分，并且必须在由缓存条目形成的任何响应中传输

* 跳到跳：仅在传输过程中用到，不会在缓存中存储，较少，详见[文档](https://tools.ietf.org/html/rfc2616#section-13.5.1)

透明代理禁止改变或增加以下请求头：
* Content-Location
* Content-MD5
* ETag
* Last-Modified

透明代理也不能修改`Expires`，但是其可以为请求增加`Expires`头，此时取值与`Date`相同

#### 13.5.3 响应头的合并

当缓存发出条件请求得到响应后
* 如果是304，则缓存会使用缓存的实体作为响应的实体主体
* 如果是206，且ETag和Last-Modified完全匹配，则缓存会把存储在缓存中的内容与响应中接收的新内容组合，并将结果作为发送给客户端的实体主体

**响应头的变化**

此过程中，原来缓存中的响应头也会被使用，但是：

1. 304或206响应中获取到的端到端类响应必须取代从缓存中获取到的**对应**的响应头
2. 同时覆盖更新缓存中所有**对应**的端到端类响应头，`warn`头除外

该规则允许源服务器使用304或206对缓存的响应进行响应头更新，但是**此规则不会删除某一个响应头。**

#### 13.5.4 响应体按范围合并

有时缓存中可能会保存实体的若干范围，故接下来的响应只需要传输其他范围即可，然后由缓存进行合并。

如果这两部分的缓存验证器不相匹配，则只使用拥有最新`Date`值的响应，忽略其他响应中缺失的其他部分

### 13.6 缓存协商策略

缓存协商策略使用服务器驱动的协商机制，**`Vary`字段改变缓存将响应用于后续请求的协商条件和过程**，详情参阅`Vary`头字段

服务器应该使用`Vary`字段通知给缓存，用于表示哪些请求头字段被用于服务器的缓存协商策略

当缓存接收到命中缓存实体的请求后
1. 如果缓存实体中包含`Vary`字段，则会对新请求与缓存请求的`Vary`指定请求头的取值进行比较，如果完全匹配，则直接使用缓存

    **如果响应的`Vary`被指定为`*`，则之后的响应只能从源服务器获取**

2. 否则向源服务器发起条件请求

    * 如果返回304，则可以使用缓存，且新响应的响应头被用于更新缓存中的响应头
    * 如果返回其他响应码，则需要使用响应

如果缓存实体中包含ETag，则条件请求中会将其值包含在`If-None-Match`请求头中，用于服务端进行匹配

如果现有的缓存条目仅包含实体的部分内容，则条件请求中不应该使用`If-None-Match`，除非仅针对该范围进行请求

**表明ETag优先级比Last-Modified高**

当缓存收到一个成功响应，其Content-Location字段与同一Request-URI的现有缓存条目匹配，其ETag与现有条目的ETag不同，并且其Date比现有条目的Date更新 ，现有的条目应该从缓存中删除

Content-Location：用于表明报文主体返回的资源对应的URI

### 13.7 共享缓存与非共享缓存

出于安全与隐私角度考虑，缓存有必要分为共享缓存与非共享缓存。当缓存仅用于单一用户时，其是非共享的，其可访问性应该由适当的安全机制强制执行。其他情况下的缓存都是共享缓存

### 13.8 错误或部分响应的处理

缓存有时接收到的响应不是一个完整响应(响应的数据量小于Content-length中指定的值)，此时缓存可以将部分响应存储起来进行拼接，但是缓存必须意识到这是一个部分响应

此情况下，对于缓存有一定要求
1. 禁止向客户端返回使用206标识的部分响应
2. 禁止向客户端返回使用200标识的部分响应

当缓存在重新验证请求时收到5XX响应，缓存可以将错误响应直接返回给客户端，如果之前缓存的可用响应中没有必须重新校验缓存控制指令，也可以将之前响应发送给客户端

### 13.9 GET和HEAD请求的副作用

一般无需考虑这两种请求的副作用

但是如果请求的URI中带有search，可能这是一个非幂等请求，此时除非明确说明响应过期时间，否则缓存禁止缓存该响应。这是对HTTP/1.0的一个修订

### 13.10 缓存更新后的旧缓存的失效问题

* 一些HTTP方法必须导致对应的缓存实体失效，可能是Request-URI、Location或Content-Location引用的实体

	HTTP方法有POST、PUT、DELETE

* 只有缓存实体的host部分与响应的Request-URI相同时，才会执行基于Location或Content-Location中URL的失效
* 传递缓存不理解的方法时，应该使Request-URI引用的任何实体无效

### 13.11 会引起服务器资源变更的请求

除GET和POST外，其他所有可能引起服务器资源变更的请求必须由源服务器直接响应，缓存不能回复来自客户端的此类请求，因为可能引起资源的不一致问题

### 13.12 缓存的替换

缓存收到新的响应时，根据13.6节中的相关规则，判断该响应是否可以替换之前的缓存。他可以被插入到缓存存储器中，以响应之后的相关请求。缓存的替换过程中需要注意响应头的更新

**如果新响应的Date值比现有响应的Date更旧，则不应该进行缓存更新**

### 13.13 历史机制

用户的历史记录与缓存不同，历史记录旨在显示用户曾经查看的资源，即使该资源缓存已过期，也仍然应该显示在历史记录中

### 总结

1. 缓存应用的目的，减少网络请求，从而降低往返延迟与带宽需求
2. 条件请求：ETag（强验证与弱验证）与Last-Modified（资源最后修改时间），ETag为HTTP/1.1新增，优先级更高
4. 缓存控制头：Cache-Control头，取值max-age、no-cache等
5. 缓存过期时间

	* 服务器指定过期时间：Expires、max-age无需与服务端商议
	* 启发式过期时间：Last-Modified，根据响应头计算
	* 默认过期时间：响应头中的`Date`与`Last-Modified`之间的差值的10%作为缓存有效时间
·
6. 响应头合并：304或206会更新对应响应头，但是不会删除任何一个响应头
7. 缓存协商策略：`Vary`头增加被用于协商的头字段
8. 其他问题