## 13 HTTP缓存 重要哦

HTTP是通常用于分布式信息系统,可以对响应进行缓存提高性能

缓存的目标
* 减少发送请求：减少网络请求往返
* 减少发送完整响应：减少所需网络带宽

### 13.1 缓存存储机制

#### 13.1.1 正确的缓存

正确的缓存必须是一个使用缓存持有的最新一次的respond响应request，并且符合以下条件之一
* 通过与源服务器重新验证响应，已检查它是否与源服务器返回的内容等效。
* 缓存未超时
* 响应消息是304、305或请求错误（4xx或5xx）

当缓存无法与远程服务器通信时，如果缓存能够满足响应则应该直接使用，否则应该返回错误或警告出现通信错误

当缓存接收到响应时，应该直接转发给发出请求的客户端，即使响应已经超时也不应该添加任何或移除任何`Warning`头。响应可能在传输过程中超时，所以为了避免无穷循环，不应该由缓存在此处进行校验。当UA收到没有`Warning`的超时响应时，可能需要向用户展示一个警告信息

#### 13.1.2 告警信息

当缓存返回一个被转发来的或已经超时的响应时，HTTP/1.1应该在响应上添加`Warning`头，允许客户端进行适当的操作

`Warning`头可能被用于缓存或其他功能，使用`Warning`的目的在于区分其与真正的请求错误

`Warning`头取值有三位，第一位用于判断是否必须从存储的缓存项中删除警告，1为删除，2为不删除

#### 13.1.3 缓存控制机制

HTTP/1.1中基本的缓存控制使用`Cache-Control`头，可以在其中发送各种指令，通常这些指令会覆盖默认的缓存算法

但是部分情况下，`Cache-Control`的语义性被弱化

#### 13.1.4 UA显示缓存相关警告

UA可以覆盖基本的缓存机制，但是应该提前通过用户的显式操作进行明确配置

当用户使用十分降低缓存效率的方式覆盖缓存机制时，UA应该不断向用户提示此状态

#### 13.1.6 客户端控制缓存

缓存信息的主要来源时原始服务器，但是客户端也可以通过`Cache-Control`字段控制缓存

* 指定响应缓存的最长可使用时间，类似于max-age
* 指定响应到期前剩余的最短时间，类似于expires

### 13.2 **缓存过期模型**

#### 13.2.1 服务器指定过期时间

当缓存完全避免向源服务器发出请求时，HTTP缓存效果最佳。

避免请求的主要机制是原始服务器在将来提供明确的到期时间，表明可以使用响应来满足后续请求，缓存可以在不首先联系服务器的情况下返回新响应

源服务器可以为每一个响应分配一个过期时间，响应的缓存在用于后续请求之前进行有效性验证。即服务器使用`Expires`或`Cache-Control`中的`max-age`指令显示指定过期时间

到期时间不能用于强制用户代理刷新其显示或重新加载资源，其语义仅适用于缓存机制，并且此类机制仅需在启动对该资源的新请求时检查资源的到期状态

#### 13.2.2 启发式过期时间

源服务器不一定总会提供明确的过期时间，故HTTP缓存也会通过使用`Last-Modified`等头部字段，分配启发式的过期时间

启发式过期时间影响语义透明度，应当谨慎使用

#### 13.2.3 缓存年龄计算

缓存是否可用取决于两点：
* 缓存的当前年龄
* 缓存可用的最终时间点

本节着重于第一点

* `Date`头字段：HTTP/1.1中需要源服务器针对每个响应发送，用以标识响应生成时间
* `Age`头字段：age字段的值是指从原始服务器获取响应以来，该响应被缓存的时间长度，单位为秒

	即age字段是指源服务器在多久前创建了响应

则缓存的当前年龄 = max(当前系统时间 - Date, Age) + (now - request_time)

后面为对往返网络延迟时间的修正，此计算方法较为保守

**HTTP/1.1规定代理使用缓存创建响应时必须添加`Age`字段**，即在HTTP/1.1协议下如果发现响应中有`Age`字段，则响应不是第一手的。但是反之不可以，因为可能存在比较低的协议

#### 13.2.4 缓存过期时间计算

本节计算缓存可用时间

`Max-age`优先级高于`Expires`
* 如果响应中指定max-age，则缓存可用时间 = max-age
* 否则，如果响应指定expire，则缓存可用时间 = Expires - Date

这两种计算方法所用信息均来自源服务器，故不受客户端时钟偏差影响

当响应中没有max-age、expires，并且响应不包含其他对缓存的限制时，可以使用启发式的计算缓存可用时间

如果响应中指定`Last-Modified`，则启发式的到期时间不应该超过自该时间以来的某个时间间隔，典型设置为10%，即**取响应头中的`Date`与`Last-Modified`之间的差值的10%作为缓存有效时间**

缓存是否可用：缓存可用时间 > 已缓存时间

#### 13.2.5 边界情况

* 由于计算机制原因，可能出现同一个资源在两个缓存中过期时间不同的情况
* 如果客户端发现自身缓存的Date字段收到的非第一手响应还要新，则会忽略该响应，并使用`Cache-Control：max-age = 0`指令重试请求，以强制检查源服务器
* 如果缓存中针对同一个响应有两个条目，则应该使用Date字段更新的一个，如果相等，可以使用任意一个，更谨慎的情况下可以向服务器发起新请求

第二条中的cache-control字段即为客户端强制检查缓存，此处有两个选择
* `Cache-Control: max-age=0`：强制所有中间缓存向源服务器进行验证
* `Cache-Control: no-cache`：强制所有中间缓存从源服务器获取新副本

### 13.3 缓存对比机制

条件缓存：当缓存过期后，客户端需要向源服务器或代理验证缓存的可用情况
* 缓存良好时无需重新传输完整响应
* 缓存无效时，不用支付额外往返开销

原始服务器生成完整响应时，会附加某种验证器，缓存条目中也会保持一致。客户端发出**条件请求**时，会携带这些验证器，服务器会对验证器进行检查
* 如果匹配，返回304未修改，不携带实体主体
* 如果不匹配，返回完整响应，包含响应实体

条件请求除了携带验证器外，其他与普通请求相同

**如果响应没有携带验证器，其依然可以被缓存与使用，但是过期之后无法被刷新**

验证器字段
* `Last-Modified`：实体上次修改时间，如果自`Last-Modified`值以来未修改实体，则响应有效，单位为秒
* `ETag`：资源的唯一性标识符，弥补`Last-Modified`单位为秒的不足。分为强`ETag`和弱`ETag`

#### 13.3.3 强验证与弱验证

* 强验证：当实体发生任何变化时，验证器也会变化。可用于任意上下文
* 弱验证：仅当实体在语义上发生重大变化时，验证器才会变化，**资源更改并不总会修改验证器**。仅在不要求两次请求实体完全相同时可用

客户端只能使用弱验证器发出简单GET请求，不能在其他请求方式中使用

`Etag`标签通常为强验证器，但是也提供了弱验证的机制，其中弱值会随着实体含义的变化而变化

`Last-Modified`通常被默认为弱验证器